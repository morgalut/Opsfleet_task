{"content": "---\nhow-tos/use-remote-graph.md\n---\n\n# How to interact with the deployment using RemoteGraph\n\n!!! info \"Prerequisites\"\n\n- [LangGraph Platform](../concepts/langgraph_platform.md)\n    - [LangGraph Server](../concepts/langgraph_server.md)\n\n`RemoteGraph` is an interface that allows you to interact with your LangGraph Platform deployment as if it were a regular, locally-defined LangGraph graph (e.g. a `CompiledGraph`). This guide shows you how you can initialize a `RemoteGraph` and interact with it.\n\n## Initializing the graph\n\nWhen initializing a `RemoteGraph`, you must always specify:\n\n- `name`: the name of the graph you want to interact with. This is the same graph name you use in `langgraph.json` configuration file for your deployment.\n- `api_key`: a valid LangSmith API key. Can be set as an environment variable (`LANGSMITH_API_KEY`) or passed directly via the `api_key` argument. The API key could also be provided via the `client` / `sync_client` arguments, if `LangGraphClient` / `SyncLangGraphClient` were initialized with `api_key` argument.\n\nAdditionally, you have to provide one of the following:\n\n- `url`: URL of the deployment you want to interact with. If you pass `url` argument, both sync and async clients will be created using the provided URL, headers (if provided) and default configuration values (e.g. timeout, etc).\n- `client`: a `LangGraphClient` instance for interacting with the deployment asynchronously (e.g. using `.astream()`, `.ainvoke()`, `.aget_state()`, `.aupdate_state()`, etc.)\n- `sync_client`: a `SyncLangGraphClient` instance for interacting with the deployment synchronously (e.g. using `.stream()`, `.invoke()`, `.get_state()`, `.update_state()`, etc.)\n\n!!! Note\n\nIf you pass both `client` or `sync_client` as well as `url` argument, they will take precedence over the `url` argument. If none of the `client` / `sync_client` / `url` arguments are provided, `RemoteGraph` will raise a `ValueError` at runtime.\n\n### Using URL\n\n```python\nfrom langgraph.pregel.remote import RemoteGraph\n\nurl = <DEPLOYMENT_URL>\ngraph_name = \"agent\"\nremote_graph = RemoteGraph(graph_name, url=url)\n```\n\n### Using clients\n\n```python\nfrom langgraph_sdk import get_client, get_sync_client\nfrom langgraph.pregel.remote import RemoteGraph\n\nurl = <DEPLOYMENT_URL>\ngraph_name = \"agent\"\nclient = get_client(url=url)\nsync_client = get_sync_client(url=url)\nremote_graph = RemoteGraph(graph_name, client=client, sync_client=sync_client)\n```\n\n## Invoking the graph\n\nSince `RemoteGraph` is a `Runnable` that implements the same methods as `CompiledGraph`, you can interact with it the same way you normally would with a compiled graph, i.e. by calling `.invoke()`, `.stream()`, `.get_state()`, `.update_state()`, etc (as well as their async counterparts).\n\n### Asynchronously\n\n!!! Note\n\nTo use the graph asynchronously, you must provide either the `url` or `client` when initializing the `RemoteGraph`.\n\n```python\n# invoke the graph\nresult = await remote_graph.ainvoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n})\n\n# stream outputs from the graph\nasync for chunk in remote_graph.astream({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in la\"}]\n}):\n    print(chunk)\n```\n\n### Synchronously\n\n!!! Note\n\nTo use the graph synchronously, you must provide either the `url` or `sync_client` when initializing the `RemoteGraph`.\n\n```python\n# invoke the graph\nresult = remote_graph.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n})\n\n# stream outputs from the graph\nfor chunk in remote_graph.stream({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in la\"}]\n}):\n    print(chunk)\n```\n\n## Thread-level persistence\n\nBy default, the graph runs (i.e. `.invoke()` or `.stream()` invocations) are stateless - the checkpoints and the final state of the graph are not persisted. If you would like to persist the outputs of the graph run (for example, to enable human-in-the-loop features), you can create a thread and provide the thread ID via the `config` argument, same as you would with a regular compiled graph:\n\n```python\nfrom langgraph_sdk import get_sync_client\nurl = <DEPLOYMENT_URL>\ngraph_name = \"agent\"\nsync_client = get_sync_client(url=url)\nremote_graph = RemoteGraph(graph_name, url=url)\n\n# create a thread (or use an existing thread instead)\nthread = sync_client.threads.create()\n\n# invoke the graph with the thread config\nconfig = {\"configurable\": {\"thread_id\": thread[\"thread_id\"]}}\nresult = remote_graph.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n}, config=config)\n\n# verify that the state was persisted to the thread\nthread_state = remote_graph.get_state(config)\nprint(thread_state)\n```\n\n## Using as a subgraph\n\n!!! Note\n\nIf you need to use a `checkpointer` with a graph that has a `RemoteGraph` subgraph node, make sure to use UUIDs as thread IDs.\n\nSince the `RemoteGraph` behaves the same way as a regular `CompiledGraph`, it can be also used as a subgraph in another graph. For example:\n\n```python\nfrom langgraph_sdk import get_sync_client\nfrom langgraph.graph import StateGraph, MessagesState, START\nfrom typing import TypedDict\n\nurl = <DEPLOYMENT_URL>\ngraph_name = \"agent\"\nremote_graph = RemoteGraph(graph_name, url=url)\n\n# define parent graph\nbuilder = StateGraph(MessagesState)\n# add remote graph directly as a node\nbuilder.add_node(\"child\", remote_graph)\nbuilder.add_edge(START, \"child\")\ngraph = builder.compile()\n\n# invoke the parent graph\nresult = graph.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n})\nprint(result)\n\n# stream outputs from both the parent graph and subgraph\nfor chunk in graph.stream({\n    \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n}, subgraphs=True):\n    print(chunk)\n```\n\n---\nhow-tos/autogen-integration.md\n---\n\n# How to integrate LangGraph with AutoGen, CrewAI, and other frameworks\n\nThis guide shows how to integrate AutoGen agents with LangGraph to leverage features like persistence, streaming, and memory, and then deploy the integrated solution to LangGraph Platform for scalable production use. In this guide we show how to build a LangGraph chatbot that integrates with AutoGen, but you can follow the same approach with other frameworks.\n\nIntegrating AutoGen with LangGraph provides several benefits:\n\n- Enhanced features: Add [persistence](../concepts/persistence.md), [streaming](../concepts/streaming.md), [short and long-term memory](../concepts/memory.md) and more to your AutoGen agents.\n- Multi-agent systems: Build [multi-agent systems](../concepts/multi_agent.md) where individual agents are built with different frameworks.\n- Production deployment: Deploy your integrated solution to [LangGraph Platform](../concepts/langgraph_platform.md) for scalable production use.\n\n## Prerequisites\n\n- Python 3.9+\n- Autogen: `pip install autogen`\n- LangGraph: `pip install langgraph`\n- OpenAI API key\n\n## Setup\n\nSet your your environment:\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n\n## 1. Define AutoGen agent\n\nCreate an AutoGen agent that can execute code. This example is adapted from AutoGen's [official tutorials](https://github.com/microsoft/autogen/blob/0.2/notebook/agentchat_web_info.ipynb):\n\n```python\nimport autogen\nimport os\n\nconfig_list = [{\"model\": \"gpt-4o\", \"api_key\": os.environ[\"OPENAI_API_KEY\"]}]\n\nllm_config = {\n    \"timeout\": 600,\n    \"cache_seed\": 42,\n    \"config_list\": config_list,\n    \"temperature\": 0,\n}\n\nautogen_agent = autogen.AssistantAgent(\n    name=\"assistant\",\n    llm_config=llm_config,\n)\n\nuser_proxy = autogen.UserProxyAgent(\n    name=\"user_proxy\",\n    human_input_mode=\"NEVER\",\n    max_consecutive_auto_reply=10,\n    is_termination_msg=lambda x: x.get(\"content\", \"\").rstrip().endswith(\"TERMINATE\"),\n    code_execution_config={\n        \"work_dir\": \"web\",\n        \"use_docker\": False,\n    },  # Please set use_docker=True if docker is available to run the generated code. Using docker is safer than running the generated code directly.\n    llm_config=llm_config,\n    system_message=\"Reply TERMINATE if the task has been solved at full satisfaction. Otherwise, reply CONTINUE, or the reason why the task is not solved yet.\",\n)\n```\n\n## 2. Create the graph\n\nWe will now create a LangGraph chatbot graph that calls AutoGen agent.\n\n```python\nfrom langchain_core.messages import convert_to_openai_messages\nfrom langgraph.graph import StateGraph, MessagesState, START\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ndef call_autogen_agent(state: MessagesState):\n    # Convert LangGraph messages to OpenAI format for AutoGen\n    messages = convert_to_openai_messages(state[\"messages\"])\n    \n    # Get the last user message\n    last_message = messages[-1]\n    \n    # Pass previous message history as context (excluding the last message)\n    carryover = messages[:-1] if len(messages) > 1 else []\n    \n    # Initiate chat with AutoGen\n    response = user_proxy.initiate_chat(\n        autogen_agent,\n        message=last_message,\n        carryover=carryover\n    )\n    \n    # Extract the final response from the agent\n    final_content = response.chat_history[-1][\"content\"]\n    \n    # Return the response in LangGraph format\n    return {\"messages\": {\"role\": \"assistant\", \"content\": final_content}}\n\n# Create the graph with memory for persistence\ncheckpointer = InMemorySaver()\n\n# Build the graph\nbuilder = StateGraph(MessagesState)\nbuilder.add_node(\"autogen\", call_autogen_agent)\nbuilder.add_edge(START, \"autogen\")\n\n# Compile with checkpointer for persistence\ngraph = builder.compile(checkpointer=checkpointer)\n```\n\n```python\nfrom IPython.display import display, Image\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Graph](./assets/autogen-output.png)\n\n## 3. Test the graph locally\n\nBefore deploying to LangGraph Platform, you can test the graph locally:\n\n```python hl_lines=\"2 13\"\n# pass the thread ID to persist agent outputs for future interactions\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\nfor chunk in graph.stream(\n    {\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": \"Find numbers between 10 and 30 in fibonacci sequence\",\n            }\n        ]\n    },\n    config,\n):\n    print(chunk)\n```\n\n**Output:**\n```\nuser_proxy (to assistant):\n\nFind numbers between 10 and 30 in fibonacci sequence\n\n--------------------------------------------------------------------------------\nassistant (to user_proxy):\n\nTo find numbers between 10 and 30 in the Fibonacci sequence, we can generate the Fibonacci sequence and check which numbers fall within this range. Here's a plan:\n\n1. Generate Fibonacci numbers starting from 0.\n2. Continue generating until the numbers exceed 30.\n3. Collect and print the numbers that are between 10 and 30.\n\n...\n```\n\nSince we're leveraging LangGraph's [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) features we can now continue the conversation using the same thread ID -- LangGraph will automatically pass previous history to the AutoGen agent:\n\n```python hl_lines=\"10\"\nfor chunk in graph.stream(\n    {\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": \"Multiply the last number by 3\",\n            }\n        ]\n    },\n    config,\n):\n    print(chunk)\n```\n\n**Output:**\n```\nuser_proxy (to assistant):\n\nMultiply the last number by 3\nContext: \nFind numbers between 10 and 30 in fibonacci sequence\nThe Fibonacci numbers between 10 and 30 are 13 and 21.\n\nThese numbers are part of the Fibonacci sequence, which is generated by adding the two preceding numbers to get the next number, starting from 0 and 1.\n\nThe sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n\nAs you can see, 13 and 21 are the only numbers in this sequence that fall between 10 and 30.\n\nTERMINATE\n\n--------------------------------------------------------------------------------\nassistant (to user_proxy):\n\nThe last number in the Fibonacci sequence between 10 and 30 is 21. Multiplying 21 by 3 gives:\n\n21 * 3 = 63\n\nTERMINATE\n\n--------------------------------------------------------------------------------\n{'call_autogen_agent': {'messages': {'role': 'assistant', 'content': 'The last number in the Fibonacci sequence between 10 and 30 is 21. Multiplying 21 by 3 gives:\\n\\n21 * 3 = 63\\n\\nTERMINATE'}}}\n```\n\n## 4. Prepare for deployment\n\nTo deploy to LangGraph Platform, create a file structure like the following:\n\n```\nmy-autogen-agent/\n├── agent.py          # Your main agent code\n├── requirements.txt  # Python dependencies\n└── langgraph.json   # LangGraph configuration\n```\n\n=== \"agent.py\"\n\n```python\n    import os\n    import autogen\n    from langchain_core.messages import convert_to_openai_messages\n    from langgraph.graph import StateGraph, MessagesState, START\n    from langgraph.checkpoint.memory import InMemorySaver\n\n# AutoGen configuration\n    config_list = [{\"model\": \"gpt-4o\", \"api_key\": os.environ[\"OPENAI_API_KEY\"]}]\n\nllm_config = {\n        \"timeout\": 600,\n        \"cache_seed\": 42,\n        \"config_list\": config_list,\n        \"temperature\": 0,\n    }\n\n# Create AutoGen agents\n    autogen_agent = autogen.AssistantAgent(\n        name=\"assistant\",\n        llm_config=llm_config,\n    )\n\nuser_proxy = autogen.UserProxyAgent(\n        name=\"user_proxy\",\n        human_input_mode=\"NEVER\",\n        max_consecutive_auto_reply=10,\n        is_termination_msg=lambda x: x.get(\"content\", \"\").rstrip().endswith(\"TERMINATE\"),\n        code_execution_config={\n            \"work_dir\": \"/tmp/autogen_work\",\n            \"use_docker\": False,\n        },\n        llm_config=llm_config,\n        system_message=\"Reply TERMINATE if the task has been solved at full satisfaction.\",\n    )\n\ndef call_autogen_agent(state: MessagesState):\n        \"\"\"Node function that calls the AutoGen agent\"\"\"\n        messages = convert_to_openai_messages(state[\"messages\"])\n        last_message = messages[-1]\n        carryover = messages[:-1] if len(messages) > 1 else []\n        \n        response = user_proxy.initiate_chat(\n            autogen_agent,\n            message=last_message,\n            carryover=carryover\n        )\n        \n        final_content = response.chat_history[-1][\"content\"]\n        return {\"messages\": {\"role\": \"assistant\", \"content\": final_content}}\n\n# Create and compile the graph\n    def create_graph():\n        checkpointer = InMemorySaver()\n        builder = StateGraph(MessagesState)\n        builder.add_node(\"autogen\", call_autogen_agent)\n        builder.add_edge(START, \"autogen\")\n        return builder.compile(checkpointer=checkpointer)\n\n# Export the graph for LangGraph Platform\n    graph = create_graph()\n    ```\n\n=== \"requirements.txt\"\n\n```\n    langgraph>=0.1.0\n    ag2>=0.2.0\n    langchain-core>=0.1.0\n    langchain-openai>=0.0.5\n    ```\n\n=== \"langgraph.json\"\n\n```json\n    {\n    \"dependencies\": [\".\"],\n    \"graphs\": {\n        \"autogen_agent\": \"./agent.py:graph\"\n    },\n    \"env\": \".env\"\n    }\n    ```\n\n## 5. Deploy to LangGraph Platform\n\nDeploy the graph with the LangGraph Platform CLI:\n\n```\npip install -U langgraph-cli\n```\n\n```\nlanggraph deploy --config langgraph.json \n```\n\n---\nhow-tos/enable-tracing.md\n---\n\n# Enable tracing for your application\n\nTo enable [tracing](../concepts/tracing.md) for your application, set the following environment variables:\n\n```python\nexport LANGSMITH_TRACING=true\nexport LANGSMITH_API_KEY=<your-api-key>\n```\n\nFor more information, see [Trace with LangGraph](https://docs.smith.langchain.com/observability/how_to_guides/trace_with_langgraph).\n\n## Learn more\n\n- [Graph runs in LangSmith](../how-tos/run-id-langsmith.md)\n- [LangSmith Observability quickstart](https://docs.smith.langchain.com/observability)\n- [Tracing conceptual guide](https://docs.smith.langchain.com/observability/concepts#traces)\n\n---\nhow-tos/graph-api.md\n---\n\n# How to use the graph API\n\nThis guide demonstrates the basics of LangGraph's Graph API. It walks through [state](#define-and-update-state), as well as composing common graph structures such as [sequences](#create-a-sequence-of-steps), [branches](#create-branches), and [loops](#create-and-control-loops). It also covers LangGraph's control features, including the [Send API](#map-reduce-and-the-send-api) for map-reduce workflows and the [Command API](#combine-control-flow-and-state-updates-with-command) for combining state updates with \"hops\" across nodes.\n\n## Setup\n\nInstall `langgraph`:\n\n```bash\npip install -U langgraph\n```\n\n!!! tip \"Set up LangSmith for better debugging\"\n\nSign up for [LangSmith](https://smith.langchain.com) to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started in the [docs](https://docs.smith.langchain.com).\n\n## Define and update state\n\nHere we show how to define and update [state](../concepts/low_level.md#state) in LangGraph. We will demonstrate:\n\n1. How to use state to define a graph's [schema](../concepts/low_level.md#schema)\n2. How to use [reducers](../concepts/low_level.md#reducers) to control how state updates are processed.\n\n### Define state\n\n[State](../concepts/low_level.md#state) in LangGraph can be a `TypedDict`, `Pydantic` model, or dataclass. Below we will use `TypedDict`. See [this section](#use-pydantic-models-for-graph-state) for detail on using Pydantic.\n\nBy default, graphs will have the same input and output schema, and the state determines that schema. See [this section](#define-input-and-output-schemas) for how to define distinct input and output schemas.\n\nLet's consider a simple example using [messages](../concepts/low_level.md#working-with-messages-in-graph-state). This represents a versatile formulation of state for many LLM applications. See our [concepts page](../concepts/low_level.md#working-with-messages-in-graph-state) for more detail.\n\n```python\nfrom langchain_core.messages import AnyMessage\nfrom typing_extensions import TypedDict\n\nclass State(TypedDict):\n    messages: list[AnyMessage]\n    extra_field: int\n```\n\nThis state tracks a list of [message](https://python.langchain.com/docs/concepts/messages/) objects, as well as an extra integer field.\n\n### Update state\n\nLet's build an example graph with a single node. Our [node](../concepts/low_level.md#nodes) is just a Python function that reads our graph's state and makes updates to it. The first argument to this function will always be the state:\n\n```python\nfrom langchain_core.messages import AIMessage\n\ndef node(state: State):\n    messages = state[\"messages\"]\n    new_message = AIMessage(\"Hello!\")\n    return {\"messages\": messages + [new_message], \"extra_field\": 10}\n```\n\nThis node simply appends a message to our message list, and populates an extra field.\n\n!!! important\n\nNodes should return updates to the state directly, instead of mutating the state.\n\nLet's next define a simple graph containing this node. We use [StateGraph](../concepts/low_level.md#stategraph) to define a graph that operates on this state. We then use [add_node](../concepts/low_level.md#nodes) populate our graph.\n\n```python\nfrom langgraph.graph import StateGraph\n\nbuilder = StateGraph(State)\nbuilder.add_node(node)\nbuilder.set_entry_point(\"node\")\ngraph = builder.compile()\n```\n\nLangGraph provides built-in utilities for visualizing your graph. Let's inspect our graph. See [this section](#visualize-your-graph) for detail on visualization.\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Simple graph with single node](assets/graph_api_image_1.png)\n\nIn this case, our graph just executes a single node. Let's proceed with a simple invocation:\n\n```python\nfrom langchain_core.messages import HumanMessage\n\nresult = graph.invoke({\"messages\": [HumanMessage(\"Hi\")]})\nresult\n```\n\n```\n{'messages': [HumanMessage(content='Hi'), AIMessage(content='Hello!')], 'extra_field': 10}\n```\n\nNote that:\n\n- We kicked off invocation by updating a single key of the state.\n- We receive the entire state in the invocation result.\n\nFor convenience, we frequently inspect the content of [message objects](https://python.langchain.com/docs/concepts/messages/) via pretty-print:\n\n```python\nfor message in result[\"messages\"]:\n    message.pretty_print()\n```\n\n```\n================================ Human Message ================================\n\nHi\n================================== Ai Message ==================================\n\nHello!\n```\n\n### Process state updates with reducers\n\nEach key in the state can have its own independent [reducer](../concepts/low_level.md#reducers) function, which controls how updates from nodes are applied. If no reducer function is explicitly specified then it is assumed that all updates to the key should override it.\n\nFor `TypedDict` state schemas, we can define reducers by annotating the corresponding field of the state with a reducer function.\n\nIn the earlier example, our node updated the `\"messages\"` key in the state by appending a message to it. Below, we add a reducer to this key, such that updates are automatically appended:\n\n```python hl_lines=\"8\"\nfrom typing_extensions import Annotated\n\ndef add(left, right):\n    \"\"\"Can also import `add` from the `operator` built-in.\"\"\"\n    return left + right\n\nclass State(TypedDict):\n    messages: Annotated[list[AnyMessage], add]\n    extra_field: int\n```\n\nNow our node can be simplified:\n\n```python hl_lines=\"3\"\ndef node(state: State):\n    new_message = AIMessage(\"Hello!\")\n    return {\"messages\": [new_message], \"extra_field\": 10}\n```\n\n```python\nfrom langgraph.graph import START\n\ngraph = StateGraph(State).add_node(node).add_edge(START, \"node\").compile()\n\nresult = graph.invoke({\"messages\": [HumanMessage(\"Hi\")]})\n\nfor message in result[\"messages\"]:\n    message.pretty_print()\n```\n\n```\n================================ Human Message ================================\n\nHi\n================================== Ai Message ==================================\n\nHello!\n```\n\n#### MessagesState\n\nIn practice, there are additional considerations for updating lists of messages:\n\n- We may wish to update an existing message in the state.\n- We may want to accept short-hands for [message formats](../concepts/low_level.md#using-messages-in-your-graph), such as [OpenAI format](https://python.langchain.com/docs/concepts/messages/#openai-format).\n\nLangGraph includes a built-in reducer `add_messages` that handles these considerations:\n\n```python hl_lines=\"4\"\nfrom langgraph.graph.message import add_messages\n\nclass State(TypedDict):\n    messages: Annotated[list[AnyMessage], add_messages]\n    extra_field: int\n\ndef node(state: State):\n    new_message = AIMessage(\"Hello!\")\n    return {\"messages\": [new_message], \"extra_field\": 10}\n\ngraph = StateGraph(State).add_node(node).set_entry_point(\"node\").compile()\n```\n\n```python hl_lines=\"1\"\ninput_message = {\"role\": \"user\", \"content\": \"Hi\"}\n\nresult = graph.invoke({\"messages\": [input_message]})\n\nfor message in result[\"messages\"]:\n    message.pretty_print()\n```\n\n```\n================================ Human Message ================================\n\nHi\n================================== Ai Message ==================================\n\nHello!\n```\n\nThis is a versatile representation of state for applications involving [chat models](https://python.langchain.com/docs/concepts/chat_models/). LangGraph includes a pre-built `MessagesState` for convenience, so that we can have:\n\n```python\nfrom langgraph.graph import MessagesState\n\nclass State(MessagesState):\n    extra_field: int\n```\n\n### Define input and output schemas\n\nBy default, `StateGraph` operates with a single schema, and all nodes are expected to communicate using that schema. However, it's also possible to define distinct input and output schemas for a graph.\n\nWhen distinct schemas are specified, an internal schema will still be used for communication between nodes. The input schema ensures that the provided input matches the expected structure, while the output schema filters the internal data to return only the relevant information according to the defined output schema.\n\nBelow, we'll see how to define distinct input and output schema.\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom typing_extensions import TypedDict\n\n# Define the schema for the input\nclass InputState(TypedDict):\n    question: str\n\n# Define the schema for the output\nclass OutputState(TypedDict):\n    answer: str\n\n# Define the overall schema, combining both input and output\nclass OverallState(InputState, OutputState):\n    pass\n\n# Define the node that processes the input and generates an answer\ndef answer_node(state: InputState):\n    # Example answer and an extra key\n    return {\"answer\": \"bye\", \"question\": state[\"question\"]}\n\n# Build the graph with input and output schemas specified\nbuilder = StateGraph(OverallState, input_schema=InputState, output_schema=OutputState)\nbuilder.add_node(answer_node)  # Add the answer node\nbuilder.add_edge(START, \"answer_node\")  # Define the starting edge\nbuilder.add_edge(\"answer_node\", END)  # Define the ending edge\ngraph = builder.compile()  # Compile the graph\n\n# Invoke the graph with an input and print the result\nprint(graph.invoke({\"question\": \"hi\"}))\n```\n\n```\n{'answer': 'bye'}\n```\n\nNotice that the output of invoke only includes the output schema.\n\n### Pass private state between nodes\n\nIn some cases, you may want nodes to exchange information that is crucial for intermediate logic but doesn't need to be part of the main schema of the graph. This private data is not relevant to the overall input/output of the graph and should only be shared between certain nodes.\n\nBelow, we'll create an example sequential graph consisting of three nodes (node_1, node_2 and node_3), where private data is passed between the first two steps (node_1 and node_2), while the third step (node_3) only has access to the public overall state.\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom typing_extensions import TypedDict\n\n# The overall state of the graph (this is the public state shared across nodes)\nclass OverallState(TypedDict):\n    a: str\n\n# Output from node_1 contains private data that is not part of the overall state\nclass Node1Output(TypedDict):\n    private_data: str\n\n# The private data is only shared between node_1 and node_2\ndef node_1(state: OverallState) -> Node1Output:\n    output = {\"private_data\": \"set by node_1\"}\n    print(f\"Entered node `node_1`:\\n\\tInput: {state}.\\n\\tReturned: {output}\")\n    return output\n\n# Node 2 input only requests the private data available after node_1\nclass Node2Input(TypedDict):\n    private_data: str\n\ndef node_2(state: Node2Input) -> OverallState:\n    output = {\"a\": \"set by node_2\"}\n    print(f\"Entered node `node_2`:\\n\\tInput: {state}.\\n\\tReturned: {output}\")\n    return output\n\n# Node 3 only has access to the overall state (no access to private data from node_1)\ndef node_3(state: OverallState) -> OverallState:\n    output = {\"a\": \"set by node_3\"}\n    print(f\"Entered node `node_3`:\\n\\tInput: {state}.\\n\\tReturned: {output}\")\n    return output\n\n# Connect nodes in a sequence\n# node_2 accepts private data from node_1, whereas\n# node_3 does not see the private data.\nbuilder = StateGraph(OverallState).add_sequence([node_1, node_2, node_3])\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n\n# Invoke the graph with the initial state\nresponse = graph.invoke(\n    {\n        \"a\": \"set at start\",\n    }\n)\n\nprint()\nprint(f\"Output of graph invocation: {response}\")\n```\n\n```\nEntered node `node_1`:\n\tInput: {'a': 'set at start'}.\n\tReturned: {'private_data': 'set by node_1'}\nEntered node `node_2`:\n\tInput: {'private_data': 'set by node_1'}.\n\tReturned: {'a': 'set by node_2'}\nEntered node `node_3`:\n\tInput: {'a': 'set by node_2'}.\n\tReturned: {'a': 'set by node_3'}\n\nOutput of graph invocation: {'a': 'set by node_3'}\n```", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "### Use Pydantic models for graph state\n\nA [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.StateGraph) accepts a `state_schema` argument on initialization that specifies the \"shape\" of the state that the nodes in the graph can access and update.\n\nIn our examples, we typically use a python-native `TypedDict` or [`dataclass`](https://docs.python.org/3/library/dataclasses.html) for `state_schema`, but `state_schema` can be any [type](https://docs.python.org/3/library/stdtypes.html#type-objects).\n\nHere, we'll see how a [Pydantic BaseModel](https://docs.pydantic.dev/latest/api/base_model/) can be used for `state_schema` to add run-time validation on **inputs**.\n\n!!! note \"Known Limitations\"\n\n- Currently, the output of the graph will **NOT** be an instance of a pydantic model. \n    - Run-time validation only occurs on inputs into nodes, not on the outputs. \n    - The validation error trace from pydantic does not show which node the error arises in. \n    - Pydantic's recursive validation can be slow. For performance-sensitive applications, you may want to consider using a `dataclass` instead.\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom typing_extensions import TypedDict\nfrom pydantic import BaseModel\n\n# The overall state of the graph (this is the public state shared across nodes)\nclass OverallState(BaseModel):\n    a: str\n\ndef node(state: OverallState):\n    return {\"a\": \"goodbye\"}\n\n# Build the state graph\nbuilder = StateGraph(OverallState)\nbuilder.add_node(node)  # node_1 is the first node\nbuilder.add_edge(START, \"node\")  # Start the graph with node_1\nbuilder.add_edge(\"node\", END)  # End the graph after node_1\ngraph = builder.compile()\n\n# Test the graph with a valid input\ngraph.invoke({\"a\": \"hello\"})\n```\n\nInvoke the graph with an **invalid** input\n\n```python\ntry:\n    graph.invoke({\"a\": 123})  # Should be a string\nexcept Exception as e:\n    print(\"An exception was raised because `a` is an integer rather than a string.\")\n    print(e)\n```\n\n```\nAn exception was raised because `a` is an integer rather than a string.\n1 validation error for OverallState\na\n  Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    For further information visit https://errors.pydantic.dev/2.9/v/string_type\n```\n\nSee below for additional features of Pydantic model state:\n\n??? example \"Serialization Behavior\"\n\nWhen using Pydantic models as state schemas, it's important to understand how serialization works, especially when:\n    - Passing Pydantic objects as inputs\n    - Receiving outputs from the graph\n    - Working with nested Pydantic models\n\nLet's see these behaviors in action.\n\n```python\n    from langgraph.graph import StateGraph, START, END\n    from pydantic import BaseModel\n\nclass NestedModel(BaseModel):\n        value: str\n\nclass ComplexState(BaseModel):\n        text: str\n        count: int\n        nested: NestedModel\n\ndef process_node(state: ComplexState):\n        # Node receives a validated Pydantic object\n        print(f\"Input state type: {type(state)}\")\n        print(f\"Nested type: {type(state.nested)}\")\n        # Return a dictionary update\n        return {\"text\": state.text + \" processed\", \"count\": state.count + 1}\n\n# Build the graph\n    builder = StateGraph(ComplexState)\n    builder.add_node(\"process\", process_node)\n    builder.add_edge(START, \"process\")\n    builder.add_edge(\"process\", END)\n    graph = builder.compile()\n\n# Create a Pydantic instance for input\n    input_state = ComplexState(text=\"hello\", count=0, nested=NestedModel(value=\"test\"))\n    print(f\"Input object type: {type(input_state)}\")\n\n# Invoke graph with a Pydantic instance\n    result = graph.invoke(input_state)\n    print(f\"Output type: {type(result)}\")\n    print(f\"Output content: {result}\")\n\n# Convert back to Pydantic model if needed\n    output_model = ComplexState(**result)\n    print(f\"Converted back to Pydantic: {type(output_model)}\")\n    ```\n\n??? example \"Runtime Type Coercion\"\n\nPydantic performs runtime type coercion for certain data types. This can be helpful but also lead to unexpected behavior if you're not aware of it.\n\n```python\n    from langgraph.graph import StateGraph, START, END\n    from pydantic import BaseModel\n\nclass CoercionExample(BaseModel):\n        # Pydantic will coerce string numbers to integers\n        number: int\n        # Pydantic will parse string booleans to bool\n        flag: bool\n\ndef inspect_node(state: CoercionExample):\n        print(f\"number: {state.number} (type: {type(state.number)})\")\n        print(f\"flag: {state.flag} (type: {type(state.flag)})\")\n        return {}\n\nbuilder = StateGraph(CoercionExample)\n    builder.add_node(\"inspect\", inspect_node)\n    builder.add_edge(START, \"inspect\")\n    builder.add_edge(\"inspect\", END)\n    graph = builder.compile()\n\n# Demonstrate coercion with string inputs that will be converted\n    result = graph.invoke({\"number\": \"42\", \"flag\": \"true\"})\n\n# This would fail with a validation error\n    try:\n        graph.invoke({\"number\": \"not-a-number\", \"flag\": \"true\"})\n    except Exception as e:\n        print(f\"\\nExpected validation error: {e}\")\n    ```\n\n??? example \"Working with Message Models\"\n\nWhen working with LangChain message types in your state schema, there are important considerations for serialization. You should use `AnyMessage` (rather than `BaseMessage`) for proper serialization/deserialization when using message objects over the wire.\n\n```python\n    from langgraph.graph import StateGraph, START, END\n    from pydantic import BaseModel\n    from langchain_core.messages import HumanMessage, AIMessage, AnyMessage\n    from typing import List\n\nclass ChatState(BaseModel):\n        messages: List[AnyMessage]\n        context: str\n\ndef add_message(state: ChatState):\n        return {\"messages\": state.messages + [AIMessage(content=\"Hello there!\")]}\n\nbuilder = StateGraph(ChatState)\n    builder.add_node(\"add_message\", add_message)\n    builder.add_edge(START, \"add_message\")\n    builder.add_edge(\"add_message\", END)\n    graph = builder.compile()\n\n# Create input with a message\n    initial_state = ChatState(\n        messages=[HumanMessage(content=\"Hi\")], context=\"Customer support chat\"\n    )\n\nresult = graph.invoke(initial_state)\n    print(f\"Output: {result}\")\n\n# Convert back to Pydantic model to see message types\n    output_model = ChatState(**result)\n    for i, msg in enumerate(output_model.messages):\n        print(f\"Message {i}: {type(msg).__name__} - {msg.content}\")\n    ```\n\n## Add runtime configuration\n\nSometimes you want to be able to configure your graph when calling it. For example, you might want to be able to specify what LLM or system prompt to use at runtime, _without polluting the graph state with these parameters_.\n\nTo add runtime configuration:\n\n1. Specify a schema for your configuration\n2. Add the configuration to the function signature for nodes or conditional edges\n3. Pass the configuration into the graph.\n\nSee below for a simple example:\n\n```python hl_lines=\"13 14 16 21 29 30\"\nfrom langgraph.graph import END, StateGraph, START\nfrom langgraph.runtime import Runtime\nfrom typing_extensions import TypedDict\n\n# 1. Specify config schema\nclass ContextSchema(TypedDict):\n    my_runtime_value: str\n\n# 2. Define a graph that accesses the config in a node\nclass State(TypedDict):\n    my_state_value: str\n\ndef node(state: State, runtime: Runtime[ContextSchema]):\n    if runtime.context[\"my_runtime_value\"] == \"a\":\n        return {\"my_state_value\": 1}\n    elif runtime.context[\"my_runtime_value\"] == \"b\":\n        return {\"my_state_value\": 2}\n    else:\n        raise ValueError(\"Unknown values.\")\n\nbuilder = StateGraph(State, context_schema=ContextSchema)\nbuilder.add_node(node)\nbuilder.add_edge(START, \"node\")\nbuilder.add_edge(\"node\", END)\n\ngraph = builder.compile()\n\n# 3. Pass in configuration at runtime:\nprint(graph.invoke({}, context={\"my_runtime_value\": \"a\"}))\nprint(graph.invoke({}, context={\"my_runtime_value\": \"b\"}))\n```\n\n```\n{'my_state_value': 1}\n{'my_state_value': 2}\n```\n\n??? example \"Extended example: specifying LLM at runtime\"\n\nBelow we demonstrate a practical example in which we configure what LLM to use at runtime. We will use both OpenAI and Anthropic models.\n\n```python\n    from dataclasses import dataclass\n\nfrom langchain.chat_models import init_chat_model\n    from langgraph.graph import MessagesState, END, StateGraph, START\n    from langgraph.runtime import Runtime\n    from typing_extensions import TypedDict\n\n@dataclass\n    class ContextSchema:\n        model_provider: str = \"anthropic\"\n\nMODELS = {\n        \"anthropic\": init_chat_model(\"anthropic:claude-3-5-haiku-latest\"),\n        \"openai\": init_chat_model(\"openai:gpt-4.1-mini\"),\n    }\n\ndef call_model(state: MessagesState, runtime: Runtime[ContextSchema]):\n        model = MODELS[runtime.context.model_provider]\n        response = model.invoke(state[\"messages\"])\n        return {\"messages\": [response]}\n\nbuilder = StateGraph(MessagesState, context_schema=ContextSchema)\n    builder.add_node(\"model\", call_model)\n    builder.add_edge(START, \"model\")\n    builder.add_edge(\"model\", END)\n\ngraph = builder.compile()\n\n# Usage\n    input_message = {\"role\": \"user\", \"content\": \"hi\"}\n    # With no configuration, uses default (Anthropic)\n    response_1 = graph.invoke({\"messages\": [input_message]}, context=ContextSchema())[\"messages\"][-1]\n    # Or, can set OpenAI\n    response_2 = graph.invoke({\"messages\": [input_message]}, context={\"model_provider\": \"openai\"})[\"messages\"][-1]\n\nprint(response_1.response_metadata[\"model_name\"])\n    print(response_2.response_metadata[\"model_name\"])\n    ```\n    ```\n    claude-3-5-haiku-20241022\n    gpt-4.1-mini-2025-04-14\n    ```\n\n??? example \"Extended example: specifying model and system message at runtime\"\n\nBelow we demonstrate a practical example in which we configure two parameters: the LLM and system message to use at runtime.\n\n```python\n    from dataclasses import dataclass\n    from typing import Optional\n    from langchain.chat_models import init_chat_model\n    from langchain_core.messages import SystemMessage\n    from langgraph.graph import END, MessagesState, StateGraph, START\n    from langgraph.runtime import Runtime\n    from typing_extensions import TypedDict\n\n@dataclass\n    class ContextSchema:\n        model_provider: str = \"anthropic\"\n        system_message: str | None = None\n\nMODELS = {\n        \"anthropic\": init_chat_model(\"anthropic:claude-3-5-haiku-latest\"),\n        \"openai\": init_chat_model(\"openai:gpt-4.1-mini\"),\n    }\n\ndef call_model(state: MessagesState, runtime: Runtime[ContextSchema]):\n        model = MODELS[runtime.context.model_provider]\n        messages = state[\"messages\"]\n        if (system_message := runtime.context.system_message):\n            messages = [SystemMessage(system_message)] + messages\n        response = model.invoke(messages)\n        return {\"messages\": [response]}\n\nbuilder = StateGraph(MessagesState, context_schema=ContextSchema)\n    builder.add_node(\"model\", call_model)\n    builder.add_edge(START, \"model\")\n    builder.add_edge(\"model\", END)\n\ngraph = builder.compile()\n\n# Usage\n    input_message = {\"role\": \"user\", \"content\": \"hi\"}\n    response = graph.invoke({\"messages\": [input_message]}, context={\"model_provider\": \"openai\", \"system_message\": \"Respond in Italian.\"})\n    for message in response[\"messages\"]:\n        message.pretty_print()\n    ```\n    ```\n    ================================ Human Message ================================\n\nhi\n    ================================== Ai Message ==================================\n\nCiao! Come posso aiutarti oggi?\n    ```\n\n## Add retry policies\n\nThere are many use cases where you may wish for your node to have a custom retry policy, for example if you are calling an API, querying a database, or calling an LLM, etc. LangGraph lets you add retry policies to nodes.\n\nTo configure a retry policy, pass the `retry_policy` parameter to the [add_node](../reference/graphs.md#langgraph.graph.state.StateGraph.add_node). The `retry_policy` parameter takes in a `RetryPolicy` named tuple object. Below we instantiate a `RetryPolicy` object with the default parameters and associate it with a node:\n\n```python\nfrom langgraph.types import RetryPolicy\n\nbuilder.add_node(\n    \"node_name\",\n    node_function,\n    retry_policy=RetryPolicy(),\n)\n```\n\nBy default, the `retry_on` parameter uses the `default_retry_on` function, which retries on any exception except for the following:\n\n- `ValueError`\n- `TypeError`\n- `ArithmeticError`\n- `ImportError`\n- `LookupError`\n- `NameError`\n- `SyntaxError`\n- `RuntimeError`\n- `ReferenceError`\n- `StopIteration`\n- `StopAsyncIteration`\n- `OSError`\n\nIn addition, for exceptions from popular http request libraries such as `requests` and `httpx` it only retries on 5xx status codes.\n\n??? example \"Extended example: customizing retry policies\"\n\nConsider an example in which we are reading from a SQL database. Below we pass two different retry policies to nodes:\n\n```python\n    import sqlite3\n    from typing_extensions import TypedDict\n    from langchain.chat_models import init_chat_model\n    from langgraph.graph import END, MessagesState, StateGraph, START\n    from langgraph.types import RetryPolicy\n    from langchain_community.utilities import SQLDatabase\n    from langchain_core.messages import AIMessage\n\ndb = SQLDatabase.from_uri(\"sqlite:///:memory:\")\n    model = init_chat_model(\"anthropic:claude-3-5-haiku-latest\")\n\ndef query_database(state: MessagesState):\n        query_result = db.run(\"SELECT * FROM Artist LIMIT 10;\")\n        return {\"messages\": [AIMessage(content=query_result)]}\n\ndef call_model(state: MessagesState):\n        response = model.invoke(state[\"messages\"])\n        return {\"messages\": [response]}\n\n# Define a new graph\n    builder = StateGraph(MessagesState)\n    builder.add_node(\n        \"query_database\",\n        query_database,\n        retry_policy=RetryPolicy(retry_on=sqlite3.OperationalError),\n    )\n    builder.add_node(\"model\", call_model, retry_policy=RetryPolicy(max_attempts=5))\n    builder.add_edge(START, \"model\")\n    builder.add_edge(\"model\", \"query_database\")\n    builder.add_edge(\"query_database\", END)\n    graph = builder.compile()\n    ```\n\n## Add node caching\n\nNode caching is useful in cases where you want to avoid repeating operations, like when doing something expensive (either in terms of time or cost). LangGraph lets you add individualized caching policies to nodes in a graph.\n\nTo configure a cache policy, pass the `cache_policy` parameter to the [add_node](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.state.StateGraph.add_node) function. In the following example, a [`CachePolicy`](https://langchain-ai.github.io/langgraph/reference/types/?h=cachepolicy#langgraph.types.CachePolicy) object is instantiated with a time to live of 120 seconds and the default `key_func` generator. Then it is associated with a node:\n\n```python\nfrom langgraph.types import CachePolicy\n\nbuilder.add_node(\n    \"node_name\",\n    node_function,\n    cache_policy=CachePolicy(ttl=120),\n)\n```\n\nThen, to enable node-level caching for a graph, set the `cache` argument when compiling the graph. The example below uses `InMemoryCache` to set up a graph with in-memory cache, but `SqliteCache` is also available.\n\n```python\nfrom langgraph.cache.memory import InMemoryCache\n\ngraph = builder.compile(cache=InMemoryCache())\n```\n\n## Create a sequence of steps\n\n!!! info \"Prerequisites\"\n\nThis guide assumes familiarity with the above section on [state](#define-and-update-state).\n\nHere we demonstrate how to construct a simple sequence of steps. We will show:\n\n1. How to build a sequential graph\n2. Built-in short-hand for constructing similar graphs.\n\nTo add a sequence of nodes, we use the `.add_node` and `.add_edge` methods of our [graph](../concepts/low_level.md#stategraph):\n\n```python\nfrom langgraph.graph import START, StateGraph\n\nbuilder = StateGraph(State)\n\n# Add nodes\nbuilder.add_node(step_1)\nbuilder.add_node(step_2)\nbuilder.add_node(step_3)\n\n# Add edges\nbuilder.add_edge(START, \"step_1\")\nbuilder.add_edge(\"step_1\", \"step_2\")\nbuilder.add_edge(\"step_2\", \"step_3\")\n```\n\nWe can also use the built-in shorthand `.add_sequence`:\n\n```python\nbuilder = StateGraph(State).add_sequence([step_1, step_2, step_3])\nbuilder.add_edge(START, \"step_1\")\n```\n\n??? info \"Why split application steps into a sequence with LangGraph?\"\n    LangGraph makes it easy to add an underlying persistence layer to your application.\n    This allows state to be checkpointed in between the execution of nodes, so your LangGraph nodes govern:\n\n- How state updates are [checkpointed](../concepts/persistence.md)\n- How interruptions are resumed in [human-in-the-loop](../concepts/human_in_the_loop.md) workflows\n- How we can \"rewind\" and branch-off executions using LangGraph's [time travel](../concepts/time-travel.md) features\n\nThey also determine how execution steps are [streamed](../concepts/streaming.md), and how your application is visualized\nand debugged using [LangGraph Studio](../concepts/langgraph_studio.md).\n\nLet's demonstrate an end-to-end example. We will create a sequence of three steps:\n\n1. Populate a value in a key of the state\n2. Update the same value\n3. Populate a different value\n\nLet's first define our [state](../concepts/low_level.md#state). This governs the [schema of the graph](../concepts/low_level.md#schema), and can also specify how to apply updates. See [this section](#process-state-updates-with-reducers) for more detail.\n\nIn our case, we will just keep track of two values:\n\n```python\nfrom typing_extensions import TypedDict\n\nclass State(TypedDict):\n    value_1: str\n    value_2: int\n```\n\nOur [nodes](../concepts/low_level.md#nodes) are just Python functions that read our graph's state and make updates to it. The first argument to this function will always be the state:\n\n```python\ndef step_1(state: State):\n    return {\"value_1\": \"a\"}\n\ndef step_2(state: State):\n    current_value_1 = state[\"value_1\"]\n    return {\"value_1\": f\"{current_value_1} b\"}\n\ndef step_3(state: State):\n    return {\"value_2\": 10}\n```\n\n!!! note\n\nNote that when issuing updates to the state, each node can just specify the value of the key it wishes to update.\n\nBy default, this will **overwrite** the value of the corresponding key. You can also use [reducers](../concepts/low_level.md#reducers) to control how updates are processed— for example, you can append successive updates to a key instead. See [this section](#process-state-updates-with-reducers) for more detail.\n\nFinally, we define the graph. We use [StateGraph](../concepts/low_level.md#stategraph) to define a graph that operates on this state.\n\nWe will then use [add_node](../concepts/low_level.md#messagesstate) and [add_edge](../concepts/low_level.md#edges) to populate our graph and define its control flow.\n\n```python\nfrom langgraph.graph import START, StateGraph\n\nbuilder = StateGraph(State)\n\n# Add nodes\nbuilder.add_node(step_1)\nbuilder.add_node(step_2)\nbuilder.add_node(step_3)\n\n# Add edges\nbuilder.add_edge(START, \"step_1\")\nbuilder.add_edge(\"step_1\", \"step_2\")\nbuilder.add_edge(\"step_2\", \"step_3\")\n```\n\n!!! tip \"Specifying custom names\"\n\nYou can specify custom names for nodes using `.add_node`:\n\n```python\n    builder.add_node(\"my_node\", step_1)\n    ```\n\nNote that:\n\n- `.add_edge` takes the names of nodes, which for functions defaults to `node.__name__`.\n- We must specify the entry point of the graph. For this we add an edge with the [START node](../concepts/low_level.md#start-node).\n- The graph halts when there are no more nodes to execute.\n\nWe next [compile](../concepts/low_level.md#compiling-your-graph) our graph. This provides a few basic checks on the structure of the graph (e.g., identifying orphaned nodes). If we were adding persistence to our application via a [checkpointer](../concepts/persistence.md), it would also be passed in here.\n\n```python\ngraph = builder.compile()\n```\n\nLangGraph provides built-in utilities for visualizing your graph. Let's inspect our sequence. See [this guide](#visualize-your-graph) for detail on visualization.\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Sequence of steps graph](assets/graph_api_image_2.png)\n\nLet's proceed with a simple invocation:\n\n```python\ngraph.invoke({\"value_1\": \"c\"})\n```\n\n```\n{'value_1': 'a b', 'value_2': 10}\n```\n\nNote that:\n\n- We kicked off invocation by providing a value for a single state key. We must always provide a value for at least one key.\n- The value we passed in was overwritten by the first node.\n- The second node updated the value.\n- The third node populated a different value.\n\n!!! tip \"Built-in shorthand\"\n\n`langgraph>=0.2.46` includes a built-in short-hand `add_sequence` for adding node sequences. You can compile the same graph as follows:\n\n```python hl_lines=\"1\"\n    builder = StateGraph(State).add_sequence([step_1, step_2, step_3])\n    builder.add_edge(START, \"step_1\")\n\ngraph = builder.compile()\n\ngraph.invoke({\"value_1\": \"c\"})\n    ```\n\n## Create branches\n\nParallel execution of nodes is essential to speed up overall graph operation. LangGraph offers native support for parallel execution of nodes, which can significantly enhance the performance of graph-based workflows. This parallelization is achieved through fan-out and fan-in mechanisms, utilizing both standard edges and [conditional_edges](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.MessageGraph.add_conditional_edges). Below are some examples showing how to add create branching dataflows that work for you.\n\n### Run graph nodes in parallel\n\nIn this example, we fan out from `Node A` to `B and C` and then fan in to `D`. With our state, [we specify the reducer add operation](https://langchain-ai.github.io/langgraph/concepts/low_level.md#reducers). This will combine or accumulate values for the specific key in the State, rather than simply overwriting the existing value. For lists, this means concatenating the new list with the existing list. See the above section on [state reducers](#process-state-updates-with-reducers) for more detail on updating state with reducers.\n\n```python\nimport operator\nfrom typing import Annotated, Any\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n    # The operator.add reducer fn makes this append-only\n    aggregate: Annotated[list, operator.add]\n\ndef a(state: State):\n    print(f'Adding \"A\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"A\"]}\n\ndef b(state: State):\n    print(f'Adding \"B\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"B\"]}\n\ndef c(state: State):\n    print(f'Adding \"C\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"C\"]}\n\ndef d(state: State):\n    print(f'Adding \"D\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"D\"]}\n\nbuilder = StateGraph(State)\nbuilder.add_node(a)\nbuilder.add_node(b)\nbuilder.add_node(c)\nbuilder.add_node(d)\nbuilder.add_edge(START, \"a\")\nbuilder.add_edge(\"a\", \"b\")\nbuilder.add_edge(\"a\", \"c\")\nbuilder.add_edge(\"b\", \"d\")\nbuilder.add_edge(\"c\", \"d\")\nbuilder.add_edge(\"d\", END)\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Parallel execution graph](assets/graph_api_image_3.png)\n\nWith the reducer, you can see that the values added in each node are accumulated.\n\n```python\ngraph.invoke({\"aggregate\": []}, {\"configurable\": {\"thread_id\": \"foo\"}})\n```\n\n```\nAdding \"A\" to []\nAdding \"B\" to ['A']\nAdding \"C\" to ['A']\nAdding \"D\" to ['A', 'B', 'C']\n```\n\n!!! note\n\nIn the above example, nodes `\"b\"` and `\"c\"` are executed concurrently in the same [superstep](../concepts/low_level.md#graphs). Because they are in the same step, node `\"d\"` executes after both `\"b\"` and `\"c\"` are finished.\n\nImportantly, updates from a parallel superstep may not be ordered consistently. If you need a consistent, predetermined ordering of updates from a parallel superstep, you should write the outputs to a separate field in the state together with a value with which to order them.\n\n??? note \"Exception handling?\"\n\nLangGraph executes nodes within [supersteps](../concepts/low_level.md#graphs), meaning that while parallel branches are executed in parallel, the entire superstep is **transactional**. If any of these branches raises an exception, **none** of the updates are applied to the state (the entire superstep errors).\n\nImportantly, when using a [checkpointer](../concepts/persistence.md), results from successful nodes within a superstep are saved, and don't repeat when resumed.\n\nIf you have error-prone (perhaps want to handle flakey API calls), LangGraph provides two ways to address this:\n\n1. You can write regular python code within your node to catch and handle exceptions.\n    2. You can set a **[retry_policy](../reference/types.md#langgraph.types.RetryPolicy)** to direct the graph to retry nodes that raise certain types of exceptions. Only failing branches are retried, so you needn't worry about performing redundant work.\n\nTogether, these let you perform parallel execution and fully control exception handling.\n\n### Defer node execution\n\nDeferring node execution is useful when you want to delay the execution of a node until all other pending tasks are completed. This is particularly relevant when branches have different lengths, which is common in workflows like map-reduce flows.\n\nThe above example showed how to fan-out and fan-in when each path was only one step. But what if one branch had more than one step? Let's add a node `\"b_2\"` in the `\"b\"` branch:\n\n```python hl_lines=\"35\"\nimport operator\nfrom typing import Annotated, Any\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n    # The operator.add reducer fn makes this append-only\n    aggregate: Annotated[list, operator.add]\n\ndef a(state: State):\n    print(f'Adding \"A\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"A\"]}\n\ndef b(state: State):\n    print(f'Adding \"B\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"B\"]}\n\ndef b_2(state: State):\n    print(f'Adding \"B_2\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"B_2\"]}\n\ndef c(state: State):\n    print(f'Adding \"C\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"C\"]}\n\ndef d(state: State):\n    print(f'Adding \"D\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"D\"]}\n\nbuilder = StateGraph(State)\nbuilder.add_node(a)\nbuilder.add_node(b)\nbuilder.add_node(b_2)\nbuilder.add_node(c)\nbuilder.add_node(d, defer=True)\nbuilder.add_edge(START, \"a\")\nbuilder.add_edge(\"a\", \"b\")\nbuilder.add_edge(\"a\", \"c\")\nbuilder.add_edge(\"b\", \"b_2\")\nbuilder.add_edge(\"b_2\", \"d\")\nbuilder.add_edge(\"c\", \"d\")\nbuilder.add_edge(\"d\", END)\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Deferred execution graph](assets/graph_api_image_4.png)\n\n```python\ngraph.invoke({\"aggregate\": []})\n```\n\n```\nAdding \"A\" to []\nAdding \"B\" to ['A']\nAdding \"C\" to ['A']\nAdding \"B_2\" to ['A', 'B', 'C']\nAdding \"D\" to ['A', 'B', 'C', 'B_2']\n```\n\nIn the above example, nodes `\"b\"` and `\"c\"` are executed concurrently in the same superstep. We set `defer=True` on node `d` so it will not execute until all pending tasks are finished. In this case, this means that `\"d\"` waits to execute until the entire `\"b\"` branch is finished.\n\n### Conditional branching\n\nIf your fan-out should vary at runtime based on the state, you can use [add_conditional_edges](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.StateGraph.add_conditional_edges) to select one or more paths using the graph state. See example below, where node `a` generates a state update that determines the following node.\n\n```python hl_lines=\"14 37\"\nimport operator\nfrom typing import Annotated, Literal, Sequence\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "class State(TypedDict):\n    aggregate: Annotated[list, operator.add]\n    # Add a key to the state. We will set this key to determine\n    # how we branch.\n    which: str\n\ndef a(state: State):\n    print(f'Adding \"A\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"A\"], \"which\": \"c\"}\n\ndef b(state: State):\n    print(f'Adding \"B\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"B\"]}\n\ndef c(state: State):\n    print(f'Adding \"C\" to {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"C\"]}\n\nbuilder = StateGraph(State)\nbuilder.add_node(a)\nbuilder.add_node(b)\nbuilder.add_node(c)\nbuilder.add_edge(START, \"a\")\nbuilder.add_edge(\"b\", END)\nbuilder.add_edge(\"c\", END)\n\ndef conditional_edge(state: State) -> Literal[\"b\", \"c\"]:\n    # Fill in arbitrary logic here that uses the state\n    # to determine the next node\n    return state[\"which\"]\n\nbuilder.add_conditional_edges(\"a\", conditional_edge)\n\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Conditional branching graph](assets/graph_api_image_5.png)\n\n```python\nresult = graph.invoke({\"aggregate\": []})\nprint(result)\n```\n\n```\nAdding \"A\" to []\nAdding \"C\" to ['A']\n{'aggregate': ['A', 'C'], 'which': 'c'}\n```\n\n!!! tip\n\nYour conditional edges can route to multiple destination nodes. For example:\n\n```python\n    def route_bc_or_cd(state: State) -> Sequence[str]:\n        if state[\"which\"] == \"cd\":\n            return [\"c\", \"d\"]\n        return [\"b\", \"c\"]\n    ```\n\n## Map-Reduce and the Send API\n\nLangGraph supports map-reduce and other advanced branching patterns using the Send API. Here is an example of how to use it:\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.types import Send\nfrom typing_extensions import TypedDict, Annotated\nimport operator\n\nclass OverallState(TypedDict):\n    topic: str\n    subjects: list[str]\n    jokes: Annotated[list[str], operator.add]\n    best_selected_joke: str\n\ndef generate_topics(state: OverallState):\n    return {\"subjects\": [\"lions\", \"elephants\", \"penguins\"]}\n\ndef generate_joke(state: OverallState):\n    joke_map = {\n        \"lions\": \"Why don't lions like fast food? Because they can't catch it!\",\n        \"elephants\": \"Why don't elephants use computers? They're afraid of the mouse!\",\n        \"penguins\": \"Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice.\"\n    }\n    return {\"jokes\": [joke_map[state[\"subject\"]]]}\n\ndef continue_to_jokes(state: OverallState):\n    return [Send(\"generate_joke\", {\"subject\": s}) for s in state[\"subjects\"]]\n\ndef best_joke(state: OverallState):\n    return {\"best_selected_joke\": \"penguins\"}\n\nbuilder = StateGraph(OverallState)\nbuilder.add_node(\"generate_topics\", generate_topics)\nbuilder.add_node(\"generate_joke\", generate_joke)\nbuilder.add_node(\"best_joke\", best_joke)\nbuilder.add_edge(START, \"generate_topics\")\nbuilder.add_conditional_edges(\"generate_topics\", continue_to_jokes, [\"generate_joke\"])\nbuilder.add_edge(\"generate_joke\", \"best_joke\")\nbuilder.add_edge(\"best_joke\", END)\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Map-reduce graph with fanout](assets/graph_api_image_6.png)\n\n```python\n# Call the graph: here we call it to generate a list of jokes\nfor step in graph.stream({\"topic\": \"animals\"}):\n    print(step)\n```\n\n```\n{'generate_topics': {'subjects': ['lions', 'elephants', 'penguins']}}\n{'generate_joke': {'jokes': [\"Why don't lions like fast food? Because they can't catch it!\"]}}\n{'generate_joke': {'jokes': [\"Why don't elephants use computers? They're afraid of the mouse!\"]}}\n{'generate_joke': {'jokes': ['Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice.']}}\n{'best_joke': {'best_selected_joke': 'penguins'}}\n```\n\n## Create and control loops\n\nWhen creating a graph with a loop, we require a mechanism for terminating execution. This is most commonly done by adding a [conditional edge](../concepts/low_level.md#conditional-edges) that routes to the [END](../concepts/low_level.md#end-node) node once we reach some termination condition.\n\nYou can also set the graph recursion limit when invoking or streaming the graph. The recursion limit sets the number of [supersteps](../concepts/low_level.md#graphs) that the graph is allowed to execute before it raises an error. Read more about the concept of recursion limits [here](../concepts/low_level.md#recursion-limit).\n\nLet's consider a simple graph with a loop to better understand how these mechanisms work.\n\n!!! tip\n\nTo return the last value of your state instead of receiving a recursion limit error, see the [next section](#impose-a-recursion-limit).\n\nWhen creating a loop, you can include a conditional edge that specifies a termination condition:\n\n```python\nbuilder = StateGraph(State)\nbuilder.add_node(a)\nbuilder.add_node(b)\n\ndef route(state: State) -> Literal[\"b\", END]:\n    if termination_condition(state):\n        return END\n    else:\n        return \"b\"\n\nbuilder.add_edge(START, \"a\")\nbuilder.add_conditional_edges(\"a\", route)\nbuilder.add_edge(\"b\", \"a\")\ngraph = builder.compile()\n```\n\nTo control the recursion limit, specify `\"recursionLimit\"` in the config. This will raise a `GraphRecursionError`, which you can catch and handle:\n\n```python\nfrom langgraph.errors import GraphRecursionError\n\ntry:\n    graph.invoke(inputs, {\"recursion_limit\": 3})\nexcept GraphRecursionError:\n    print(\"Recursion Error\")\n```\n\nLet's define a graph with a simple loop. Note that we use a conditional edge to implement a termination condition.\n\n```python\nimport operator\nfrom typing import Annotated, Literal\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n    # The operator.add reducer fn makes this append-only\n    aggregate: Annotated[list, operator.add]\n\ndef a(state: State):\n    print(f'Node A sees {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"A\"]}\n\ndef b(state: State):\n    print(f'Node B sees {state[\"aggregate\"]}')\n    return {\"aggregate\": [\"B\"]}\n\n# Define nodes\nbuilder = StateGraph(State)\nbuilder.add_node(a)\nbuilder.add_node(b)\n\n# Define edges\ndef route(state: State) -> Literal[\"b\", END]:\n    if len(state[\"aggregate\"]) < 7:\n        return \"b\"\n    else:\n        return END\n\nbuilder.add_edge(START, \"a\")\nbuilder.add_conditional_edges(\"a\", route)\nbuilder.add_edge(\"b\", \"a\")\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Simple loop graph](assets/graph_api_image_7.png)\n\nThis architecture is similar to a [React agent](../agents/overview.md) in which node `\"a\"` is a tool-calling model, and node `\"b\"` represents the tools.\n\nIn our `route` conditional edge, we specify that we should end after the `\"aggregate\"` list in the state passes a threshold length.\n\nInvoking the graph, we see that we alternate between nodes `\"a\"` and `\"b\"` before terminating once we reach the termination condition.\n\n```python\ngraph.invoke({\"aggregate\": []})\n```\n\n```\nNode A sees []\nNode B sees ['A']\nNode A sees ['A', 'B']\nNode B sees ['A', 'B', 'A']\nNode A sees ['A', 'B', 'A', 'B']\nNode B sees ['A', 'B', 'A', 'B', 'A']\nNode A sees ['A', 'B', 'A', 'B', 'A', 'B']\n```\n\n### Impose a recursion limit\n\nIn some applications, we may not have a guarantee that we will reach a given termination condition. In these cases, we can set the graph's [recursion limit](../concepts/low_level.md#recursion-limit). This will raise a `GraphRecursionError` after a given number of [supersteps](../concepts/low_level.md#graphs). We can then catch and handle this exception:\n\n```python\nfrom langgraph.errors import GraphRecursionError\n\ntry:\n    graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\nexcept GraphRecursionError:\n    print(\"Recursion Error\")\n```\n\n```\nNode A sees []\nNode B sees ['A']\nNode C sees ['A', 'B']\nNode D sees ['A', 'B']\nNode A sees ['A', 'B', 'C', 'D']\nRecursion Error\n```\n\n??? example \"Extended example: return state on hitting recursion limit\"\n\nInstead of raising `GraphRecursionError`, we can introduce a new key to the state that keeps track of the number of steps remaining until reaching the recursion limit. We can then use this key to determine if we should end the run.\n\nLangGraph implements a special `RemainingSteps` annotation. Under the hood, it creates a `ManagedValue` channel -- a state channel that will exist for the duration of our graph run and no longer.\n\n```python\n    import operator\n    from typing import Annotated, Literal\n    from typing_extensions import TypedDict\n    from langgraph.graph import StateGraph, START, END\n    from langgraph.managed.is_last_step import RemainingSteps\n\nclass State(TypedDict):\n        aggregate: Annotated[list, operator.add]\n        remaining_steps: RemainingSteps\n\ndef a(state: State):\n        print(f'Node A sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"A\"]}\n\ndef b(state: State):\n        print(f'Node B sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"B\"]}\n\n# Define nodes\n    builder = StateGraph(State)\n    builder.add_node(a)\n    builder.add_node(b)\n\n# Define edges\n    def route(state: State) -> Literal[\"b\", END]:\n        if state[\"remaining_steps\"] <= 2:\n            return END\n        else:\n            return \"b\"\n\nbuilder.add_edge(START, \"a\")\n    builder.add_conditional_edges(\"a\", route)\n    builder.add_edge(\"b\", \"a\")\n    graph = builder.compile()\n\n# Test it out\n    result = graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\n    print(result)\n    ```\n    ```\n    Node A sees []\n    Node B sees ['A']\n    Node A sees ['A', 'B']\n    {'aggregate': ['A', 'B', 'A']}\n    ```\n\n??? example \"Extended example: loops with branches\"\n\nTo better understand how the recursion limit works, let's consider a more complex example. Below we implement a loop, but one step fans out into two nodes:\n\n```python\n    import operator\n    from typing import Annotated, Literal\n    from typing_extensions import TypedDict\n    from langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n        aggregate: Annotated[list, operator.add]\n\ndef a(state: State):\n        print(f'Node A sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"A\"]}\n\ndef b(state: State):\n        print(f'Node B sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"B\"]}\n\ndef c(state: State):\n        print(f'Node C sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"C\"]}\n\ndef d(state: State):\n        print(f'Node D sees {state[\"aggregate\"]}')\n        return {\"aggregate\": [\"D\"]}\n\n# Define nodes\n    builder = StateGraph(State)\n    builder.add_node(a)\n    builder.add_node(b)\n    builder.add_node(c)\n    builder.add_node(d)\n\n# Define edges\n    def route(state: State) -> Literal[\"b\", END]:\n        if len(state[\"aggregate\"]) < 7:\n            return \"b\"\n        else:\n            return END\n\nbuilder.add_edge(START, \"a\")\n    builder.add_conditional_edges(\"a\", route)\n    builder.add_edge(\"b\", \"c\")\n    builder.add_edge(\"b\", \"d\")\n    builder.add_edge([\"c\", \"d\"], \"a\")\n    graph = builder.compile()\n    ```\n\n```python\n    from IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n    ```\n\n![Complex loop graph with branches](assets/graph_api_image_8.png)\n\nThis graph looks complex, but can be conceptualized as loop of [supersteps](../concepts/low_level.md#graphs):\n\n1. Node A\n    2. Node B\n    3. Nodes C and D\n    4. Node A\n    5. ...\n\nWe have a loop of four supersteps, where nodes C and D are executed concurrently.\n\nInvoking the graph as before, we see that we complete two full \"laps\" before hitting the termination condition:\n\n```python\n    result = graph.invoke({\"aggregate\": []})\n    ```\n    ```\n    Node A sees []\n    Node B sees ['A']\n    Node D sees ['A', 'B']\n    Node C sees ['A', 'B']\n    Node A sees ['A', 'B', 'C', 'D']\n    Node B sees ['A', 'B', 'C', 'D', 'A']\n    Node D sees ['A', 'B', 'C', 'D', 'A', 'B']\n    Node C sees ['A', 'B', 'C', 'D', 'A', 'B']\n    Node A sees ['A', 'B', 'C', 'D', 'A', 'B', 'C', 'D']\n    ```\n\nHowever, if we set the recursion limit to four, we only complete one lap because each lap is four supersteps:\n\n```python\n    from langgraph.errors import GraphRecursionError\n\ntry:\n        result = graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\n    except GraphRecursionError:\n        print(\"Recursion Error\")\n    ```\n    ```\n    Node A sees []\n    Node B sees ['A']\n    Node C sees ['A', 'B']\n    Node D sees ['A', 'B']\n    Node A sees ['A', 'B', 'C', 'D']\n    Recursion Error\n    ```\n\n## Async\n\nUsing the async programming paradigm can produce significant performance improvements when running [IO-bound](https://en.wikipedia.org/wiki/I/O_bound) code concurrently (e.g., making concurrent API requests to a chat model provider).\n\nTo convert a `sync` implementation of the graph to an `async` implementation, you will need to:\n\n1. Update `nodes` use `async def` instead of `def`.\n2. Update the code inside to use `await` appropriately.\n3. Invoke the graph with `.ainvoke` or `.astream` as desired.\n\nBecause many LangChain objects implement the [Runnable Protocol](https://python.langchain.com/docs/expression_language/interface/) which has `async` variants of all the `sync` methods it's typically fairly quick to upgrade a `sync` graph to an `async` graph.\n\nSee example below. To demonstrate async invocations of underlying LLMs, we will include a chat model:\n\n{% include-markdown \"../../snippets/chat_model_tabs.md\" %}\n\n```python hl_lines=\"4 5 12\"\nfrom langchain.chat_models import init_chat_model\nfrom langgraph.graph import MessagesState, StateGraph\n\nasync def node(state: MessagesState): # (1)!\n    new_message = await llm.ainvoke(state[\"messages\"]) # (2)!\n    return {\"messages\": [new_message]}\n\nbuilder = StateGraph(MessagesState).add_node(node).set_entry_point(\"node\")\ngraph = builder.compile()\n\ninput_message = {\"role\": \"user\", \"content\": \"Hello\"}\nresult = await graph.ainvoke({\"messages\": [input_message]}) # (3)!\n```\n\n1. Declare nodes to be async functions.\n2. Use async invocations when available within the node.\n3. Use async invocations on the graph object itself.\n\n!!! tip \"Async streaming\"\n\nSee the [streaming guide](./streaming.md) for examples of streaming with async.\n\n## Combine control flow and state updates with `Command`\n\nIt can be useful to combine control flow (edges) and state updates (nodes). For example, you might want to BOTH perform state updates AND decide which node to go to next in the SAME node. LangGraph provides a way to do so by returning a [Command](../reference/types.md#langgraph.types.Command) object from node functions:\n\n```python\ndef my_node(state: State) -> Command[Literal[\"my_other_node\"]]:\n    return Command(\n        # state update\n        update={\"foo\": \"bar\"},\n        # control flow\n        goto=\"my_other_node\"\n    )\n```\n\nWe show an end-to-end example below. Let's create a simple graph with 3 nodes: A, B and C. We will first execute node A, and then decide whether to go to Node B or Node C next based on the output of node A.\n\n```python\nimport random\nfrom typing_extensions import TypedDict, Literal\nfrom langgraph.graph import StateGraph, START\nfrom langgraph.types import Command\n\n# Define graph state\nclass State(TypedDict):\n    foo: str\n\n# Define the nodes\n\ndef node_a(state: State) -> Command[Literal[\"node_b\", \"node_c\"]]:\n    print(\"Called A\")\n    value = random.choice([\"b\", \"c\"])\n    # this is a replacement for a conditional edge function\n    if value == \"b\":\n        goto = \"node_b\"\n    else:\n        goto = \"node_c\"\n\n# note how Command allows you to BOTH update the graph state AND route to the next node\n    return Command(\n        # this is the state update\n        update={\"foo\": value},\n        # this is a replacement for an edge\n        goto=goto,\n    )\n\ndef node_b(state: State):\n    print(\"Called B\")\n    return {\"foo\": state[\"foo\"] + \"b\"}\n\ndef node_c(state: State):\n    print(\"Called C\")\n    return {\"foo\": state[\"foo\"] + \"c\"}\n```\n\nWe can now create the `StateGraph` with the above nodes. Notice that the graph doesn't have [conditional edges](../concepts/low_level.md#conditional-edges) for routing! This is because control flow is defined with `Command` inside `node_a`.\n\n```python\nbuilder = StateGraph(State)\nbuilder.add_edge(START, \"node_a\")\nbuilder.add_node(node_a)\nbuilder.add_node(node_b)\nbuilder.add_node(node_c)\n# NOTE: there are no edges between nodes A, B and C!\n\ngraph = builder.compile()\n```\n\n!!! important\n\nYou might have noticed that we used `Command` as a return type annotation, e.g. `Command[Literal[\"node_b\", \"node_c\"]]`. This is necessary for the graph rendering and tells LangGraph that `node_a` can navigate to `node_b` and `node_c`.\n\n```python\nfrom IPython.display import display, Image\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![Command-based graph navigation](assets/graph_api_image_11.png)\n\nIf we run the graph multiple times, we'd see it take different paths (A -> B or A -> C) based on the random choice in node A.\n\n```python\ngraph.invoke({\"foo\": \"\"})\n```\n\n```\nCalled A\nCalled C\n```\n\n### Navigate to a node in a parent graph\n\nIf you are using [subgraphs](../concepts/subgraphs.md), you might want to navigate from a node within a subgraph to a different subgraph (i.e. a different node in the parent graph). To do so, you can specify `graph=Command.PARENT` in `Command`:\n\n```python\ndef my_node(state: State) -> Command[Literal[\"my_other_node\"]]:\n    return Command(\n        update={\"foo\": \"bar\"},\n        goto=\"other_subgraph\",  # where `other_subgraph` is a node in the parent graph\n        graph=Command.PARENT\n    )\n```\n\nLet's demonstrate this using the above example. We'll do so by changing `nodeA` in the above example into a single-node graph that we'll add as a subgraph to our parent graph.\n\n!!! important \"State updates with `Command.PARENT`\"\n\nWhen you send updates from a subgraph node to a parent graph node for a key that's shared by both parent and subgraph [state schemas](../concepts/low_level.md#schema), you **must** define a [reducer](../concepts/low_level.md#reducers) for the key you're updating in the parent graph state. See the example below.\n\n```python hl_lines=\"6 23 33 37\"\nimport operator\nfrom typing_extensions import Annotated\n\nclass State(TypedDict):\n    # NOTE: we define a reducer here\n    foo: Annotated[str, operator.add]\n\ndef node_a(state: State):\n    print(\"Called A\")\n    value = random.choice([\"a\", \"b\"])\n    # this is a replacement for a conditional edge function\n    if value == \"a\":\n        goto = \"node_b\"\n    else:\n        goto = \"node_c\"\n\n# note how Command allows you to BOTH update the graph state AND route to the next node\n    return Command(\n        update={\"foo\": value},\n        goto=goto,\n        # this tells LangGraph to navigate to node_b or node_c in the parent graph\n        # NOTE: this will navigate to the closest parent graph relative to the subgraph\n        graph=Command.PARENT,\n    )\n\nsubgraph = StateGraph(State).add_node(node_a).add_edge(START, \"node_a\").compile()\n\ndef node_b(state: State):\n    print(\"Called B\")\n    # NOTE: since we've defined a reducer, we don't need to manually append\n    # new characters to existing 'foo' value. instead, reducer will append these\n    # automatically (via operator.add)\n    return {\"foo\": \"b\"}\n\ndef node_c(state: State):\n    print(\"Called C\")\n    return {\"foo\": \"c\"}\n\nbuilder = StateGraph(State)\nbuilder.add_edge(START, \"subgraph\")\nbuilder.add_node(\"subgraph\", subgraph)\nbuilder.add_node(node_b)\nbuilder.add_node(node_c)\n\ngraph = builder.compile()\n```\n\n```python\ngraph.invoke({\"foo\": \"\"})\n```\n\n```\nCalled A\nCalled C\n```\n\n### Use inside tools\n\nA common use case is updating graph state from inside a tool. For example, in a customer support application you might want to look up customer information based on their account number or ID in the beginning of the conversation. To update the graph state from the tool, you can return `Command(update={\"my_custom_key\": \"foo\", \"messages\": [...]})` from the tool:\n\n```python\n@tool\ndef lookup_user_info(tool_call_id: Annotated[str, InjectedToolCallId], config: RunnableConfig):\n    \"\"\"Use this to look up user information to better assist them with their questions.\"\"\"\n    user_info = get_user_info(config.get(\"configurable\", {}).get(\"user_id\"))\n    return Command(\n        update={\n            # update the state keys\n            \"user_info\": user_info,\n            # update the message history\n            \"messages\": [ToolMessage(\"Successfully looked up user information\", tool_call_id=tool_call_id)]\n        }\n    )\n```\n\n!!! important\n\nYou MUST include `messages` (or any state key used for the message history) in `Command.update` when returning `Command` from a tool and the list of messages in `messages` MUST contain a `ToolMessage`. This is necessary for the resulting message history to be valid (LLM providers require AI messages with tool calls to be followed by the tool result messages).\n\nIf you are using tools that update state via `Command`, we recommend using prebuilt [`ToolNode`](../reference/agents.md#langgraph.prebuilt.tool_node.ToolNode) which automatically handles tools returning `Command` objects and propagates them to the graph state. If you're writing a custom node that calls tools, you would need to manually propagate `Command` objects returned by the tools as the update from the node.\n\n## Visualize your graph\n\nHere we demonstrate how to visualize the graphs you create.\n\nYou can visualize any arbitrary [Graph](https://langchain-ai.github.io/langgraph/reference/graphs/), including [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.state.StateGraph).\n\nLet's have some fun by drawing fractals :).\n\n```python\nimport random\nfrom typing import Annotated, Literal\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.graph.message import add_messages\n\nclass State(TypedDict):\n    messages: Annotated[list, add_messages]\n\nclass MyNode:\n    def __init__(self, name: str):\n        self.name = name\n    def __call__(self, state: State):\n        return {\"messages\": [(\"assistant\", f\"Called node {self.name}\")]}\n\ndef route(state) -> Literal[\"entry_node\", \"__end__\"]:\n    if len(state[\"messages\"]) > 10:\n        return \"__end__\"\n    return \"entry_node\"\n\ndef add_fractal_nodes(builder, current_node, level, max_level):\n    if level > max_level:\n        return\n    # Number of nodes to create at this level\n    num_nodes = random.randint(1, 3)  # Adjust randomness as needed\n    for i in range(num_nodes):\n        nm = [\"A\", \"B\", \"C\"][i]\n        node_name = f\"node_{current_node}_{nm}\"\n        builder.add_node(node_name, MyNode(node_name))\n        builder.add_edge(current_node, node_name)\n        # Recursively add more nodes\n        r = random.random()\n        if r > 0.2 and level + 1 < max_level:\n            add_fractal_nodes(builder, node_name, level + 1, max_level)\n        elif r > 0.05:\n            builder.add_conditional_edges(node_name, route, node_name)\n        else:\n            # End\n            builder.add_edge(node_name, \"__end__\")\n\ndef build_fractal_graph(max_level: int):\n    builder = StateGraph(State)\n    entry_point = \"entry_node\"\n    builder.add_node(entry_point, MyNode(entry_point))\n    builder.add_edge(START, entry_point)\n    add_fractal_nodes(builder, entry_point, 1, max_level)\n    # Optional: set a finish point if required\n    builder.add_edge(entry_point, END)  # or any specific node\n    return builder.compile()\n\napp = build_fractal_graph(3)\n```\n\n### Mermaid\n\nWe can also convert a graph class into Mermaid syntax.\n\n```python\nprint(app.get_graph().draw_mermaid())\n```\n\n```\n%%{init: {'flowchart': {'curve': 'linear'}}}%%\ngraph TD;\n\t__start__([<p>__start__</p>]):::first\n\tentry_node(entry_node)\n\tnode_entry_node_A(node_entry_node_A)\n\tnode_entry_node_B(node_entry_node_B)\n\tnode_node_entry_node_B_A(node_node_entry_node_B_A)\n\tnode_node_entry_node_B_B(node_node_entry_node_B_B)\n\tnode_node_entry_node_B_C(node_node_entry_node_B_C)\n\t__end__([<p>__end__</p>]):::last\n\t__start__ --> entry_node;\n\tentry_node --> __end__;\n\tentry_node --> node_entry_node_A;\n\tentry_node --> node_entry_node_B;\n\tnode_entry_node_B --> node_node_entry_node_B_A;\n\tnode_entry_node_B --> node_node_entry_node_B_B;\n\tnode_entry_node_B --> node_node_entry_node_B_C;\n\tnode_entry_node_A -.-> entry_node;\n\tnode_entry_node_A -.-> __end__;\n\tnode_node_entry_node_B_A -.-> entry_node;\n\tnode_node_entry_node_B_A -.-> __end__;\n\tnode_node_entry_node_B_B -.-> entry_node;\n\tnode_node_entry_node_B_B -.-> __end__;\n\tnode_node_entry_node_B_C -.-> entry_node;\n\tnode_node_entry_node_B_C -.-> __end__;\n\tclassDef default fill:#f2f0ff,line-height:1.2\n\tclassDef first fill-opacity:0\n\tclassDef last fill:#bfb6fc\n```\n\n### PNG\n\nIf preferred, we could render the Graph into a `.png`. Here we could use three options:\n\n- Using Mermaid.ink API (does not require additional packages)\n- Using Mermaid + Pyppeteer (requires `pip install pyppeteer`)\n- Using graphviz (which requires `pip install graphviz`)\n\n**Using Mermaid.Ink**\n\nBy default, `draw_mermaid_png()` uses Mermaid.Ink's API to generate the diagram.\n\n```python\nfrom IPython.display import Image, display\nfrom langchain_core.runnables.graph import CurveStyle, MermaidDrawMethod, NodeStyles\n\ndisplay(Image(app.get_graph().draw_mermaid_png()))\n```\n\n![Fractal graph visualization](assets/graph_api_image_10.png)\n\n**Using Mermaid + Pyppeteer**\n\n```python\nimport nest_asyncio\n\nnest_asyncio.apply()  # Required for Jupyter Notebook to run async functions\n\ndisplay(\n    Image(\n        app.get_graph().draw_mermaid_png(\n            curve_style=CurveStyle.LINEAR,\n            node_colors=NodeStyles(first=\"#ffdfba\", last=\"#baffc9\", default=\"#fad7de\"),\n            wrap_label_n_words=9,\n            output_file_path=None,\n            draw_method=MermaidDrawMethod.PYPPETEER,\n            background_color=\"white\",\n            padding=10,\n        )\n    )\n)\n```\n\n**Using Graphviz**\n\n```python\ntry:\n    display(Image(app.get_graph().draw_png()))\nexcept ImportError:\n    print(\n        \"You likely need to install dependencies for pygraphviz, see more here https://github.com/pygraphviz/pygraphviz/blob/main/INSTALL.txt\"\n    )\n```\n\n---\nhow-tos/streaming.md\n---\n\n# Stream outputs\n\nYou can [stream outputs](../concepts/streaming.md) from a LangGraph agent or workflow.\n\n## Supported stream modes\n\nPass one or more of the following stream modes as a list to the [`stream()`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.CompiledStateGraph.stream) or [`astream()`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.CompiledStateGraph.astream) methods:", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "| Mode       | Description                                                                                                                                                                         |\n| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `values`   | Streams the full value of the state after each step of the graph.                                                                                                                   |\n| `updates`  | Streams the updates to the state after each step of the graph. If multiple updates are made in the same step (e.g., multiple nodes are run), those updates are streamed separately. |\n| `custom`   | Streams custom data from inside your graph nodes.                                                                                                                                   |\n| `messages` | Streams 2-tuples (LLM token, metadata) from any graph nodes where an LLM is invoked.                                                                                                |\n| `debug`    | Streams as much information as possible throughout the execution of the graph.                                                                                                      |\n\n## Stream from an agent\n\n### Agent progress\n\nTo stream agent progress, use the [`stream()`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.CompiledStateGraph.stream) or [`astream()`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.CompiledStateGraph.astream) methods with `stream_mode=\"updates\"`. This emits an event after every agent step.\n\nFor example, if you have an agent that calls a tool once, you should see the following updates:\n\n- **LLM node**: AI message with tool call requests\n- **Tool node**: Tool message with execution result\n- **LLM node**: Final AI response\n\n=== \"Sync\"\n\n```python hl_lines=\"5 7\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n    for chunk in agent.stream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"updates\"\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n=== \"Async\"\n\n```python hl_lines=\"5 7\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n    async for chunk in agent.astream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"updates\"\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n### LLM tokens\n\nTo stream tokens as they are produced by the LLM, use `stream_mode=\"messages\"`:\n\n=== \"Sync\"\n\n```python hl_lines=\"5 7\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n    for token, metadata in agent.stream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"messages\"\n    ):\n        print(\"Token\", token)\n        print(\"Metadata\", metadata)\n        print(\"\\n\")\n    ```\n\n=== \"Async\"\n\n```python hl_lines=\"5 7\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n    async for token, metadata in agent.astream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"messages\"\n    ):\n        print(\"Token\", token)\n        print(\"Metadata\", metadata)\n        print(\"\\n\")\n    ```\n\n### Tool updates\n\nTo stream updates from tools as they are executed, you can use [get_stream_writer](https://langchain-ai.github.io/langgraph/reference/config/#langgraph.config.get_stream_writer).\n\n=== \"Sync\"\n\n```python hl_lines=\"1 5 7 17\"\n    from langgraph.config import get_stream_writer\n\ndef get_weather(city: str) -> str:\n        \"\"\"Get weather for a given city.\"\"\"\n        writer = get_stream_writer()\n        # stream any arbitrary data\n        writer(f\"Looking up data for city: {city}\")\n        return f\"It's always sunny in {city}!\"\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n\nfor chunk in agent.stream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"custom\"\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n=== \"Async\"\n\n```python hl_lines=\"1 5 7 17\"\n    from langgraph.config import get_stream_writer\n\ndef get_weather(city: str) -> str:\n        \"\"\"Get weather for a given city.\"\"\"\n        writer = get_stream_writer()\n        # stream any arbitrary data\n        writer(f\"Looking up data for city: {city}\")\n        return f\"It's always sunny in {city}!\"\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n\nasync for chunk in agent.astream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=\"custom\"\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n!!! Note\n\nIf you add `get_stream_writer` inside your tool, you won't be able to invoke the tool outside of a LangGraph execution context.\n\n### Stream multiple modes\n\nYou can specify multiple streaming modes by passing stream mode as a list: `stream_mode=[\"updates\", \"messages\", \"custom\"]`:\n\n=== \"Sync\"\n\n```python hl_lines=\"8\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n\nfor stream_mode, chunk in agent.stream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=[\"updates\", \"messages\", \"custom\"]\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n=== \"Async\"\n\n```python hl_lines=\"8\"\n    agent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_weather],\n    )\n\nasync for stream_mode, chunk in agent.astream(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what is the weather in sf\"}]},\n        stream_mode=[\"updates\", \"messages\", \"custom\"]\n    ):\n        print(chunk)\n        print(\"\\n\")\n    ```\n\n### Disable streaming\n\nIn some applications you might need to disable streaming of individual tokens for a given model. This is useful in [multi-agent](../agents/multi-agent.md) systems to control which agents stream their output.\n\nSee the [Models](../agents/models.md#disable-streaming) guide to learn how to disable streaming.\n\n## Stream from a workflow\n\n### Basic usage example\n\nLangGraph graphs expose the [`.stream()`](https://langchain-ai.github.io/langgraph/reference/pregel/#langgraph.pregel.Pregel.stream) (sync) and [`.astream()`](https://langchain-ai.github.io/langgraph/reference/pregel/#langgraph.pregel.Pregel.astream) (async) methods to yield streamed outputs as iterators.\n\n=== \"Sync\"\n\n```python\n    for chunk in graph.stream(inputs, stream_mode=\"updates\"):\n        print(chunk)\n    ```\n\n=== \"Async\"\n\n```python\n    async for chunk in graph.astream(inputs, stream_mode=\"updates\"):\n        print(chunk)\n    ```\n\n??? example \"Extended example: streaming updates\"\n\n```python hl_lines=\"24 26\"\n      from typing import TypedDict\n      from langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n          topic: str\n          joke: str\n\ndef refine_topic(state: State):\n          return {\"topic\": state[\"topic\"] + \" and cats\"}\n\ndef generate_joke(state: State):\n          return {\"joke\": f\"This is a joke about {state['topic']}\"}\n\ngraph = (\n          StateGraph(State)\n          .add_node(refine_topic)\n          .add_node(generate_joke)\n          .add_edge(START, \"refine_topic\")\n          .add_edge(\"refine_topic\", \"generate_joke\")\n          .add_edge(\"generate_joke\", END)\n          .compile()\n      )\n\nfor chunk in graph.stream( # (1)!\n          {\"topic\": \"ice cream\"},\n          stream_mode=\"updates\", # (2)!\n      ):\n          print(chunk)\n      ```\n\n1. The `stream()` method returns an iterator that yields streamed outputs.\n      2. Set `stream_mode=\"updates\"` to stream only the updates to the graph state after each node. Other stream modes are also available. See [supported stream modes](#supported-stream-modes) for details.\n\n```output\n      {'refineTopic': {'topic': 'ice cream and cats'}}\n      {'generateJoke': {'joke': 'This is a joke about ice cream and cats'}}\n      ```                                                                                                   |\n\n### Stream multiple modes\n\nYou can pass a list as the `stream_mode` parameter to stream multiple modes at once.\n\nThe streamed outputs will be tuples of `(mode, chunk)` where `mode` is the name of the stream mode and `chunk` is the data streamed by that mode.\n\n=== \"Sync\"\n\n```python\n    for mode, chunk in graph.stream(inputs, stream_mode=[\"updates\", \"custom\"]):\n        print(chunk)\n    ```\n\n=== \"Async\"\n\n```python\n    async for mode, chunk in graph.astream(inputs, stream_mode=[\"updates\", \"custom\"]):\n        print(chunk)\n    ```\n\n### Stream graph state\n\nUse the stream modes `updates` and `values` to stream the state of the graph as it executes.\n\n- `updates` streams the **updates** to the state after each step of the graph.\n- `values` streams the **full value** of the state after each step of the graph.\n\n```python\nfrom typing import TypedDict\nfrom langgraph.graph import StateGraph, START, END\n\nclass State(TypedDict):\n  topic: str\n  joke: str\n\ndef refine_topic(state: State):\n    return {\"topic\": state[\"topic\"] + \" and cats\"}\n\ndef generate_joke(state: State):\n    return {\"joke\": f\"This is a joke about {state['topic']}\"}\n\ngraph = (\n  StateGraph(State)\n  .add_node(refine_topic)\n  .add_node(generate_joke)\n  .add_edge(START, \"refine_topic\")\n  .add_edge(\"refine_topic\", \"generate_joke\")\n  .add_edge(\"generate_joke\", END)\n  .compile()\n)\n```\n\n=== \"updates\"\n\nUse this to stream only the **state updates** returned by the nodes after each step. The streamed outputs include the name of the node as well as the update.\n\n```python hl_lines=\"3\"\n    for chunk in graph.stream(\n        {\"topic\": \"ice cream\"},\n        stream_mode=\"updates\",\n    ):\n        print(chunk)\n    ```\n\n=== \"values\"\n\nUse this to stream the **full state** of the graph after each step.\n\n```python hl_lines=\"3\"\n    for chunk in graph.stream(\n        {\"topic\": \"ice cream\"},\n        stream_mode=\"values\",\n    ):\n        print(chunk)\n    ```\n\n### Stream subgraph outputs\n\nTo include outputs from [subgraphs](../concepts/subgraphs.md) in the streamed outputs, you can set `subgraphs=True` in the `.stream()` method of the parent graph. This will stream outputs from both the parent graph and any subgraphs.\n\nThe outputs will be streamed as tuples `(namespace, data)`, where `namespace` is a tuple with the path to the node where a subgraph is invoked, e.g. `(\"parent_node:<task_id>\", \"child_node:<task_id>\")`.\n\n```python hl_lines=\"3\"\nfor chunk in graph.stream(\n    {\"foo\": \"foo\"},\n    subgraphs=True, # (1)!\n    stream_mode=\"updates\",\n):\n    print(chunk)\n```\n\n1. Set `subgraphs=True` to stream outputs from subgraphs.\n\n??? example \"Extended example: streaming from subgraphs\"\n\n```python hl_lines=\"39\"\n      from langgraph.graph import START, StateGraph\n      from typing import TypedDict\n\n# Define subgraph\n      class SubgraphState(TypedDict):\n          foo: str  # note that this key is shared with the parent graph state\n          bar: str\n\ndef subgraph_node_1(state: SubgraphState):\n          return {\"bar\": \"bar\"}\n\ndef subgraph_node_2(state: SubgraphState):\n          return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n\nsubgraph_builder = StateGraph(SubgraphState)\n      subgraph_builder.add_node(subgraph_node_1)\n      subgraph_builder.add_node(subgraph_node_2)\n      subgraph_builder.add_edge(START, \"subgraph_node_1\")\n      subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n      subgraph = subgraph_builder.compile()\n\n# Define parent graph\n      class ParentState(TypedDict):\n          foo: str\n\ndef node_1(state: ParentState):\n          return {\"foo\": \"hi! \" + state[\"foo\"]}\n\nbuilder = StateGraph(ParentState)\n      builder.add_node(\"node_1\", node_1)\n      builder.add_node(\"node_2\", subgraph)\n      builder.add_edge(START, \"node_1\")\n      builder.add_edge(\"node_1\", \"node_2\")\n      graph = builder.compile()\n\nfor chunk in graph.stream(\n          {\"foo\": \"foo\"},\n          stream_mode=\"updates\",\n          subgraphs=True, # (1)!\n      ):\n          print(chunk)\n      ```\n\n1. Set `subgraphs=True` to stream outputs from subgraphs.\n\n```\n      ((), {'node_1': {'foo': 'hi! foo'}})\n      (('node_2:dfddc4ba-c3c5-6887-5012-a243b5b377c2',), {'subgraph_node_1': {'bar': 'bar'}})\n      (('node_2:dfddc4ba-c3c5-6887-5012-a243b5b377c2',), {'subgraph_node_2': {'foo': 'hi! foobar'}})\n      ((), {'node_2': {'foo': 'hi! foobar'}})\n      ```\n\n**Note** that we are receiving not just the node updates, but we also the namespaces which tell us what graph (or subgraph) we are streaming from.\n\n### Debugging {#debug}\n\nUse the `debug` streaming mode to stream as much information as possible throughout the execution of the graph. The streamed outputs include the name of the node as well as the full state.\n\n```python hl_lines=\"3\"\nfor chunk in graph.stream(\n    {\"topic\": \"ice cream\"},\n    stream_mode=\"debug\",\n):\n    print(chunk)\n```\n\n### LLM tokens {#messages}\n\nUse the `messages` streaming mode to stream Large Language Model (LLM) outputs **token by token** from any part of your graph, including nodes, tools, subgraphs, or tasks.\n\nThe streamed output from [`messages` mode](#supported-stream-modes) is a tuple `(message_chunk, metadata)` where:\n\n- `message_chunk`: the token or message segment from the LLM.\n- `metadata`: a dictionary containing details about the graph node and LLM invocation.\n\n> If your LLM is not available as a LangChain integration, you can stream its outputs using `custom` mode instead. See [use with any LLM](#use-with-any-llm) for details.\n\n!!! warning \"Manual config required for async in Python < 3.11\"\n\nWhen using Python < 3.11 with async code, you must explicitly pass `RunnableConfig` to `ainvoke()` to enable proper streaming. See [Async with Python < 3.11](#async) for details or upgrade to Python 3.11+.\n\n```python hl_lines=\"17 33\"\nfrom dataclasses import dataclass\n\nfrom langchain.chat_models import init_chat_model\nfrom langgraph.graph import StateGraph, START\n\n@dataclass\nclass MyState:\n    topic: str\n    joke: str = \"\"\n\nllm = init_chat_model(model=\"openai:gpt-4o-mini\")\n\ndef call_model(state: MyState):\n    \"\"\"Call the LLM to generate a joke about a topic\"\"\"\n    llm_response = llm.invoke( # (1)!\n        [\n            {\"role\": \"user\", \"content\": f\"Generate a joke about {state.topic}\"}\n        ]\n    )\n    return {\"joke\": llm_response.content}\n\ngraph = (\n    StateGraph(MyState)\n    .add_node(call_model)\n    .add_edge(START, \"call_model\")\n    .compile()\n)\n\nfor message_chunk, metadata in graph.stream( # (2)!\n    {\"topic\": \"ice cream\"},\n    stream_mode=\"messages\",\n):\n    if message_chunk.content:\n        print(message_chunk.content, end=\"|\", flush=True)\n```\n\n1. Note that the message events are emitted even when the LLM is run using `.invoke` rather than `.stream`.\n2. The \"messages\" stream mode returns an iterator of tuples `(message_chunk, metadata)` where `message_chunk` is the token streamed by the LLM and `metadata` is a dictionary with information about the graph node where the LLM was called and other information.\n\n#### Filter by LLM invocation\n\nYou can associate `tags` with LLM invocations to filter the streamed tokens by LLM invocation.\n\n```python hl_lines=\"10\"\nfrom langchain.chat_models import init_chat_model\n\nllm_1 = init_chat_model(model=\"openai:gpt-4o-mini\", tags=['joke']) # (1)!\nllm_2 = init_chat_model(model=\"openai:gpt-4o-mini\", tags=['poem']) # (2)!\n\ngraph = ... # define a graph that uses these LLMs\n\nasync for msg, metadata in graph.astream(  # (3)!\n    {\"topic\": \"cats\"},\n    stream_mode=\"messages\",\n):\n    if metadata[\"tags\"] == [\"joke\"]: # (4)!\n        print(msg.content, end=\"|\", flush=True)\n```\n\n1. llm_1 is tagged with \"joke\".\n2. llm_2 is tagged with \"poem\".\n3. The `stream_mode` is set to \"messages\" to stream LLM tokens. The `metadata` contains information about the LLM invocation, including the tags.\n4. Filter the streamed tokens by the `tags` field in the metadata to only include the tokens from the LLM invocation with the \"joke\" tag.\n\n??? example \"Extended example: filtering by tags\"\n\n```python hl_lines=\"42\"\n      from typing import TypedDict\n\nfrom langchain.chat_models import init_chat_model\n      from langgraph.graph import START, StateGraph\n\njoke_model = init_chat_model(model=\"openai:gpt-4o-mini\", tags=[\"joke\"]) # (1)!\n      poem_model = init_chat_model(model=\"openai:gpt-4o-mini\", tags=[\"poem\"]) # (2)!\n\nclass State(TypedDict):\n            topic: str\n            joke: str\n            poem: str\n\nasync def call_model(state, config):\n            topic = state[\"topic\"]\n            print(\"Writing joke...\")\n            # Note: Passing the config through explicitly is required for python < 3.11\n            # Since context var support wasn't added before then: https://docs.python.org/3/library/asyncio-task.html#creating-tasks\n            joke_response = await joke_model.ainvoke(\n                  [{\"role\": \"user\", \"content\": f\"Write a joke about {topic}\"}],\n                  config, # (3)!\n            )\n            print(\"\\n\\nWriting poem...\")\n            poem_response = await poem_model.ainvoke(\n                  [{\"role\": \"user\", \"content\": f\"Write a short poem about {topic}\"}],\n                  config, # (3)!\n            )\n            return {\"joke\": joke_response.content, \"poem\": poem_response.content}\n\ngraph = (\n            StateGraph(State)\n            .add_node(call_model)\n            .add_edge(START, \"call_model\")\n            .compile()\n      )\n\nasync for msg, metadata in graph.astream(\n            {\"topic\": \"cats\"},\n            stream_mode=\"messages\", # (4)!\n      ):\n          if metadata[\"tags\"] == [\"joke\"]: # (4)!\n              print(msg.content, end=\"|\", flush=True)\n      ```\n\n1. The `joke_model` is tagged with \"joke\".\n      2. The `poem_model` is tagged with \"poem\".\n      3. The `config` is passed through explicitly to ensure the context vars are propagated correctly. This is required for Python < 3.11 when using async code. Please see the [async section](#async) for more details.\n      4. The `stream_mode` is set to \"messages\" to stream LLM tokens. The `metadata` contains information about the LLM invocation, including the tags.\n\n#### Filter by node\n\nTo stream tokens only from specific nodes, use `stream_mode=\"messages\"` and filter the outputs by the `langgraph_node` field in the streamed metadata:\n\n```python hl_lines=\"3 5\"\nfor msg, metadata in graph.stream( # (1)!\n    inputs,\n    stream_mode=\"messages\",\n):\n    if msg.content and metadata[\"langgraph_node\"] == \"some_node_name\": # (2)!\n        ...\n```\n\n1. The \"messages\" stream mode returns a tuple of `(message_chunk, metadata)` where `message_chunk` is the token streamed by the LLM and `metadata` is a dictionary with information about the graph node where the LLM was called and other information.\n2. Filter the streamed tokens by the `langgraph_node` field in the metadata to only include the tokens from the `write_poem` node.\n\n??? example \"Extended example: streaming LLM tokens from specific nodes\"\n\n```python hl_lines=\"40 44\"\n      from typing import TypedDict\n      from langgraph.graph import START, StateGraph\n      from langchain_openai import ChatOpenAI\n\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\n\nclass State(TypedDict):\n            topic: str\n            joke: str\n            poem: str\n\ndef write_joke(state: State):\n            topic = state[\"topic\"]\n            joke_response = model.invoke(\n                  [{\"role\": \"user\", \"content\": f\"Write a joke about {topic}\"}]\n            )\n            return {\"joke\": joke_response.content}\n\ndef write_poem(state: State):\n            topic = state[\"topic\"]\n            poem_response = model.invoke(\n                  [{\"role\": \"user\", \"content\": f\"Write a short poem about {topic}\"}]\n            )\n            return {\"poem\": poem_response.content}\n\ngraph = (\n            StateGraph(State)\n            .add_node(write_joke)\n            .add_node(write_poem)\n            # write both the joke and the poem concurrently\n            .add_edge(START, \"write_joke\")\n            .add_edge(START, \"write_poem\")\n            .compile()\n      )\n\nfor msg, metadata in graph.stream( # (1)!\n          {\"topic\": \"cats\"},\n          stream_mode=\"messages\",\n      ):\n          if msg.content and metadata[\"langgraph_node\"] == \"write_poem\": # (2)!\n              print(msg.content, end=\"|\", flush=True)\n      ```\n\n1. The \"messages\" stream mode returns a tuple of `(message_chunk, metadata)` where `message_chunk` is the token streamed by the LLM and `metadata` is a dictionary with information about the graph node where the LLM was called and other information.\n      2. Filter the streamed tokens by the `langgraph_node` field in the metadata to only include the tokens from the `write_poem` node.\n\n### Stream custom data\n\nTo send **custom user-defined data** from inside a LangGraph node or tool, follow these steps:\n\n1. Use `get_stream_writer()` to access the stream writer and emit custom data.\n2. Set `stream_mode=\"custom\"` when calling `.stream()` or `.astream()` to get the custom data in the stream. You can combine multiple modes (e.g., `[\"updates\", \"custom\"]`), but at least one must be `\"custom\"`.\n\n!!! warning \"No `get_stream_writer()` in async for Python < 3.11\"\n\nIn async code running on Python < 3.11, `get_stream_writer()` will not work.\n    Instead, add a `writer` parameter to your node or tool and pass it manually.\n    See [Async with Python < 3.11](#async) for usage examples.\n\n=== \"node\"\n\n```python\n      from typing import TypedDict\n      from langgraph.config import get_stream_writer\n      from langgraph.graph import StateGraph, START\n\nclass State(TypedDict):\n          query: str\n          answer: str\n\ndef node(state: State):\n          writer = get_stream_writer()  # (1)!\n          writer({\"custom_key\": \"Generating custom data inside node\"}) # (2)!\n          return {\"answer\": \"some data\"}\n\ngraph = (\n          StateGraph(State)\n          .add_node(node)\n          .add_edge(START, \"node\")\n          .compile()\n      )\n\ninputs = {\"query\": \"example\"}\n\n# Usage\n      for chunk in graph.stream(inputs, stream_mode=\"custom\"):  # (3)!\n          print(chunk)\n      ```\n\n1. Get the stream writer to send custom data.\n      2. Emit a custom key-value pair (e.g., progress update).\n      3. Set `stream_mode=\"custom\"` to receive the custom data in the stream.\n\n=== \"tool\"\n\n```python hl_lines=\"8 10\"\n      from langchain_core.tools import tool\n      from langgraph.config import get_stream_writer\n\n@tool\n      def query_database(query: str) -> str:\n          \"\"\"Query the database.\"\"\"\n          writer = get_stream_writer() # (1)!\n          writer({\"data\": \"Retrieved 0/100 records\", \"type\": \"progress\"}) # (2)!\n          # perform query\n          writer({\"data\": \"Retrieved 100/100 records\", \"type\": \"progress\"}) # (3)!\n          return \"some-answer\"\n\ngraph = ... # define a graph that uses this tool\n\nfor chunk in graph.stream(inputs, stream_mode=\"custom\"): # (4)!\n          print(chunk)\n      ```\n\n1. Access the stream writer to send custom data.\n      2. Emit a custom key-value pair (e.g., progress update).\n      3. Emit another custom key-value pair.\n      4. Set `stream_mode=\"custom\"` to receive the custom data in the stream.\n\n### Use with any LLM\n\nYou can use `stream_mode=\"custom\"` to stream data from **any LLM API** — even if that API does **not** implement the LangChain chat model interface.\n\nThis lets you integrate raw LLM clients or external services that provide their own streaming interfaces, making LangGraph highly flexible for custom setups.\n\n```python hl_lines=\"5 8 20\"\nfrom langgraph.config import get_stream_writer\n\ndef call_arbitrary_model(state):\n    \"\"\"Example node that calls an arbitrary model and streams the output\"\"\"\n    writer = get_stream_writer() # (1)!\n    # Assume you have a streaming client that yields chunks\n    for chunk in your_custom_streaming_client(state[\"topic\"]): # (2)!\n        writer({\"custom_llm_chunk\": chunk}) # (3)!\n    return {\"result\": \"completed\"}\n\ngraph = (\n    StateGraph(State)\n    .add_node(call_arbitrary_model)\n    # Add other nodes and edges as needed\n    .compile()\n)\n\nfor chunk in graph.stream(\n    {\"topic\": \"cats\"},\n    stream_mode=\"custom\", # (4)!\n):\n    # The chunk will contain the custom data streamed from the llm\n    print(chunk)\n```\n\n1. Get the stream writer to send custom data.\n2. Generate LLM tokens using your custom streaming client.\n3. Use the writer to send custom data to the stream.\n4. Set `stream_mode=\"custom\"` to receive the custom data in the stream.\n\n??? example \"Extended example: streaming arbitrary chat model\"\n\n```python\n      import operator\n      import json\n\nfrom typing import TypedDict\n      from typing_extensions import Annotated\n      from langgraph.graph import StateGraph, START\n\nfrom openai import AsyncOpenAI\n\nopenai_client = AsyncOpenAI()\n      model_name = \"gpt-4o-mini\"\n\nasync def stream_tokens(model_name: str, messages: list[dict]):\n          response = await openai_client.chat.completions.create(\n              messages=messages, model=model_name, stream=True\n          )\n          role = None\n          async for chunk in response:\n              delta = chunk.choices[0].delta\n\nif delta.role is not None:\n                  role = delta.role\n\nif delta.content:\n                  yield {\"role\": role, \"content\": delta.content}\n\n# this is our tool\n      async def get_items(place: str) -> str:\n          \"\"\"Use this tool to list items one might find in a place you're asked about.\"\"\"\n          writer = get_stream_writer()\n          response = \"\"\n          async for msg_chunk in stream_tokens(\n              model_name,\n              [\n                  {\n                      \"role\": \"user\",\n                      \"content\": (\n                          \"Can you tell me what kind of items \"\n                          f\"i might find in the following place: '{place}'. \"\n                          \"List at least 3 such items separating them by a comma. \"\n                          \"And include a brief description of each item.\"\n                      ),\n                  }\n              ],\n          ):\n              response += msg_chunk[\"content\"]\n              writer(msg_chunk)\n\nreturn response\n\nclass State(TypedDict):\n          messages: Annotated[list[dict], operator.add]\n\n# this is the tool-calling graph node\n      async def call_tool(state: State):\n          ai_message = state[\"messages\"][-1]\n          tool_call = ai_message[\"tool_calls\"][-1]\n\nfunction_name = tool_call[\"function\"][\"name\"]\n          if function_name != \"get_items\":\n              raise ValueError(f\"Tool {function_name} not supported\")\n\nfunction_arguments = tool_call[\"function\"][\"arguments\"]\n          arguments = json.loads(function_arguments)\n\nfunction_response = await get_items(**arguments)\n          tool_message = {\n              \"tool_call_id\": tool_call[\"id\"],\n              \"role\": \"tool\",\n              \"name\": function_name,\n              \"content\": function_response,\n          }\n          return {\"messages\": [tool_message]}\n\ngraph = (\n          StateGraph(State)\n          .add_node(call_tool)\n          .add_edge(START, \"call_tool\")\n          .compile()\n      )\n      ```\n\nLet's invoke the graph with an AI message that includes a tool call:", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "```python\n      inputs = {\n          \"messages\": [\n              {\n                  \"content\": None,\n                  \"role\": \"assistant\",\n                  \"tool_calls\": [\n                      {\n                          \"id\": \"1\",\n                          \"function\": {\n                              \"arguments\": '{\"place\":\"bedroom\"}',\n                              \"name\": \"get_items\",\n                          },\n                          \"type\": \"function\",\n                      }\n                  ],\n              }\n          ]\n      }\n\nasync for chunk in graph.astream(\n          inputs,\n          stream_mode=\"custom\",\n      ):\n          print(chunk[\"content\"], end=\"|\", flush=True)\n      ```\n\n### Disable streaming for specific chat models\n\nIf your application mixes models that support streaming with those that do not, you may need to explicitly disable streaming for\nmodels that do not support it.\n\nSet `disable_streaming=True` when initializing the model.\n\n=== \"init_chat_model\"\n\n```python hl_lines=\"5\"\n      from langchain.chat_models import init_chat_model\n\nmodel = init_chat_model(\n          \"anthropic:claude-3-7-sonnet-latest\",\n          disable_streaming=True # (1)!\n      )\n      ```\n\n1. Set `disable_streaming=True` to disable streaming for the chat model.\n\n=== \"chat model interface\"\n\n```python\n      from langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(model=\"o1-preview\", disable_streaming=True) # (1)!\n      ```\n\n1. Set `disable_streaming=True` to disable streaming for the chat model.\n\n### Async with Python < 3.11 { #async }\n\nIn Python versions < 3.11, [asyncio tasks](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task) do not support the `context` parameter.  \nThis limits LangGraph ability to automatically propagate context, and affects LangGraph's streaming mechanisms in two key ways:\n\n1. You **must** explicitly pass [`RunnableConfig`](https://python.langchain.com/docs/concepts/runnables/#runnableconfig) into async LLM calls (e.g., `ainvoke()`), as callbacks are not automatically propagated.\n2. You **cannot** use `get_stream_writer()` in async nodes or tools — you must pass a `writer` argument directly.\n\n??? example \"Extended example: async LLM call with manual config\"\n\n```python hl_lines=\"16 29\"\n      from typing import TypedDict\n      from langgraph.graph import START, StateGraph\n      from langchain.chat_models import init_chat_model\n\nllm = init_chat_model(model=\"openai:gpt-4o-mini\")\n\nclass State(TypedDict):\n          topic: str\n          joke: str\n\nasync def call_model(state, config): # (1)!\n          topic = state[\"topic\"]\n          print(\"Generating joke...\")\n          joke_response = await llm.ainvoke(\n              [{\"role\": \"user\", \"content\": f\"Write a joke about {topic}\"}],\n              config, # (2)!\n          )\n          return {\"joke\": joke_response.content}\n\ngraph = (\n          StateGraph(State)\n          .add_node(call_model)\n          .add_edge(START, \"call_model\")\n          .compile()\n      )\n\nasync for chunk, metadata in graph.astream(\n          {\"topic\": \"ice cream\"},\n          stream_mode=\"messages\", # (3)!\n      ):\n          if chunk.content:\n              print(chunk.content, end=\"|\", flush=True)\n      ```\n\n1. Accept `config` as an argument in the async node function.\n      2. Pass `config` to `llm.ainvoke()` to ensure proper context propagation.\n      3. Set `stream_mode=\"messages\"` to stream LLM tokens.\n\n??? example \"Extended example: async custom streaming with stream writer\"\n\n```python hl_lines=\"8 21\"\n      from typing import TypedDict\n      from langgraph.types import StreamWriter\n\nclass State(TypedDict):\n            topic: str\n            joke: str\n\nasync def generate_joke(state: State, writer: StreamWriter): # (1)!\n            writer({\"custom_key\": \"Streaming custom data while generating a joke\"})\n            return {\"joke\": f\"This is a joke about {state['topic']}\"}\n\ngraph = (\n            StateGraph(State)\n            .add_node(generate_joke)\n            .add_edge(START, \"generate_joke\")\n            .compile()\n      )\n\nasync for chunk in graph.astream(\n            {\"topic\": \"ice cream\"},\n            stream_mode=\"custom\", # (2)!\n      ):\n            print(chunk)\n      ```\n\n1. Add `writer` as an argument in the function signature of the async node or tool. LangGraph will automatically pass the stream writer to the function.\n      2. Set `stream_mode=\"custom\"` to receive the custom data in the stream.\n\n---\nhow-tos/use-functional-api.md\n---\n\n# Use the functional API\n\nThe [**Functional API**](../concepts/functional_api.md) allows you to add LangGraph's key features — [persistence](../concepts/persistence.md), [memory](../how-tos/memory/add-memory.md), [human-in-the-loop](../concepts/human_in_the_loop.md), and [streaming](../concepts/streaming.md) — to your applications with minimal changes to your existing code.\n\n!!! tip\n\nFor conceptual information on the functional API, see [Functional API](../concepts/functional_api.md).\n\n## Creating a simple workflow\n\nWhen defining an `entrypoint`, input is restricted to the first argument of the function. To pass multiple inputs, you can use a dictionary.\n\n```python\n@entrypoint(checkpointer=checkpointer)\ndef my_workflow(inputs: dict) -> int:\n    value = inputs[\"value\"]\n    another_value = inputs[\"another_value\"]\n    ...\n\nmy_workflow.invoke({\"value\": 1, \"another_value\": 2})\n```\n\n??? example \"Extended example: simple workflow\"\n\n```python\n    import uuid\n    from langgraph.func import entrypoint, task\n    from langgraph.checkpoint.memory import InMemorySaver\n\n# Task that checks if a number is even\n    @task\n    def is_even(number: int) -> bool:\n        return number % 2 == 0\n\n# Task that formats a message\n    @task\n    def format_message(is_even: bool) -> str:\n        return \"The number is even.\" if is_even else \"The number is odd.\"\n\n# Create a checkpointer for persistence\n    checkpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\n    def workflow(inputs: dict) -> str:\n        \"\"\"Simple workflow to classify a number.\"\"\"\n        even = is_even(inputs[\"number\"]).result()\n        return format_message(even).result()\n\n# Run the workflow with a unique thread ID\n    config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    result = workflow.invoke({\"number\": 7}, config=config)\n    print(result)\n    ```\n\n??? example \"Extended example: Compose an essay with an LLM\"\n\nThis example demonstrates how to use the `@task` and `@entrypoint` decorators\n    syntactically. Given that a checkpointer is provided, the workflow results will\n    be persisted in the checkpointer.\n\n```python\n    import uuid\n    from langchain.chat_models import init_chat_model\n    from langgraph.func import entrypoint, task\n    from langgraph.checkpoint.memory import InMemorySaver\n\nllm = init_chat_model('openai:gpt-3.5-turbo')\n\n# Task: generate essay using an LLM\n    @task\n    def compose_essay(topic: str) -> str:\n        \"\"\"Generate an essay about the given topic.\"\"\"\n        return llm.invoke([\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant that writes essays.\"},\n            {\"role\": \"user\", \"content\": f\"Write an essay about {topic}.\"}\n        ]).content\n\n# Create a checkpointer for persistence\n    checkpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\n    def workflow(topic: str) -> str:\n        \"\"\"Simple workflow that generates an essay with an LLM.\"\"\"\n        return compose_essay(topic).result()\n\n# Execute the workflow\n    config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    result = workflow.invoke(\"the history of flight\", config=config)\n    print(result)\n    ```\n\n## Parallel execution\n\nTasks can be executed in parallel by invoking them concurrently and waiting for the results. This is useful for improving performance in IO bound tasks (e.g., calling APIs for LLMs).\n\n```python\n@task\ndef add_one(number: int) -> int:\n    return number + 1\n\n@entrypoint(checkpointer=checkpointer)\ndef graph(numbers: list[int]) -> list[str]:\n    futures = [add_one(i) for i in numbers]\n    return [f.result() for f in futures]\n```\n\n??? example \"Extended example: parallel LLM calls\"\n\nThis example demonstrates how to run multiple LLM calls in parallel using `@task`. Each call generates a paragraph on a different topic, and results are joined into a single text output.\n\n```python\n    import uuid\n    from langchain.chat_models import init_chat_model\n    from langgraph.func import entrypoint, task\n    from langgraph.checkpoint.memory import InMemorySaver\n\n# Initialize the LLM model\n    llm = init_chat_model(\"openai:gpt-3.5-turbo\")\n\n# Task that generates a paragraph about a given topic\n    @task\n    def generate_paragraph(topic: str) -> str:\n        response = llm.invoke([\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant that writes educational paragraphs.\"},\n            {\"role\": \"user\", \"content\": f\"Write a paragraph about {topic}.\"}\n        ])\n        return response.content\n\n# Create a checkpointer for persistence\n    checkpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\n    def workflow(topics: list[str]) -> str:\n        \"\"\"Generates multiple paragraphs in parallel and combines them.\"\"\"\n        futures = [generate_paragraph(topic) for topic in topics]\n        paragraphs = [f.result() for f in futures]\n        return \"\\n\\n\".join(paragraphs)\n\n# Run the workflow\n    config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    result = workflow.invoke([\"quantum computing\", \"climate change\", \"history of aviation\"], config=config)\n    print(result)\n    ```\n\nThis example uses LangGraph's concurrency model to improve execution time, especially when tasks involve I/O like LLM completions.\n\n## Calling graphs\n\nThe **Functional API** and the [**Graph API**](../concepts/low_level.md) can be used together in the same application as they share the same underlying runtime.\n\n```python\nfrom langgraph.func import entrypoint\nfrom langgraph.graph import StateGraph\n\nbuilder = StateGraph()\n...\nsome_graph = builder.compile()\n\n@entrypoint()\ndef some_workflow(some_input: dict) -> int:\n    # Call a graph defined using the graph API\n    result_1 = some_graph.invoke(...)\n    # Call another graph defined using the graph API\n    result_2 = another_graph.invoke(...)\n    return {\n        \"result_1\": result_1,\n        \"result_2\": result_2\n    }\n```\n\n??? example \"Extended example: calling a simple graph from the functional API\"\n\n```python\n    import uuid\n    from typing import TypedDict\n    from langgraph.func import entrypoint\n    from langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.graph import StateGraph\n\n# Define the shared state type\n    class State(TypedDict):\n        foo: int\n\n# Define a simple transformation node\n    def double(state: State) -> State:\n        return {\"foo\": state[\"foo\"] * 2}\n\n# Build the graph using the Graph API\n    builder = StateGraph(State)\n    builder.add_node(\"double\", double)\n    builder.set_entry_point(\"double\")\n    graph = builder.compile()\n\n# Define the functional API workflow\n    checkpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\n    def workflow(x: int) -> dict:\n        result = graph.invoke({\"foo\": x})\n        return {\"bar\": result[\"foo\"]}\n\n# Execute the workflow\n    config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    print(workflow.invoke(5, config=config))  # Output: {'bar': 10}\n    ```\n\n## Call other entrypoints\n\nYou can call other **entrypoints** from within an **entrypoint** or a **task**.\n\n```python\n@entrypoint() # Will automatically use the checkpointer from the parent entrypoint\ndef some_other_workflow(inputs: dict) -> int:\n    return inputs[\"value\"]\n\n@entrypoint(checkpointer=checkpointer)\ndef my_workflow(inputs: dict) -> int:\n    value = some_other_workflow.invoke({\"value\": 1})\n    return value\n```\n\n??? example \"Extended example: calling another entrypoint\"\n\n```python\n    import uuid\n    from langgraph.func import entrypoint\n    from langgraph.checkpoint.memory import InMemorySaver\n\n# Initialize a checkpointer\n    checkpointer = InMemorySaver()\n\n# A reusable sub-workflow that multiplies a number\n    @entrypoint()\n    def multiply(inputs: dict) -> int:\n        return inputs[\"a\"] * inputs[\"b\"]\n\n# Main workflow that invokes the sub-workflow\n    @entrypoint(checkpointer=checkpointer)\n    def main(inputs: dict) -> dict:\n        result = multiply.invoke({\"a\": inputs[\"x\"], \"b\": inputs[\"y\"]})\n        return {\"product\": result}\n\n# Execute the main workflow\n    config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    print(main.invoke({\"x\": 6, \"y\": 7}, config=config))  # Output: {'product': 42}\n    ```\n\n## Streaming\n\nThe **Functional API** uses the same streaming mechanism as the **Graph API**. Please\nread the [**streaming guide**](../concepts/streaming.md) section for more details.\n\nExample of using the streaming API to stream both updates and custom data.\n\n```python hl_lines=\"17\"\nfrom langgraph.func import entrypoint\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.config import get_stream_writer # (1)!\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef main(inputs: dict) -> int:\n    writer = get_stream_writer() # (2)!\n    writer(\"Started processing\") # (3)!\n    result = inputs[\"x\"] * 2\n    writer(f\"Result is {result}\") # (4)!\n    return result\n\nconfig = {\"configurable\": {\"thread_id\": \"abc\"}}\n\nfor mode, chunk in main.stream( # (5)!\n    {\"x\": 5},\n    stream_mode=[\"custom\", \"updates\"], # (6)!\n    config=config\n):\n    print(f\"{mode}: {chunk}\")\n```\n\n1. Import `get_stream_writer` from `langgraph.config`.\n2. Obtain a stream writer instance within the entrypoint.\n3. Emit custom data before computation begins.\n4. Emit another custom message after computing the result.\n5. Use `.stream()` to process streamed output.\n6. Specify which streaming modes to use.\n\n```pycon\n('updates', {'add_one': 2})\n('updates', {'add_two': 3})\n('custom', 'hello')\n('custom', 'world')\n('updates', {'main': 5})\n```\n\n!!! important \"Async with Python < 3.11\"\n\nIf using Python < 3.11 and writing async code, using `get_stream_writer()` will not work. Instead please\n    use the `StreamWriter` class directly. See [Async with Python < 3.11](../how-tos/streaming.md#async) for more details.\n\n```python hl_lines=\"4\"\n    from langgraph.types import StreamWriter\n\n@entrypoint(checkpointer=checkpointer)\n    async def main(inputs: dict, writer: StreamWriter) -> int:\n        ...\n    ```\n\n## Retry policy\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import RetryPolicy\n\n# This variable is just used for demonstration purposes to simulate a network failure.\n# It's not something you will have in your actual code.\nattempts = 0\n\n# Let's configure the RetryPolicy to retry on ValueError.\n# The default RetryPolicy is optimized for retrying specific network errors.\nretry_policy = RetryPolicy(retry_on=ValueError)\n\n@task(retry_policy=retry_policy)\ndef get_info():\n    global attempts\n    attempts += 1\n\nif attempts < 2:\n        raise ValueError('Failure')\n    return \"OK\"\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef main(inputs, writer):\n    return get_info().result()\n\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"1\"\n    }\n}\n\nmain.invoke({'any_input': 'foobar'}, config=config)\n```\n\n```pycon\n'OK'\n```\n\n## Caching Tasks\n\n```python\nimport time\nfrom langgraph.cache.memory import InMemoryCache\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import CachePolicy\n\n@task(cache_policy=CachePolicy(ttl=120))  # (1)!\ndef slow_add(x: int) -> int:\n    time.sleep(1)\n    return x * 2\n\n@entrypoint(cache=InMemoryCache())\ndef main(inputs: dict) -> dict[str, int]:\n    result1 = slow_add(inputs[\"x\"]).result()\n    result2 = slow_add(inputs[\"x\"]).result()\n    return {\"result1\": result1, \"result2\": result2}\n\nfor chunk in main.stream({\"x\": 5}, stream_mode=\"updates\"):\n    print(chunk)\n\n#> {'slow_add': 10}\n#> {'slow_add': 10, '__metadata__': {'cached': True}}\n#> {'main': {'result1': 10, 'result2': 10}}\n```\n\n1. `ttl` is specified in seconds. The cache will be invalidated after this time.\n\n## Resuming after an error\n\n```python\nimport time\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import StreamWriter\n\n# This variable is just used for demonstration purposes to simulate a network failure.\n# It's not something you will have in your actual code.\nattempts = 0\n\n@task()\ndef get_info():\n    \"\"\"\n    Simulates a task that fails once before succeeding.\n    Raises an exception on the first attempt, then returns \"OK\" on subsequent tries.\n    \"\"\"\n    global attempts\n    attempts += 1\n\nif attempts < 2:\n        raise ValueError(\"Failure\")  # Simulate a failure on the first attempt\n    return \"OK\"\n\n# Initialize an in-memory checkpointer for persistence\ncheckpointer = InMemorySaver()\n\n@task\ndef slow_task():\n    \"\"\"\n    Simulates a slow-running task by introducing a 1-second delay.\n    \"\"\"\n    time.sleep(1)\n    return \"Ran slow task.\"\n\n@entrypoint(checkpointer=checkpointer)\ndef main(inputs, writer: StreamWriter):\n    \"\"\"\n    Main workflow function that runs the slow_task and get_info tasks sequentially.\n\nParameters:\n    - inputs: Dictionary containing workflow input values.\n    - writer: StreamWriter for streaming custom data.\n\nThe workflow first executes `slow_task` and then attempts to execute `get_info`,\n    which will fail on the first invocation.\n    \"\"\"\n    slow_task_result = slow_task().result()  # Blocking call to slow_task\n    get_info().result()  # Exception will be raised here on the first attempt\n    return slow_task_result\n\n# Workflow execution configuration with a unique thread identifier\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"1\"  # Unique identifier to track workflow execution\n    }\n}\n\n# This invocation will take ~1 second due to the slow_task execution\ntry:\n    # First invocation will raise an exception due to the `get_info` task failing\n    main.invoke({'any_input': 'foobar'}, config=config)\nexcept ValueError:\n    pass  # Handle the failure gracefully\n```\n\nWhen we resume execution, we won't need to re-run the `slow_task` as its result is already saved in the checkpoint.\n\n```python\nmain.invoke(None, config=config)\n```\n\n```pycon\n'Ran slow task.'\n```\n\n## Human-in-the-loop\n\nThe functional API supports [human-in-the-loop](../concepts/human_in_the_loop.md) workflows using the `interrupt` function and the `Command` primitive.\n\n### Basic human-in-the-loop workflow\n\nWe will create three [tasks](../concepts/functional_api.md#task):\n\n1. Append `\"bar\"`.\n2. Pause for human input. When resuming, append human input.\n3. Append `\"qux\"`.\n\n```python\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import Command, interrupt\n\n@task\ndef step_1(input_query):\n    \"\"\"Append bar.\"\"\"\n    return f\"{input_query} bar\"\n\n@task\ndef human_feedback(input_query):\n    \"\"\"Append user input.\"\"\"\n    feedback = interrupt(f\"Please provide feedback: {input_query}\")\n    return f\"{input_query} {feedback}\"\n\n@task\ndef step_3(input_query):\n    \"\"\"Append qux.\"\"\"\n    return f\"{input_query} qux\"\n```\n\nWe can now compose these tasks in an [entrypoint](../concepts/functional_api.md#entrypoint):\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef graph(input_query):\n    result_1 = step_1(input_query).result()\n    result_2 = human_feedback(result_1).result()\n    result_3 = step_3(result_2).result()\n\nreturn result_3\n```\n\n[interrupt()](../how-tos/human_in_the_loop/add-human-in-the-loop.md#pause-using-interrupt) is called inside a task, enabling a human to review and edit the output of the previous task. The results of prior tasks-- in this case `step_1`-- are persisted, so that they are not run again following the `interrupt`.\n\nLet's send in a query string:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\nfor event in graph.stream(\"foo\", config):\n    print(event)\n    print(\"\\n\")\n```\n\nNote that we've paused with an `interrupt` after `step_1`. The interrupt provides instructions to resume the run. To resume, we issue a [Command](../how-tos/human_in_the_loop/add-human-in-the-loop.md#resume-using-the-command-primitive) containing the data expected by the `human_feedback` task.\n\n```python\n# Continue execution\nfor event in graph.stream(Command(resume=\"baz\"), config):\n    print(event)\n    print(\"\\n\")\n```\n\nAfter resuming, the run proceeds through the remaining step and terminates as expected.\n\n### Review tool calls\n\nTo review tool calls before execution, we add a `review_tool_call` function that calls [`interrupt`](../how-tos/human_in_the_loop/add-human-in-the-loop.md#pause-using-interrupt). When this function is called, execution will be paused until we issue a command to resume it.\n\nGiven a tool call, our function will `interrupt` for human review. At that point we can either:\n\n- Accept the tool call\n- Revise the tool call and continue\n- Generate a custom tool message (e.g., instructing the model to re-format its tool call)\n\n```python\nfrom typing import Union\n\ndef review_tool_call(tool_call: ToolCall) -> Union[ToolCall, ToolMessage]:\n    \"\"\"Review a tool call, returning a validated version.\"\"\"\n    human_review = interrupt(\n        {\n            \"question\": \"Is this correct?\",\n            \"tool_call\": tool_call,\n        }\n    )\n    review_action = human_review[\"action\"]\n    review_data = human_review.get(\"data\")\n    if review_action == \"continue\":\n        return tool_call\n    elif review_action == \"update\":\n        updated_tool_call = {**tool_call, **{\"args\": review_data}}\n        return updated_tool_call\n    elif review_action == \"feedback\":\n        return ToolMessage(\n            content=review_data, name=tool_call[\"name\"], tool_call_id=tool_call[\"id\"]\n        )\n```\n\nWe can now update our [entrypoint](../concepts/functional_api.md#entrypoint) to review the generated tool calls. If a tool call is accepted or revised, we execute in the same way as before. Otherwise, we just append the `ToolMessage` supplied by the human. The results of prior tasks — in this case the initial model call — are persisted, so that they are not run again following the `interrupt`.\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.graph.message import add_messages\nfrom langgraph.types import Command, interrupt\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef agent(messages, previous):\n    if previous is not None:\n        messages = add_messages(previous, messages)\n\nllm_response = call_model(messages).result()\n    while True:\n        if not llm_response.tool_calls:\n            break\n\n# Review tool calls\n        tool_results = []\n        tool_calls = []\n        for i, tool_call in enumerate(llm_response.tool_calls):\n            review = review_tool_call(tool_call)\n            if isinstance(review, ToolMessage):\n                tool_results.append(review)\n            else:  # is a validated tool call\n                tool_calls.append(review)\n                if review != tool_call:\n                    llm_response.tool_calls[i] = review  # update message\n\n# Execute remaining tool calls\n        tool_result_futures = [call_tool(tool_call) for tool_call in tool_calls]\n        remaining_tool_results = [fut.result() for fut in tool_result_futures]\n\n# Append to message list\n        messages = add_messages(\n            messages,\n            [llm_response, *tool_results, *remaining_tool_results],\n        )\n\n# Call model again\n        llm_response = call_model(messages).result()\n\n# Generate final response\n    messages = add_messages(messages, llm_response)\n    return entrypoint.final(value=llm_response, save=messages)\n```\n\n## Short-term memory\n\nShort-term memory allows storing information across different **invocations** of the same **thread id**. See [short-term memory](../concepts/functional_api.md#short-term-memory) for more details.\n\n### Manage checkpoints\n\nYou can view and delete the information stored by the checkpointer.\n\n#### View thread state (checkpoint)\n\n```python hl_lines=\"3 6 10\"\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"1\",\n        # optionally provide an ID for a specific checkpoint,\n        # otherwise the latest checkpoint is shown\n        # \"checkpoint_id\": \"1f029ca3-1f5b-6704-8004-820c16b69a5a\"\n\n}\n}\ngraph.get_state(config)\n```\n\n```\nStateSnapshot(\n    values={'messages': [HumanMessage(content=\"hi! I'm bob\"), AIMessage(content='Hi Bob! How are you doing today?), HumanMessage(content=\"what's my name?\"), AIMessage(content='Your name is Bob.')]}, next=(),\n    config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-1f5b-6704-8004-820c16b69a5a'}},\n    metadata={\n        'source': 'loop',\n        'writes': {'call_model': {'messages': AIMessage(content='Your name is Bob.')}},\n        'step': 4,\n        'parents': {},\n        'thread_id': '1'\n    },\n    created_at='2025-05-05T16:01:24.680462+00:00',\n    parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-1790-6b0a-8003-baf965b6a38f'}},\n    tasks=(),\n    interrupts=()\n)\n```\n\n#### View the history of the thread (checkpoints)\n\n```python hl_lines=\"3 6\"\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"1\"\n    }\n}\nlist(graph.get_state_history(config))\n```", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "```\n[\n    StateSnapshot(\n        values={'messages': [HumanMessage(content=\"hi! I'm bob\"), AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?'), HumanMessage(content=\"what's my name?\"), AIMessage(content='Your name is Bob.')]},\n        next=(),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-1f5b-6704-8004-820c16b69a5a'}},\n        metadata={'source': 'loop', 'writes': {'call_model': {'messages': AIMessage(content='Your name is Bob.')}}, 'step': 4, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:24.680462+00:00',\n        parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-1790-6b0a-8003-baf965b6a38f'}},\n        tasks=(),\n        interrupts=()\n    ),\n    StateSnapshot(\n        values={'messages': [HumanMessage(content=\"hi! I'm bob\"), AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?'), HumanMessage(content=\"what's my name?\")]},\n        next=('call_model',),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-1790-6b0a-8003-baf965b6a38f'}},\n        metadata={'source': 'loop', 'writes': None, 'step': 3, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:23.863421+00:00',\n        parent_config={...}\n        tasks=(PregelTask(id='8ab4155e-6b15-b885-9ce5-bed69a2c305c', name='call_model', path=('__pregel_pull', 'call_model'), error=None, interrupts=(), state=None, result={'messages': AIMessage(content='Your name is Bob.')}),),\n        interrupts=()\n    ),\n    StateSnapshot(\n        values={'messages': [HumanMessage(content=\"hi! I'm bob\"), AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?')]},\n        next=('__start__',),\n        config={...},\n        metadata={'source': 'input', 'writes': {'__start__': {'messages': [{'role': 'user', 'content': \"what's my name?\"}]}}, 'step': 2, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:23.863173+00:00',\n        parent_config={...}\n        tasks=(PregelTask(id='24ba39d6-6db1-4c9b-f4c5-682aeaf38dcd', name='__start__', path=('__pregel_pull', '__start__'), error=None, interrupts=(), state=None, result={'messages': [{'role': 'user', 'content': \"what's my name?\"}]}),),\n        interrupts=()\n    ),\n    StateSnapshot(\n        values={'messages': [HumanMessage(content=\"hi! I'm bob\"), AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?')]},\n        next=(),\n        config={...},\n        metadata={'source': 'loop', 'writes': {'call_model': {'messages': AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?')}}, 'step': 1, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:23.862295+00:00',\n        parent_config={...}\n        tasks=(),\n        interrupts=()\n    ),\n    StateSnapshot(\n        values={'messages': [HumanMessage(content=\"hi! I'm bob\")]},\n        next=('call_model',),\n        config={...},\n        metadata={'source': 'loop', 'writes': None, 'step': 0, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:22.278960+00:00',\n        parent_config={...}\n        tasks=(PregelTask(id='8cbd75e0-3720-b056-04f7-71ac805140a0', name='call_model', path=('__pregel_pull', 'call_model'), error=None, interrupts=(), state=None, result={'messages': AIMessage(content='Hi Bob! How are you doing today? Is there anything I can help you with?')}),),\n        interrupts=()\n    ),\n    StateSnapshot(\n        values={'messages': []},\n        next=('__start__',),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1f029ca3-0870-6ce2-bfff-1f3f14c3e565'}},\n        metadata={'source': 'input', 'writes': {'__start__': {'messages': [{'role': 'user', 'content': \"hi! I'm bob\"}]}}, 'step': -1, 'parents': {}, 'thread_id': '1'},\n        created_at='2025-05-05T16:01:22.277497+00:00',\n        parent_config=None,\n        tasks=(PregelTask(id='d458367b-8265-812c-18e2-33001d199ce6', name='__start__', path=('__pregel_pull', '__start__'), error=None, interrupts=(), state=None, result={'messages': [{'role': 'user', 'content': \"hi! I'm bob\"}]}),),\n        interrupts=()\n    )\n]\n```\n\n### Decouple return value from saved value\n\nUse `entrypoint.final` to decouple what is returned to the caller from what is persisted in the checkpoint. This is useful when:\n\n- You want to return a computed result (e.g., a summary or status), but save a different internal value for use on the next invocation.\n- You need to control what gets passed to the previous parameter on the next run.\n\n```python\nfrom typing import Optional\nfrom langgraph.func import entrypoint\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef accumulate(n: int, *, previous: Optional[int]) -> entrypoint.final[int, int]:\n    previous = previous or 0\n    total = previous + n\n    # Return the *previous* value to the caller but save the *new* total to the checkpoint.\n    return entrypoint.final(value=previous, save=total)\n\nconfig = {\"configurable\": {\"thread_id\": \"my-thread\"}}\n\nprint(accumulate.invoke(1, config=config))  # 0\nprint(accumulate.invoke(2, config=config))  # 1\nprint(accumulate.invoke(3, config=config))  # 3\n```\n\n### Chatbot example\n\nAn example of a simple chatbot using the functional API and the `InMemorySaver` checkpointer.\nThe bot is able to remember the previous conversation and continue from where it left off.\n\n```python\nfrom langchain_core.messages import BaseMessage\nfrom langgraph.graph import add_messages\nfrom langgraph.func import entrypoint, task\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langchain_anthropic import ChatAnthropic\n\nmodel = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n\n@task\ndef call_model(messages: list[BaseMessage]):\n    response = model.invoke(messages)\n    return response\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(inputs: list[BaseMessage], *, previous: list[BaseMessage]):\n    if previous:\n        inputs = add_messages(previous, inputs)\n\nresponse = call_model(inputs).result()\n    return entrypoint.final(value=response, save=add_messages(inputs, response))\n\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\ninput_message = {\"role\": \"user\", \"content\": \"hi! I'm bob\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n\ninput_message = {\"role\": \"user\", \"content\": \"what's my name?\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n\n??? example \"Extended example: build a simple chatbot\"\n\n[How to add thread-level persistence (functional API)](./persistence-functional.ipynb): Shows how to add thread-level persistence to a functional API workflow and implements a simple chatbot.\n\n## Long-term memory\n\n[long-term memory](../concepts/memory.md#long-term-memory) allows storing information across different **thread ids**. This could be useful for learning information about a given user in one conversation and using it in another.\n\n??? example \"Extended example: add long-term memory\"\n\n[How to add cross-thread persistence (functional API)](./cross-thread-persistence-functional.ipynb): Shows how to add cross-thread persistence to a functional API workflow and implements a simple chatbot.\n\n## Workflows\n\n- [Workflows and agent](../tutorials/workflows.md) guide for more examples of how to build workflows using the Functional API.\n\n## Agents\n\n- [How to create an agent from scratch (Functional API)](./react-agent-from-scratch-functional.ipynb): Shows how to create a simple agent from scratch using the functional API.\n- [How to build a multi-agent network](./multi-agent-network-functional.ipynb): Shows how to build a multi-agent network using the functional API.\n- [How to add multi-turn conversation in a multi-agent application (functional API)](./multi-agent-multi-turn-convo-functional.ipynb): allow an end-user to engage in a multi-turn conversation with one or more agents.\n\n## Integrate with other libraries\n\n- [Add LangGraph's features to other frameworks using the functional API](./autogen-integration-functional.ipynb): Add LangGraph features like persistence, memory and streaming to other agent frameworks that do not provide them out of the box.\n\n---\nhow-tos/subgraph.md\n---\n\n# Use subgraphs\n\nThis guide explains the mechanics of using [subgraphs](../concepts/subgraphs.md). A common application of subgraphs is to build [multi-agent](../concepts/multi_agent.md) systems.\n\nWhen adding subgraphs, you need to define how the parent graph and the subgraph communicate:\n\n* [Shared state schemas](#shared-state-schemas) — parent and subgraph have **shared state keys** in their state [schemas](../concepts/low_level.md#state)\n* [Different state schemas](#different-state-schemas) — **no shared state keys** in parent and subgraph [schemas](../concepts/low_level.md#state)\n\n## Setup\n\n```bash\npip install -U langgraph\n```\n\n!!! tip \"Set up LangSmith for LangGraph development\"\n\nSign up for [LangSmith](https://smith.langchain.com) to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started [here](https://docs.smith.langchain.com).\n\n## Shared state schemas\n\nA common case is for the parent graph and subgraph to communicate over a shared state key (channel) in the [schema](../concepts/low_level.md#state). For example, in [multi-agent](../concepts/multi_agent.md) systems, the agents often communicate over a shared [messages](https://langchain-ai.github.io/langgraph/concepts/low_level.md#why-use-messages) key.\n\nIf your subgraph shares state keys with the parent graph, you can follow these steps to add it to your graph:\n\n1. Define the subgraph workflow (`subgraph_builder` in the example below) and compile it\n2. Pass compiled subgraph to the `.add_node` method when defining the parent graph workflow\n\n```python\nfrom typing_extensions import TypedDict\nfrom langgraph.graph.state import StateGraph, START\n\nclass State(TypedDict):\n    foo: str\n\n# Subgraph\n\ndef subgraph_node_1(state: State):\n    return {\"foo\": \"hi! \" + state[\"foo\"]}\n\nsubgraph_builder = StateGraph(State)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", subgraph)\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n```\n\n??? example \"Full example: shared state schemas\"\n\n```python\n    from typing_extensions import TypedDict\n    from langgraph.graph.state import StateGraph, START\n\n# Define subgraph\n    class SubgraphState(TypedDict):\n        foo: str  # (1)! \n        bar: str  # (2)!\n    \n    def subgraph_node_1(state: SubgraphState):\n        return {\"bar\": \"bar\"}\n    \n    def subgraph_node_2(state: SubgraphState):\n        # note that this node is using a state key ('bar') that is only available in the subgraph\n        # and is sending update on the shared state key ('foo')\n        return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n    \n    subgraph_builder = StateGraph(SubgraphState)\n    subgraph_builder.add_node(subgraph_node_1)\n    subgraph_builder.add_node(subgraph_node_2)\n    subgraph_builder.add_edge(START, \"subgraph_node_1\")\n    subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n    subgraph = subgraph_builder.compile()\n    \n    # Define parent graph\n    class ParentState(TypedDict):\n        foo: str\n    \n    def node_1(state: ParentState):\n        return {\"foo\": \"hi! \" + state[\"foo\"]}\n    \n    builder = StateGraph(ParentState)\n    builder.add_node(\"node_1\", node_1)\n    builder.add_node(\"node_2\", subgraph)\n    builder.add_edge(START, \"node_1\")\n    builder.add_edge(\"node_1\", \"node_2\")\n    graph = builder.compile()\n    \n    for chunk in graph.stream({\"foo\": \"foo\"}):\n        print(chunk)\n    ```\n\n1. This key is shared with the parent graph state\n    2. This key is private to the `SubgraphState` and is not visible to the parent graph\n    \n    ```\n    {'node_1': {'foo': 'hi! foo'}}\n    {'node_2': {'foo': 'hi! foobar'}}\n    ```\n\n## Different state schemas\n\nFor more complex systems you might want to define subgraphs that have a **completely different schema** from the parent graph (no shared keys). For example, you might want to keep a private message history for each of the agents in a [multi-agent](../concepts/multi_agent.md) system.\n\nIf that's the case for your application, you need to define a node **function that invokes the subgraph**. This function needs to transform the input (parent) state to the subgraph state before invoking the subgraph, and transform the results back to the parent state before returning the state update from the node.\n\n```python\nfrom typing_extensions import TypedDict\nfrom langgraph.graph.state import StateGraph, START\n\nclass SubgraphState(TypedDict):\n    bar: str\n\n# Subgraph\n\ndef subgraph_node_1(state: SubgraphState):\n    return {\"bar\": \"hi! \" + state[\"bar\"]}\n\nsubgraph_builder = StateGraph(SubgraphState)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nclass State(TypedDict):\n    foo: str\n\ndef call_subgraph(state: State):\n    subgraph_output = subgraph.invoke({\"bar\": state[\"foo\"]})  # (1)!\n    return {\"foo\": subgraph_output[\"bar\"]}  # (2)!\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", call_subgraph)\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n```\n\n1. Transform the state to the subgraph state\n2. Transform response back to the parent state\n\n??? example \"Full example: different state schemas\"\n\n```python\n    from typing_extensions import TypedDict\n    from langgraph.graph.state import StateGraph, START\n\n# Define subgraph\n    class SubgraphState(TypedDict):\n        # note that none of these keys are shared with the parent graph state\n        bar: str\n        baz: str\n    \n    def subgraph_node_1(state: SubgraphState):\n        return {\"baz\": \"baz\"}\n    \n    def subgraph_node_2(state: SubgraphState):\n        return {\"bar\": state[\"bar\"] + state[\"baz\"]}\n    \n    subgraph_builder = StateGraph(SubgraphState)\n    subgraph_builder.add_node(subgraph_node_1)\n    subgraph_builder.add_node(subgraph_node_2)\n    subgraph_builder.add_edge(START, \"subgraph_node_1\")\n    subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n    subgraph = subgraph_builder.compile()\n    \n    # Define parent graph\n    class ParentState(TypedDict):\n        foo: str\n    \n    def node_1(state: ParentState):\n        return {\"foo\": \"hi! \" + state[\"foo\"]}\n    \n    def node_2(state: ParentState):\n        response = subgraph.invoke({\"bar\": state[\"foo\"]})  # (1)!\n        return {\"foo\": response[\"bar\"]}  # (2)!\n    \n    \n    builder = StateGraph(ParentState)\n    builder.add_node(\"node_1\", node_1)\n    builder.add_node(\"node_2\", node_2)\n    builder.add_edge(START, \"node_1\")\n    builder.add_edge(\"node_1\", \"node_2\")\n    graph = builder.compile()\n    \n    for chunk in graph.stream({\"foo\": \"foo\"}, subgraphs=True):\n        print(chunk)\n    ```\n\n1. Transform the state to the subgraph state\n    2. Transform response back to the parent state\n\n```\n    ((), {'node_1': {'foo': 'hi! foo'}})\n    (('node_2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7',), {'grandchild_1': {'my_grandchild_key': 'hi Bob, how are you'}})\n    (('node_2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7',), {'grandchild_2': {'bar': 'hi! foobaz'}})\n    ((), {'node_2': {'foo': 'hi! foobaz'}})\n    ```\n\n??? example \"Full example: different state schemas (two levels of subgraphs)\"\n\nThis is an example with two levels of subgraphs: parent -> child -> grandchild.\n\n```python\n    # Grandchild graph\n    from typing_extensions import TypedDict\n    from langgraph.graph.state import StateGraph, START, END\n    \n    class GrandChildState(TypedDict):\n        my_grandchild_key: str\n    \n    def grandchild_1(state: GrandChildState) -> GrandChildState:\n        # NOTE: child or parent keys will not be accessible here\n        return {\"my_grandchild_key\": state[\"my_grandchild_key\"] + \", how are you\"}\n    \n    \n    grandchild = StateGraph(GrandChildState)\n    grandchild.add_node(\"grandchild_1\", grandchild_1)\n    \n    grandchild.add_edge(START, \"grandchild_1\")\n    grandchild.add_edge(\"grandchild_1\", END)\n    \n    grandchild_graph = grandchild.compile()\n    \n    # Child graph\n    class ChildState(TypedDict):\n        my_child_key: str\n    \n    def call_grandchild_graph(state: ChildState) -> ChildState:\n        # NOTE: parent or grandchild keys won't be accessible here\n        grandchild_graph_input = {\"my_grandchild_key\": state[\"my_child_key\"]}  # (1)!\n        grandchild_graph_output = grandchild_graph.invoke(grandchild_graph_input)\n        return {\"my_child_key\": grandchild_graph_output[\"my_grandchild_key\"] + \" today?\"}  # (2)!\n    \n    child = StateGraph(ChildState)\n    child.add_node(\"child_1\", call_grandchild_graph)  # (3)!\n    child.add_edge(START, \"child_1\")\n    child.add_edge(\"child_1\", END)\n    child_graph = child.compile()\n    \n    # Parent graph\n    class ParentState(TypedDict):\n        my_key: str\n    \n    def parent_1(state: ParentState) -> ParentState:\n        # NOTE: child or grandchild keys won't be accessible here\n        return {\"my_key\": \"hi \" + state[\"my_key\"]}\n    \n    def parent_2(state: ParentState) -> ParentState:\n        return {\"my_key\": state[\"my_key\"] + \" bye!\"}\n    \n    def call_child_graph(state: ParentState) -> ParentState:\n        child_graph_input = {\"my_child_key\": state[\"my_key\"]}  # (4)!\n        child_graph_output = child_graph.invoke(child_graph_input)\n        return {\"my_key\": child_graph_output[\"my_child_key\"]}  # (5)!\n    \n    parent = StateGraph(ParentState)\n    parent.add_node(\"parent_1\", parent_1)\n    parent.add_node(\"child\", call_child_graph)  # (6)!\n    parent.add_node(\"parent_2\", parent_2)\n    \n    parent.add_edge(START, \"parent_1\")\n    parent.add_edge(\"parent_1\", \"child\")\n    parent.add_edge(\"child\", \"parent_2\")\n    parent.add_edge(\"parent_2\", END)\n    \n    parent_graph = parent.compile()\n    \n    for chunk in parent_graph.stream({\"my_key\": \"Bob\"}, subgraphs=True):\n        print(chunk)\n    ```\n\n1. We're transforming the state from the child state channels (`my_child_key`) to the child state channels (`my_grandchild_key`)\n    2. We're transforming the state from the grandchild state channels (`my_grandchild_key`) back to the child state channels (`my_child_key`)\n    3. We're passing a function here instead of just compiled graph (`grandchild_graph`)\n    4. We're transforming the state from the parent state channels (`my_key`) to the child state channels (`my_child_key`)\n    5. We're transforming the state from the child state channels (`my_child_key`) back to the parent state channels (`my_key`)\n    6. We're passing a function here instead of just a compiled graph (`child_graph`)\n\n```\n    ((), {'parent_1': {'my_key': 'hi Bob'}})\n    (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b', 'child_1:781bb3b1-3971-84ce-810b-acf819a03f9c'), {'grandchild_1': {'my_grandchild_key': 'hi Bob, how are you'}})\n    (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b',), {'child_1': {'my_child_key': 'hi Bob, how are you today?'}})\n    ((), {'child': {'my_key': 'hi Bob, how are you today?'}})\n    ((), {'parent_2': {'my_key': 'hi Bob, how are you today? bye!'}})\n    ```\n\n## Add persistence\n\nYou only need to **provide the checkpointer when compiling the parent graph**. LangGraph will automatically propagate the checkpointer to the child subgraphs.\n\n```python\nfrom langgraph.graph import START, StateGraph\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom typing_extensions import TypedDict\n\nclass State(TypedDict):\n    foo: str\n\n# Subgraph\n\ndef subgraph_node_1(state: State):\n    return {\"foo\": state[\"foo\"] + \"bar\"}\n\nsubgraph_builder = StateGraph(State)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", subgraph)\nbuilder.add_edge(START, \"node_1\")\n\ncheckpointer = MemorySaver()\ngraph = builder.compile(checkpointer=checkpointer)\n```\n\nIf you want the subgraph to **have its own memory**, you can compile it with the appropriate checkpointer option. This is useful in [multi-agent](../concepts/multi_agent.md) systems, if you want agents to keep track of their internal message histories:\n\n```python\nsubgraph_builder = StateGraph(...)\nsubgraph = subgraph_builder.compile(checkpointer=True)\n```\n\n## View subgraph state\n\nWhen you enable [persistence](../concepts/persistence.md), you can [inspect the graph state](../concepts/persistence.md#checkpoints) (checkpoint) via the appropriate method. To view the subgraph state, you can use the subgraphs option.\n\nYou can inspect the graph state via `graph.get_state(config)`. To view the subgraph state, you can use `graph.get_state(config, subgraphs=True)`.\n\n!!! important \"Available **only** when interrupted\"\n\nSubgraph state can only be viewed **when the subgraph is interrupted**. Once you resume the graph, you won't be able to access the subgraph state.\n\n??? example \"View interrupted subgraph state\"\n\n```python\n    from langgraph.graph import START, StateGraph\n    from langgraph.checkpoint.memory import MemorySaver\n    from langgraph.types import interrupt, Command\n    from typing_extensions import TypedDict\n    \n    class State(TypedDict):\n        foo: str\n    \n    # Subgraph\n    \n    def subgraph_node_1(state: State):\n        value = interrupt(\"Provide value:\")\n        return {\"foo\": state[\"foo\"] + value}\n    \n    subgraph_builder = StateGraph(State)\n    subgraph_builder.add_node(subgraph_node_1)\n    subgraph_builder.add_edge(START, \"subgraph_node_1\")\n    \n    subgraph = subgraph_builder.compile()\n    \n    # Parent graph\n        \n    builder = StateGraph(State)\n    builder.add_node(\"node_1\", subgraph)\n    builder.add_edge(START, \"node_1\")\n    \n    checkpointer = MemorySaver()\n    graph = builder.compile(checkpointer=checkpointer)\n    \n    config = {\"configurable\": {\"thread_id\": \"1\"}}\n    \n    graph.invoke({\"foo\": \"\"}, config)\n    parent_state = graph.get_state(config)\n    subgraph_state = graph.get_state(config, subgraphs=True).tasks[0].state  # (1)!\n    \n    # resume the subgraph\n    graph.invoke(Command(resume=\"bar\"), config)\n    ```\n    \n    1. This will be available only when the subgraph is interrupted. Once you resume the graph, you won't be able to access the subgraph state.\n\n## Stream subgraph outputs\n\nTo include outputs from subgraphs in the streamed outputs, you can set the subgraphs option in the stream method of the parent graph. This will stream outputs from both the parent graph and any subgraphs.\n\n```python\nfor chunk in graph.stream(\n    {\"foo\": \"foo\"},\n    subgraphs=True, # (1)!\n    stream_mode=\"updates\",\n):\n    print(chunk)\n```\n\n1. Set `subgraphs=True` to stream outputs from subgraphs.\n\n??? example \"Stream from subgraphs\"\n\n```python\n    from typing_extensions import TypedDict\n    from langgraph.graph.state import StateGraph, START\n\n# Define subgraph\n    class SubgraphState(TypedDict):\n        foo: str\n        bar: str\n    \n    def subgraph_node_1(state: SubgraphState):\n        return {\"bar\": \"bar\"}\n    \n    def subgraph_node_2(state: SubgraphState):\n        # note that this node is using a state key ('bar') that is only available in the subgraph\n        # and is sending update on the shared state key ('foo')\n        return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n    \n    subgraph_builder = StateGraph(SubgraphState)\n    subgraph_builder.add_node(subgraph_node_1)\n    subgraph_builder.add_node(subgraph_node_2)\n    subgraph_builder.add_edge(START, \"subgraph_node_1\")\n    subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n    subgraph = subgraph_builder.compile()\n    \n    # Define parent graph\n    class ParentState(TypedDict):\n        foo: str\n    \n    def node_1(state: ParentState):\n        return {\"foo\": \"hi! \" + state[\"foo\"]}\n    \n    builder = StateGraph(ParentState)\n    builder.add_node(\"node_1\", node_1)\n    builder.add_node(\"node_2\", subgraph)\n    builder.add_edge(START, \"node_1\")\n    builder.add_edge(\"node_1\", \"node_2\")\n    graph = builder.compile()\n\nfor chunk in graph.stream(\n        {\"foo\": \"foo\"},\n        stream_mode=\"updates\",\n        subgraphs=True, # (1)!\n    ):\n        print(chunk)\n    ```\n  \n    1. Set `subgraphs=True` to stream outputs from subgraphs.\n\n```\n    ((), {'node_1': {'foo': 'hi! foo'}})\n    (('node_2:e58e5673-a661-ebb0-70d4-e298a7fc28b7',), {'subgraph_node_1': {'bar': 'bar'}})\n    (('node_2:e58e5673-a661-ebb0-70d4-e298a7fc28b7',), {'subgraph_node_2': {'foo': 'hi! foobar'}})\n    ((), {'node_2': {'foo': 'hi! foobar'}})\n    ```\n\n---\nhow-tos/multi_agent.md\n---\n\n# Build multi-agent systems\n\nA single agent might struggle if it needs to specialize in multiple domains or manage many tools. To tackle this, you can break your agent into smaller, independent agents and composing them into a [multi-agent system](../concepts/multi_agent.md).\n\nIn multi-agent systems, agents need to communicate between each other. They do so via [handoffs](#handoffs) — a primitive that describes which agent to hand control to and the payload to send to that agent.\n\nThis guide covers the following:\n\n* implementing [handoffs](#handoffs) between agents\n* using handoffs and the prebuilt [agent](../agents/agents.md) to [build a custom multi-agent system](#build-a-multi-agent-system)\n\nTo get started with building multi-agent systems, check out LangGraph [prebuilt implementations](#prebuilt-implementations) of two of the most popular multi-agent architectures — [supervisor](../agents/multi-agent.md#supervisor) and [swarm](../agents/multi-agent.md#swarm).\n\n## Handoffs\n\nTo set up communication between the agents in a multi-agent system you can use [**handoffs**](../concepts/multi_agent.md#handoffs) — a pattern where one agent *hands off* control to another. Handoffs allow you to specify:\n\n- **destination**: target agent to navigate to (e.g., name of the LangGraph node to go to)\n- **payload**: information to pass to that agent (e.g., state update)\n\n### Create handoffs\n\nTo implement handoffs, you can return `Command` objects from your agent nodes or tools:\n\n```python hl_lines=\"13 14 23 24 25\"\nfrom typing import Annotated\nfrom langchain_core.tools import tool, InjectedToolCallId\nfrom langgraph.prebuilt import create_react_agent, InjectedState\nfrom langgraph.graph import StateGraph, START, MessagesState\nfrom langgraph.types import Command\n\ndef create_handoff_tool(*, agent_name: str, description: str | None = None):\n    name = f\"transfer_to_{agent_name}\"\n    description = description or f\"Transfer to {agent_name}\"\n\n@tool(name, description=description)\n    def handoff_tool(\n        state: Annotated[MessagesState, InjectedState], # (1)!\n        tool_call_id: Annotated[str, InjectedToolCallId],\n    ) -> Command:\n        tool_message = {\n            \"role\": \"tool\",\n            \"content\": f\"Successfully transferred to {agent_name}\",\n            \"name\": name,\n            \"tool_call_id\": tool_call_id,\n        }\n        return Command(  # (2)!\n            goto=agent_name,  # (3)!\n            update={\"messages\": state[\"messages\"] + [tool_message]},  # (4)!\n            graph=Command.PARENT,  # (5)!\n        )\n    return handoff_tool\n```", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "1. Access the [state](../concepts/low_level.md#state) of the agent that is calling the handoff tool using the [InjectedState](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.InjectedState) annotation. \n2. The `Command` primitive allows specifying a state update and a node transition as a single operation, making it useful for implementing handoffs.\n3. Name of the agent or node to hand off to.\n4. Take the agent's messages and **add** them to the parent's **state** as part of the handoff. The next agent will see the parent state.\n5. Indicate to LangGraph that we need to navigate to agent node in a **parent** multi-agent graph.\n\n!!! tip\n\nIf you want to use tools that return `Command`, you can either use prebuilt [`create_react_agent`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.chat_agent_executor.create_react_agent) / [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode) components, or implement your own tool-executing node that collects `Command` objects returned by the tools and returns a list of them, e.g.:\n    \n    ```python\n    def call_tools(state):\n        ...\n        commands = [tools_by_name[tool_call[\"name\"]].invoke(tool_call) for tool_call in tool_calls]\n        return commands\n    ```\n\n!!! Important\n\nThis handoff implementation assumes that:\n    \n    - each agent receives overall message history (across all agents) in the multi-agent system as its input. If you want more control over agent inputs, see [this section](#control-agent-inputs)\n    - each agent outputs its internal messages history to the overall message history of the multi-agent system. If you want more control over **how agent outputs are added**, wrap the agent in a separate node function:\n\n```python hl_lines=\"5\"\n      def call_hotel_assistant(state):\n          # return agent's final response,\n          # excluding inner monologue\n          response = hotel_assistant.invoke(state)\n          return {\"messages\": response[\"messages\"][-1]}\n      ```\n\n### Control agent inputs\n\nYou can use the [`Send()`](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Send) primitive to directly send data to the worker agents during the handoff. For example, you can request that the calling agent populate a task description for the next agent:\n\n```python hl_lines=\"5 26\"\nfrom typing import Annotated\nfrom langchain_core.tools import tool, InjectedToolCallId\nfrom langgraph.prebuilt import InjectedState\nfrom langgraph.graph import StateGraph, START, MessagesState\nfrom langgraph.types import Command, Send\n\ndef create_task_description_handoff_tool(\n    *, agent_name: str, description: str | None = None\n):\n    name = f\"transfer_to_{agent_name}\"\n    description = description or f\"Ask {agent_name} for help.\"\n\n@tool(name, description=description)\n    def handoff_tool(\n        # this is populated by the calling agent\n        task_description: Annotated[\n            str,\n            \"Description of what the next agent should do, including all of the relevant context.\",\n        ],\n        # these parameters are ignored by the LLM\n        state: Annotated[MessagesState, InjectedState],\n    ) -> Command:\n        task_description_message = {\"role\": \"user\", \"content\": task_description}\n        agent_input = {**state, \"messages\": [task_description_message]}\n        return Command(\n            goto=[Send(agent_name, agent_input)],\n            graph=Command.PARENT,\n        )\n\nreturn handoff_tool\n```\n\nSee the multi-agent [supervisor](../tutorials/multi_agent/agent_supervisor.md#4-create-delegation-tasks) example for a full example of using [`Send()`](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Send) in handoffs.\n\n## Build a multi-agent system\n\nYou can use handoffs in any agents built with LangGraph. We recommend using the prebuilt [agent](../agents/overview.md) or [`ToolNode`](./tool-calling.md#toolnode), as they natively support handoffs tools returning `Command`. Below is an example of how you can implement a multi-agent system for booking travel using handoffs:\n\n```python hl_lines=\"16 17 21 22 28 29\"\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.graph import StateGraph, START, MessagesState\n\ndef create_handoff_tool(*, agent_name: str, description: str | None = None):\n    # same implementation as above\n    ...\n    return Command(...)\n\n# Handoffs\ntransfer_to_hotel_assistant = create_handoff_tool(agent_name=\"hotel_assistant\")\ntransfer_to_flight_assistant = create_handoff_tool(agent_name=\"flight_assistant\")\n\n# Define agents\nflight_assistant = create_react_agent(\n    model=\"anthropic:claude-3-5-sonnet-latest\",\n    tools=[..., transfer_to_hotel_assistant],\n    name=\"flight_assistant\"\n)\nhotel_assistant = create_react_agent(\n    model=\"anthropic:claude-3-5-sonnet-latest\",\n    tools=[..., transfer_to_flight_assistant],\n    name=\"hotel_assistant\"\n)\n\n# Define multi-agent graph\nmulti_agent_graph = (\n    StateGraph(MessagesState)\n    .add_node(flight_assistant)\n    .add_node(hotel_assistant)\n    .add_edge(START, \"flight_assistant\")\n    .compile()\n)\n```\n\n??? example \"Full example: Multi-agent system for booking travel\"\n\n```python hl_lines=\"56 57 66 67 68 94 96 100 102 124\"\n    from typing import Annotated\n    from langchain_core.messages import convert_to_messages\n    from langchain_core.tools import tool, InjectedToolCallId\n    from langgraph.prebuilt import create_react_agent, InjectedState\n    from langgraph.graph import StateGraph, START, MessagesState\n    from langgraph.types import Command\n    \n    # We'll use `pretty_print_messages` helper to render the streamed agent outputs nicely\n    \n    def pretty_print_message(message, indent=False):\n        pretty_message = message.pretty_repr(html=True)\n        if not indent:\n            print(pretty_message)\n            return\n    \n        indented = \"\\n\".join(\"\\t\" + c for c in pretty_message.split(\"\\n\"))\n        print(indented)\n    \n    \n    def pretty_print_messages(update, last_message=False):\n        is_subgraph = False\n        if isinstance(update, tuple):\n            ns, update = update\n            # skip parent graph updates in the printouts\n            if len(ns) == 0:\n                return\n    \n            graph_id = ns[-1].split(\":\")[0]\n            print(f\"Update from subgraph {graph_id}:\")\n            print(\"\\n\")\n            is_subgraph = True\n    \n        for node_name, node_update in update.items():\n            update_label = f\"Update from node {node_name}:\"\n            if is_subgraph:\n                update_label = \"\\t\" + update_label\n    \n            print(update_label)\n            print(\"\\n\")\n    \n            messages = convert_to_messages(node_update[\"messages\"])\n            if last_message:\n                messages = messages[-1:]\n    \n            for m in messages:\n                pretty_print_message(m, indent=is_subgraph)\n            print(\"\\n\")\n\ndef create_handoff_tool(*, agent_name: str, description: str | None = None):\n        name = f\"transfer_to_{agent_name}\"\n        description = description or f\"Transfer to {agent_name}\"\n    \n        @tool(name, description=description)\n        def handoff_tool(\n            state: Annotated[MessagesState, InjectedState], # (1)!\n            tool_call_id: Annotated[str, InjectedToolCallId],\n        ) -> Command:\n            tool_message = {\n                \"role\": \"tool\",\n                \"content\": f\"Successfully transferred to {agent_name}\",\n                \"name\": name,\n                \"tool_call_id\": tool_call_id,\n            }\n            return Command(  # (2)!\n                goto=agent_name,  # (3)!\n                update={\"messages\": state[\"messages\"] + [tool_message]},  # (4)!\n                graph=Command.PARENT,  # (5)!\n            )\n        return handoff_tool\n    \n    # Handoffs\n    transfer_to_hotel_assistant = create_handoff_tool(\n        agent_name=\"hotel_assistant\",\n        description=\"Transfer user to the hotel-booking assistant.\",\n    )\n    transfer_to_flight_assistant = create_handoff_tool(\n        agent_name=\"flight_assistant\",\n        description=\"Transfer user to the flight-booking assistant.\",\n    )\n    \n    # Simple agent tools\n    def book_hotel(hotel_name: str):\n        \"\"\"Book a hotel\"\"\"\n        return f\"Successfully booked a stay at {hotel_name}.\"\n    \n    def book_flight(from_airport: str, to_airport: str):\n        \"\"\"Book a flight\"\"\"\n        return f\"Successfully booked a flight from {from_airport} to {to_airport}.\"\n    \n    # Define agents\n    flight_assistant = create_react_agent(\n        model=\"anthropic:claude-3-5-sonnet-latest\",\n        tools=[book_flight, transfer_to_hotel_assistant],\n        prompt=\"You are a flight booking assistant\",\n        name=\"flight_assistant\"\n    )\n    hotel_assistant = create_react_agent(\n        model=\"anthropic:claude-3-5-sonnet-latest\",\n        tools=[book_hotel, transfer_to_flight_assistant],\n        prompt=\"You are a hotel booking assistant\",\n        name=\"hotel_assistant\"\n    )\n    \n    # Define multi-agent graph\n    multi_agent_graph = (\n        StateGraph(MessagesState)\n        .add_node(flight_assistant)\n        .add_node(hotel_assistant)\n        .add_edge(START, \"flight_assistant\")\n        .compile()\n    )\n    \n    # Run the multi-agent graph\n    for chunk in multi_agent_graph.stream(\n        {\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": \"book a flight from BOS to JFK and a stay at McKittrick Hotel\"\n                }\n            ]\n        },\n        subgraphs=True\n    ):\n        pretty_print_messages(chunk)\n    ```\n\n1. Access agent's state\n    2. The `Command` primitive allows specifying a state update and a node transition as a single operation, making it useful for implementing handoffs.\n    3. Name of the agent or node to hand off to.\n    4. Take the agent's messages and **add** them to the parent's **state** as part of the handoff. The next agent will see the parent state.\n    5. Indicate to LangGraph that we need to navigate to agent node in a **parent** multi-agent graph.\n\n## Multi-turn conversation\n\nUsers might want to engage in a *multi-turn conversation* with one or more agents. To build a system that can handle this, you can create a node that uses an [`interrupt`](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Interrupt) to collect user input and routes back to the **active** agent.\n\nThe agents can then be implemented as nodes in a graph that executes agent steps and determines the next action:\n\n1. **Wait for user input** to continue the conversation, or  \n2. **Route to another agent** (or back to itself, such as in a loop) via a [handoff](#handoffs)\n\n```python\ndef human(state) -> Command[Literal[\"agent\", \"another_agent\"]]:\n    \"\"\"A node for collecting user input.\"\"\"\n    user_input = interrupt(value=\"Ready for user input.\")\n\n# Determine the active agent.\n    active_agent = ...\n\n...\n    return Command(\n        update={\n            \"messages\": [{\n                \"role\": \"human\",\n                \"content\": user_input,\n            }]\n        },\n        goto=active_agent\n    )\n\ndef agent(state) -> Command[Literal[\"agent\", \"another_agent\", \"human\"]]:\n    # The condition for routing/halting can be anything, e.g. LLM tool call / structured output, etc.\n    goto = get_next_agent(...)  # 'agent' / 'another_agent'\n    if goto:\n        return Command(goto=goto, update={\"my_state_key\": \"my_state_value\"})\n    else:\n        return Command(goto=\"human\") # Go to human node\n```\n\n??? example \"Full example: multi-agent system for travel recommendations\"\n\nIn this example, we will build a team of travel assistant agents that can communicate with each other via handoffs.\n    \n    We will create 2 agents:\n    \n    * travel_advisor: can help with travel destination recommendations. Can ask hotel_advisor for help.\n    * hotel_advisor: can help with hotel recommendations. Can ask travel_advisor for help.\n\n```python\n    from langchain_anthropic import ChatAnthropic\n    from langgraph.graph import MessagesState, StateGraph, START\n    from langgraph.prebuilt import create_react_agent, InjectedState\n    from langgraph.types import Command, interrupt\n    from langgraph.checkpoint.memory import InMemorySaver\n    \n    \n    model = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n\nclass MultiAgentState(MessagesState):\n        last_active_agent: str\n    \n    \n    # Define travel advisor tools and ReAct agent\n    travel_advisor_tools = [\n        get_travel_recommendations,\n        make_handoff_tool(agent_name=\"hotel_advisor\"),\n    ]\n    travel_advisor = create_react_agent(\n        model,\n        travel_advisor_tools,\n        prompt=(\n            \"You are a general travel expert that can recommend travel destinations (e.g. countries, cities, etc). \"\n            \"If you need hotel recommendations, ask 'hotel_advisor' for help. \"\n            \"You MUST include human-readable response before transferring to another agent.\"\n        ),\n    )\n    \n    \n    def call_travel_advisor(\n        state: MultiAgentState,\n    ) -> Command[Literal[\"hotel_advisor\", \"human\"]]:\n        # You can also add additional logic like changing the input to the agent / output from the agent, etc.\n        # NOTE: we're invoking the ReAct agent with the full history of messages in the state\n        response = travel_advisor.invoke(state)\n        update = {**response, \"last_active_agent\": \"travel_advisor\"}\n        return Command(update=update, goto=\"human\")\n    \n    \n    # Define hotel advisor tools and ReAct agent\n    hotel_advisor_tools = [\n        get_hotel_recommendations,\n        make_handoff_tool(agent_name=\"travel_advisor\"),\n    ]\n    hotel_advisor = create_react_agent(\n        model,\n        hotel_advisor_tools,\n        prompt=(\n            \"You are a hotel expert that can provide hotel recommendations for a given destination. \"\n            \"If you need help picking travel destinations, ask 'travel_advisor' for help.\"\n            \"You MUST include human-readable response before transferring to another agent.\"\n        ),\n    )\n    \n    \n    def call_hotel_advisor(\n        state: MultiAgentState,\n    ) -> Command[Literal[\"travel_advisor\", \"human\"]]:\n        response = hotel_advisor.invoke(state)\n        update = {**response, \"last_active_agent\": \"hotel_advisor\"}\n        return Command(update=update, goto=\"human\")\n    \n    \n    def human_node(\n        state: MultiAgentState, config\n    ) -> Command[Literal[\"hotel_advisor\", \"travel_advisor\", \"human\"]]:\n        \"\"\"A node for collecting user input.\"\"\"\n    \n        user_input = interrupt(value=\"Ready for user input.\")\n        active_agent = state[\"last_active_agent\"]\n    \n        return Command(\n            update={\n                \"messages\": [\n                    {\n                        \"role\": \"human\",\n                        \"content\": user_input,\n                    }\n                ]\n            },\n            goto=active_agent,\n        )\n    \n    \n    builder = StateGraph(MultiAgentState)\n    builder.add_node(\"travel_advisor\", call_travel_advisor)\n    builder.add_node(\"hotel_advisor\", call_hotel_advisor)\n    \n    # This adds a node to collect human input, which will route\n    # back to the active agent.\n    builder.add_node(\"human\", human_node)\n    \n    # We'll always start with a general travel advisor.\n    builder.add_edge(START, \"travel_advisor\")\n    \n    \n    checkpointer = InMemorySaver()\n    graph = builder.compile(checkpointer=checkpointer)\n    ```\n    \n    Let's test a multi turn conversation with this application.\n\n```python\n    import uuid\n    \n    thread_config = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n    \n    inputs = [\n        # 1st round of conversation,\n        {\n            \"messages\": [\n                {\"role\": \"user\", \"content\": \"i wanna go somewhere warm in the caribbean\"}\n            ]\n        },\n        # Since we're using `interrupt`, we'll need to resume using the Command primitive.\n        # 2nd round of conversation,\n        Command(\n            resume=\"could you recommend a nice hotel in one of the areas and tell me which area it is.\"\n        ),\n        # 3rd round of conversation,\n        Command(\n            resume=\"i like the first one. could you recommend something to do near the hotel?\"\n        ),\n    ]\n    \n    for idx, user_input in enumerate(inputs):\n        print()\n        print(f\"--- Conversation Turn {idx + 1} ---\")\n        print()\n        print(f\"User: {user_input}\")\n        print()\n        for update in graph.stream(\n            user_input,\n            config=thread_config,\n            stream_mode=\"updates\",\n        ):\n            for node_id, value in update.items():\n                if isinstance(value, dict) and value.get(\"messages\", []):\n                    last_message = value[\"messages\"][-1]\n                    if isinstance(last_message, dict) or last_message.type != \"ai\":\n                        continue\n                    print(f\"{node_id}: {last_message.content}\")\n    ```\n    \n    ```\n    --- Conversation Turn 1 ---\n    \n    User: {'messages': [{'role': 'user', 'content': 'i wanna go somewhere warm in the caribbean'}]}\n    \n    travel_advisor: Based on the recommendations, Aruba would be an excellent choice for your Caribbean getaway! Aruba is known as \"One Happy Island\" and offers:\n    - Year-round warm weather with consistent temperatures around 82°F (28°C)\n    - Beautiful white sand beaches like Eagle Beach and Palm Beach\n    - Clear turquoise waters perfect for swimming and snorkeling\n    - Minimal rainfall and location outside the hurricane belt\n    - A blend of Caribbean and Dutch culture\n    - Great dining options and nightlife\n    - Various water sports and activities\n    \n    Would you like me to get some specific hotel recommendations in Aruba for your stay? I can transfer you to our hotel advisor who can help with accommodations.\n    \n    --- Conversation Turn 2 ---\n    \n    User: Command(resume='could you recommend a nice hotel in one of the areas and tell me which area it is.')\n    \n    hotel_advisor: Based on the recommendations, I can suggest two excellent options:\n    \n    1. The Ritz-Carlton, Aruba - Located in Palm Beach\n    - This luxury resort is situated in the vibrant Palm Beach area\n    - Known for its exceptional service and amenities\n    - Perfect if you want to be close to dining, shopping, and entertainment\n    - Features multiple restaurants, a casino, and a world-class spa\n    - Located on a pristine stretch of Palm Beach\n    \n    2. Bucuti & Tara Beach Resort - Located in Eagle Beach\n    - An adults-only boutique resort on Eagle Beach\n    - Known for being more intimate and peaceful\n    - Award-winning for its sustainability practices\n    - Perfect for a romantic getaway or peaceful vacation\n    - Located on one of the most beautiful beaches in the Caribbean\n    \n    Would you like more specific information about either of these properties or their locations?\n    \n    --- Conversation Turn 3 ---\n    \n    User: Command(resume='i like the first one. could you recommend something to do near the hotel?')\n    \n    travel_advisor: Near the Ritz-Carlton in Palm Beach, here are some highly recommended activities:\n    \n    1. Visit the Palm Beach Plaza Mall - Just a short walk from the hotel, featuring shopping, dining, and entertainment\n    2. Try your luck at the Stellaris Casino - It's right in the Ritz-Carlton\n    3. Take a sunset sailing cruise - Many depart from the nearby pier\n    4. Visit the California Lighthouse - A scenic landmark just north of Palm Beach\n    5. Enjoy water sports at Palm Beach:\n       - Jet skiing\n       - Parasailing\n       - Snorkeling\n       - Stand-up paddleboarding\n    \n    Would you like more specific information about any of these activities or would you like to know about other options in the area?\n    ```\n\n## Prebuilt implementations\n\nLangGraph comes with prebuilt implementations of two of the most popular multi-agent architectures:\n\n- [supervisor](../agents/multi-agent.md#supervisor) — individual agents are coordinated by a central supervisor agent. The supervisor controls all communication flow and task delegation, making decisions about which agent to invoke based on the current context and task requirements. You can use [`langgraph-supervisor`](https://github.com/langchain-ai/langgraph-supervisor-py) library to create a supervisor multi-agent systems.\n- [swarm](../agents/multi-agent.md#supervisor) — agents dynamically hand off control to one another based on their specializations. The system remembers which agent was last active, ensuring that on subsequent interactions, the conversation resumes with that agent. You can use [`langgraph-swarm`](https://github.com/langchain-ai/langgraph-swarm-py) library to create a swarm multi-agent systems.\n\n---\nhow-tos/run-id-langsmith.md\n---\n\n# How to pass custom run ID or set tags and metadata for graph runs in LangSmith\n\n!!! tip \"Prerequisites\"\n    This guide assumes familiarity with the following:\n    \n    - [LangSmith Documentation](https://docs.smith.langchain.com)\n    - [LangSmith Platform](https://smith.langchain.com)\n    - [RunnableConfig](https://api.python.langchain.com/en/latest/runnables/langchain_core.runnables.config.RunnableConfig.html#langchain_core.runnables.config.RunnableConfig)\n    - [Add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n    - [Customize run name](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#customize-run-name)\n\nDebugging graph runs can sometimes be difficult to do in an IDE or terminal. [LangSmith](https://docs.smith.langchain.com) lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read the [LangSmith documentation](https://docs.smith.langchain.com) for more information on how to get started.\n\nTo make it easier to identify and analyzed traces generated during graph invocation, you can set additional configuration at run time (see [RunnableConfig](https://api.python.langchain.com/en/latest/runnables/langchain_core.runnables.config.RunnableConfig.html#langchain_core.runnables.config.RunnableConfig)):\n\n| **Field**   | **Type**            | **Description**                                                                                                    |\n|-------------|---------------------|--------------------------------------------------------------------------------------------------------------------|\n| run_name    | `str`               | Name for the tracer run for this call. Defaults to the name of the class.                                          |\n| run_id      | `UUID`              | Unique identifier for the tracer run for this call. If not provided, a new UUID will be generated.                 |\n| tags        | `List[str]`         | Tags for this call and any sub-calls (e.g., a Chain calling an LLM). You can use these to filter calls.            |\n| metadata    | `Dict[str, Any]`    | Metadata for this call and any sub-calls (e.g., a Chain calling an LLM). Keys should be strings, values should be JSON-serializable. |\n\nLangGraph graphs implement the [LangChain Runnable Interface](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html) and accept a second argument (`RunnableConfig`) in methods like `invoke`, `ainvoke`, `stream` etc.\n\nThe LangSmith platform will allow you to search and filter traces based on `run_name`, `run_id`, `tags` and `metadata`.\n\n## TLDR\n\n```python\nimport uuid\n# Generate a random UUID -- it must be a UUID\nconfig = {\"run_id\": uuid.uuid4()}, \"tags\": [\"my_tag1\"], \"metadata\": {\"a\": 5}}\n# Works with all standard Runnable methods \n# like invoke, batch, ainvoke, astream_events etc\ngraph.stream(inputs, config, stream_mode=\"values\")\n```\n\nThe rest of the how to guide will show a full agent.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys\n\n```python\n%%capture --no-stderr\n%pip install --quiet -U langgraph langchain_openai\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n_set_env(\"LANGSMITH_API_KEY\")\n```\n\n!!! tip\n    Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. [LangSmith](https://docs.smith.langchain.com) lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started [here](https://docs.smith.langchain.com).\n\n## Define the graph\n\nFor this example we will use the [prebuilt ReAct agent](https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/).\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom typing import Literal\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_core.tools import tool\n\n# First we initialize the model we want to use.\nmodel = ChatOpenAI(model=\"gpt-4o\", temperature=0)\n\n# For this tutorial we will use custom tool that returns pre-defined values for weather in two cities (NYC & SF)\n@tool\ndef get_weather(city: Literal[\"nyc\", \"sf\"]):\n    \"\"\"Use this to get weather information.\"\"\"\n    if city == \"nyc\":\n        return \"It might be cloudy in nyc\"\n    elif city == \"sf\":\n        return \"It's always sunny in sf\"\n    else:\n        raise AssertionError(\"Unknown city\")\n\ntools = [get_weather]\n\n# Define the graph\ngraph = create_react_agent(model, tools=tools)\n```\n\n## Run your graph\n\nNow that we've defined our graph let's run it once and view the trace in LangSmith. In order for our trace to be easily accessible in LangSmith, we will pass in a custom `run_id` in the config.\n\nThis assumes that you have set your `LANGSMITH_API_KEY` environment variable.\n\nNote that you can also configure what project to trace to by setting the `LANGCHAIN_PROJECT` environment variable, by default runs will be traced to the `default` project.\n\n```python\nimport uuid\n\ndef print_stream(stream):\n    for s in stream:\n        message = s[\"messages\"][-1]\n        if isinstance(message, tuple):\n            print(message)\n        else:\n            message.pretty_print()\n\ninputs = {\"messages\": [(\"user\", \"what is the weather in sf\")]}\n\nconfig = {\"run_name\": \"agent_007\", \"tags\": [\"cats are awesome\"]}\n\nprint_stream(graph.stream(inputs, config, stream_mode=\"values\"))\n```\n\n**Output:**\n```\n================================ Human Message ==================================\n\nwhat is the weather in sf\n================================== Ai Message ===================================\nTool Calls:\n  get_weather (call_9ZudXyMAdlUjptq9oMGtQo8o)\n Call ID: call_9ZudXyMAdlUjptq9oMGtQo8o\n  Args:\n    city: sf\n================================= Tool Message ==================================\nName: get_weather\n\nIt's always sunny in sf\n================================== Ai Message ===================================\n\nThe weather in San Francisco is currently sunny.\n```\n\n## View the trace in LangSmith\n\nNow that we've ran our graph, let's head over to LangSmith and view our trace. First click into the project that you traced to (in our case the default project). You should see a run with the custom run name \"agent_007\".\n\n![LangSmith Trace View](assets/d38d1f2b-0f4c-4707-b531-a3c749de987f.png)\n\nIn addition, you will be able to filter traces after the fact using the tags or metadata provided. For example,\n\n![LangSmith Filter View](assets/410e0089-2ab8-46bb-a61a-827187fd46b3.png)\n\n---\nhow-tos/tool-calling.md\n---\n\n# Call tools\n\n[Tools](../concepts/tools.md) encapsulate a callable function and its input schema. These can be passed to compatible chat models, allowing the model to decide whether to invoke a tool and determine the appropriate arguments.\n\nYou can [define your own tools](#define-a-tool) or use [prebuilt tools](#prebuilt-tools)\n\n## Define a tool", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "Define a basic tool with the [@tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) decorator:\n\n```python hl_lines=\"3\"\nfrom langchain_core.tools import tool\n\n@tool\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n```\n\n## Run a tool\n\nTools conform to the [Runnable interface](https://python.langchain.com/docs/concepts/runnables/), which means you can run a tool using the `invoke` method:\n\n```python\nmultiply.invoke({\"a\": 6, \"b\": 7})  # returns 42\n```\n\nIf the tool is invoked with `type=\"tool_call\"`, it will return a [ToolMessage](https://python.langchain.com/docs/concepts/messages/#toolmessage):\n\n```python\ntool_call = {\n    \"type\": \"tool_call\",\n    \"id\": \"1\",\n    \"args\": {\"a\": 42, \"b\": 7}\n}\nmultiply.invoke(tool_call) # returns a ToolMessage object\n```\n\nOutput:\n\n```pycon\nToolMessage(content='294', name='multiply', tool_call_id='1')\n```\n\n## Use in an agent\n\nTo create a tool-calling agent, you can use the prebuilt [create_react_agent](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.chat_agent_executor.create_react_agent):\n\n```python hl_lines=\"2 9\"\nfrom langchain_core.tools import tool\nfrom langgraph.prebuilt import create_react_agent\n\n@tool\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\nagent = create_react_agent(\n    model=\"anthropic:claude-3-7-sonnet\",\n    tools=[multiply]\n)\nagent.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"what's 42 x 7?\"}]})\n```\n\n### Dynamically select tools\n\nConfigure tool availability at runtime based on context:\n\n```python hl_lines=\"30 42 44 56\"\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nfrom langchain.chat_models import init_chat_model\nfrom langchain_core.tools import tool\n\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.prebuilt.chat_agent_executor import AgentState\nfrom langgraph.runtime import Runtime\n\n@dataclass\nclass CustomContext:\n    tools: list[Literal[\"weather\", \"compass\"]]\n\n@tool\ndef weather() -> str:\n    \"\"\"Returns the current weather conditions.\"\"\"\n    return \"It's nice and sunny.\"\n\n@tool\ndef compass() -> str:\n    \"\"\"Returns the direction the user is facing.\"\"\"\n    return \"North\"\n\nmodel = init_chat_model(\"anthropic:claude-sonnet-4-20250514\")\n\ndef configure_model(state: AgentState, runtime: Runtime[CustomContext]):\n    \"\"\"Configure the model with tools based on runtime context.\"\"\"\n    selected_tools = [\n        tool\n        for tool in [weather, compass]\n        if tool.name in runtime.context.tools\n    ]\n    return model.bind_tools(selected_tools)\n\nagent = create_react_agent(\n    # Dynamically configure the model with tools based on runtime context\n    configure_model,\n    # Initialize with all tools available\n    tools=[weather, compass]\n)\n\noutput = agent.invoke(\n    {\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": \"Who are you and what tools do you have access to?\",\n            }\n        ]\n    },\n    context=CustomContext(tools=[\"weather\"]),  # Only enable the weather tool\n)\n\nprint(output[\"messages\"][-1].text())\n```\n\n!!! version-added \"Added in version 0.6.0\"\n\n## Use in a workflow\n\nIf you are writing a custom workflow, you will need to:\n\n1. register the tools with the chat model\n2. call the tool if the model decides to use it\n\nUse `model.bind_tools()` to register the tools with the model.\n\n```python hl_lines=\"5\"\nfrom langchain.chat_models import init_chat_model\n\nmodel = init_chat_model(model=\"claude-3-5-haiku-latest\")\n\nmodel_with_tools = model.bind_tools([multiply])\n```\n\nLLMs automatically determine if a tool invocation is necessary and handle calling the tool with the appropriate arguments.\n\n??? example \"Extended example: attach tools to a chat model\"\n\n```python hl_lines=\"10\"\n    from langchain_core.tools import tool\n    from langchain.chat_models import init_chat_model\n\n@tool\n    def multiply(a: int, b: int) -> int:\n        \"\"\"Multiply two numbers.\"\"\"\n        return a * b\n\nmodel = init_chat_model(model=\"claude-3-5-haiku-latest\")\n    model_with_tools = model.bind_tools([multiply])\n\nresponse_message = model_with_tools.invoke(\"what's 42 x 7?\")\n    tool_call = response_message.tool_calls[0]\n\nmultiply.invoke(tool_call)\n    ```\n\n```pycon\n    ToolMessage(\n        content='294',\n        name='multiply',\n        tool_call_id='toolu_0176DV4YKSD8FndkeuuLj36c'\n    )\n    ```\n\n#### ToolNode\n\nTo execute tools in custom workflows, use the prebuilt [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode) or implement your own custom node.\n\n`ToolNode` is a specialized node for executing tools in a workflow. It provides the following features:\n\n- Supports both synchronous and asynchronous tools.\n- Executes multiple tools concurrently.\n- Handles errors during tool execution (`handle_tool_errors=True`, enabled by default). See [handling tool errors](#handle-errors) for more details.\n\n`ToolNode` operates on [`MessagesState`](../concepts/low_level.md#messagesstate):\n\n- **Input**: `MessagesState`, where the last message is an `AIMessage` containing the `tool_calls` parameter.\n- **Output**: `MessagesState` updated with the resulting [`ToolMessage`](https://python.langchain.com/docs/concepts/messages/#toolmessage) from executed tools.\n\n```python hl_lines=\"1 14\"\nfrom langgraph.prebuilt import ToolNode\n\ndef get_weather(location: str):\n    \"\"\"Call to get the current weather.\"\"\"\n    if location.lower() in [\"sf\", \"san francisco\"]:\n        return \"It's 60 degrees and foggy.\"\n    else:\n        return \"It's 90 degrees and sunny.\"\n\ndef get_coolest_cities():\n    \"\"\"Get a list of coolest cities\"\"\"\n    return \"nyc, sf\"\n\ntool_node = ToolNode([get_weather, get_coolest_cities])\ntool_node.invoke({\"messages\": [...]})\n```\n\n??? example \"Single tool call\"\n\n```python hl_lines=\"13\"\n    from langchain_core.messages import AIMessage\n    from langgraph.prebuilt import ToolNode\n\n# Define tools\n    @tool\n    def get_weather(location: str):\n        \"\"\"Call to get the current weather.\"\"\"\n        if location.lower() in [\"sf\", \"san francisco\"]:\n            return \"It's 60 degrees and foggy.\"\n        else:\n            return \"It's 90 degrees and sunny.\"\n\ntool_node = ToolNode([get_weather])\n\nmessage_with_single_tool_call = AIMessage(\n        content=\"\",\n        tool_calls=[\n            {\n                \"name\": \"get_weather\",\n                \"args\": {\"location\": \"sf\"},\n                \"id\": \"tool_call_id\",\n                \"type\": \"tool_call\",\n            }\n        ],\n    )\n\ntool_node.invoke({\"messages\": [message_with_single_tool_call]})\n    ```\n\n```\n    {'messages': [ToolMessage(content=\"It's 60 degrees and foggy.\", name='get_weather', tool_call_id='tool_call_id')]}\n    ```\n\n??? example \"Multiple tool calls\"\n\n```python hl_lines=\"17 37\"\n    from langchain_core.messages import AIMessage\n    from langgraph.prebuilt import ToolNode\n\n# Define tools\n\ndef get_weather(location: str):\n        \"\"\"Call to get the current weather.\"\"\"\n        if location.lower() in [\"sf\", \"san francisco\"]:\n            return \"It's 60 degrees and foggy.\"\n        else:\n            return \"It's 90 degrees and sunny.\"\n\ndef get_coolest_cities():\n        \"\"\"Get a list of coolest cities\"\"\"\n        return \"nyc, sf\"\n\ntool_node = ToolNode([get_weather, get_coolest_cities])\n\nmessage_with_multiple_tool_calls = AIMessage(\n        content=\"\",\n        tool_calls=[\n            {\n                \"name\": \"get_coolest_cities\",\n                \"args\": {},\n                \"id\": \"tool_call_id_1\",\n                \"type\": \"tool_call\",\n            },\n            {\n                \"name\": \"get_weather\",\n                \"args\": {\"location\": \"sf\"},\n                \"id\": \"tool_call_id_2\",\n                \"type\": \"tool_call\",\n            },\n        ],\n    )\n\ntool_node.invoke({\"messages\": [message_with_multiple_tool_calls]})  # (1)!\n    ```\n\n1. `ToolNode` will execute both tools in parallel\n\n```\n    {\n        'messages': [\n            ToolMessage(content='nyc, sf', name='get_coolest_cities', tool_call_id='tool_call_id_1'),\n            ToolMessage(content=\"It's 60 degrees and foggy.\", name='get_weather', tool_call_id='tool_call_id_2')\n        ]\n    }\n    ```\n\n??? example \"Use with a chat model\"\n\n```python hl_lines=\"11 14 17\"\n    from langchain.chat_models import init_chat_model\n    from langgraph.prebuilt import ToolNode\n\ndef get_weather(location: str):\n        \"\"\"Call to get the current weather.\"\"\"\n        if location.lower() in [\"sf\", \"san francisco\"]:\n            return \"It's 60 degrees and foggy.\"\n        else:\n            return \"It's 90 degrees and sunny.\"\n\ntool_node = ToolNode([get_weather])\n\nmodel = init_chat_model(model=\"claude-3-5-haiku-latest\")\n    model_with_tools = model.bind_tools([get_weather])  # (1)!\n\nresponse_message = model_with_tools.invoke(\"what's the weather in sf?\")\n    tool_node.invoke({\"messages\": [response_message]})\n    ```\n\n1. Use `.bind_tools()` to attach the tool schema to the chat model\n\n```\n    {'messages': [ToolMessage(content=\"It's 60 degrees and foggy.\", name='get_weather', tool_call_id='toolu_01Pnkgw5JeTRxXAU7tyHT4UW')]}\n    ```\n\n??? example \"Use in a tool-calling agent\"\n\nThis is an example of creating a tool-calling agent from scratch using `ToolNode`. You can also use LangGraph's prebuilt [agent](../agents/agents.md).\n\n```python hl_lines=\"12 15 33\"\n    from langchain.chat_models import init_chat_model\n    from langgraph.prebuilt import ToolNode\n    from langgraph.graph import StateGraph, MessagesState, START, END\n\ndef get_weather(location: str):\n        \"\"\"Call to get the current weather.\"\"\"\n        if location.lower() in [\"sf\", \"san francisco\"]:\n            return \"It's 60 degrees and foggy.\"\n        else:\n            return \"It's 90 degrees and sunny.\"\n\ntool_node = ToolNode([get_weather])\n\nmodel = init_chat_model(model=\"claude-3-5-haiku-latest\")\n    model_with_tools = model.bind_tools([get_weather])\n\ndef should_continue(state: MessagesState):\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n        if last_message.tool_calls:\n            return \"tools\"\n        return END\n\ndef call_model(state: MessagesState):\n        messages = state[\"messages\"]\n        response = model_with_tools.invoke(messages)\n        return {\"messages\": [response]}\n\nbuilder = StateGraph(MessagesState)\n\n# Define the two nodes we will cycle between\n    builder.add_node(\"call_model\", call_model)\n    builder.add_node(\"tools\", tool_node)\n\nbuilder.add_edge(START, \"call_model\")\n    builder.add_conditional_edges(\"call_model\", should_continue, [\"tools\", END])\n    builder.add_edge(\"tools\", \"call_model\")\n\ngraph = builder.compile()\n\ngraph.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf?\"}]})\n    ```\n\n```\n    {\n        'messages': [\n            HumanMessage(content=\"what's the weather in sf?\"),\n            AIMessage(\n                content=[{'text': \"I'll help you check the weather in San Francisco right now.\", 'type': 'text'}, {'id': 'toolu_01A4vwUEgBKxfFVc5H3v1CNs', 'input': {'location': 'San Francisco'}, 'name': 'get_weather', 'type': 'tool_use'}],\n                tool_calls=[{'name': 'get_weather', 'args': {'location': 'San Francisco'}, 'id': 'toolu_01A4vwUEgBKxfFVc5H3v1CNs', 'type': 'tool_call'}]\n            ),\n            ToolMessage(content=\"It's 60 degrees and foggy.\"),\n            AIMessage(content=\"The current weather in San Francisco is 60 degrees and foggy. Typical San Francisco weather with its famous marine layer!\")\n        ]\n    }\n    ```\n\n## Tool customization\n\nFor more control over tool behavior, use the `@tool` decorator.\n\n### Parameter descriptions\n\nAuto-generate descriptions from docstrings:\n\n```python hl_lines=\"1 3\"\nfrom langchain_core.tools import tool\n\n@tool(\"multiply_tool\", parse_docstring=True)\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two numbers.\n\nArgs:\n        a: First operand\n        b: Second operand\n    \"\"\"\n    return a * b\n```\n\n### Explicit input schema\n\nDefine schemas using `args_schema`:\n\n```python hl_lines=\"9\"\nfrom pydantic import BaseModel, Field\nfrom langchain_core.tools import tool\n\nclass MultiplyInputSchema(BaseModel):\n    \"\"\"Multiply two numbers\"\"\"\n    a: int = Field(description=\"First operand\")\n    b: int = Field(description=\"Second operand\")\n\n@tool(\"multiply_tool\", args_schema=MultiplyInputSchema)\ndef multiply(a: int, b: int) -> int:\n    return a * b\n```\n\n### Tool name\n\nOverride the default tool name using the first argument or name property:\n\n```python hl_lines=\"3\"\nfrom langchain_core.tools import tool\n\n@tool(\"multiply_tool\")\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n```\n\n## Context management\n\nTools within LangGraph sometimes require context data, such as runtime-only arguments (e.g., user IDs or session details), that should not be controlled by the model. LangGraph provides three methods for managing such context:\n\n| Type                                    | Usage Scenario                           | Mutable | Lifetime                 |\n| --------------------------------------- | ---------------------------------------- | ------- | ------------------------ |\n| [Configuration](#configuration)         | Static, immutable runtime data           | ❌      | Single invocation        |\n| [Short-term memory](#short-term-memory) | Dynamic, changing data during invocation | ✅      | Single invocation        |\n| [Long-term memory](#long-term-memory)   | Persistent, cross-session data           | ✅      | Across multiple sessions |\n\n### Configuration\n\nUse configuration when you have **immutable** runtime data that tools require, such as user identifiers. You pass these arguments via [`RunnableConfig`](https://python.langchain.com/docs/concepts/runnables/#runnableconfig) at invocation and access them in the tool:\n\n```python hl_lines=\"5 13\"\nfrom langchain_core.tools import tool\nfrom langchain_core.runnables import RunnableConfig\n\n@tool\ndef get_user_info(config: RunnableConfig) -> str:\n    \"\"\"Retrieve user information based on user ID.\"\"\"\n    user_id = config[\"configurable\"].get(\"user_id\")\n    return \"User is John Smith\" if user_id == \"user_123\" else \"Unknown user\"\n\n# Invocation example with an agent\nagent.invoke(\n    {\"messages\": [{\"role\": \"user\", \"content\": \"look up user info\"}]},\n    config={\"configurable\": {\"user_id\": \"user_123\"}}\n)\n```\n\n??? example \"Extended example: Access config in tools\"\n\n```python hl_lines=\"6 9 19\"\n    from langchain_core.runnables import RunnableConfig\n    from langchain_core.tools import tool\n    from langgraph.prebuilt import create_react_agent\n\ndef get_user_info(\n        config: RunnableConfig,\n    ) -> str:\n        \"\"\"Look up user info.\"\"\"\n        user_id = config[\"configurable\"].get(\"user_id\")\n        return \"User is John Smith\" if user_id == \"user_123\" else \"Unknown user\"\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_user_info],\n    )\n\nagent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"look up user information\"}]},\n        config={\"configurable\": {\"user_id\": \"user_123\"}}\n    )\n    ```\n\n### Short-term memory\n\nShort-term memory maintains **dynamic** state that changes during a single execution.\n\nTo **access** (read) the graph state inside the tools, you can use a special parameter **annotation** — [`InjectedState`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.InjectedState):\n\n```python hl_lines=\"12\"\nfrom typing import Annotated, NotRequired\nfrom langchain_core.tools import tool\nfrom langgraph.prebuilt import InjectedState, create_react_agent\nfrom langgraph.prebuilt.chat_agent_executor import AgentState\n\nclass CustomState(AgentState):\n    # The user_name field in short-term state\n    user_name: NotRequired[str]\n\n@tool\ndef get_user_name(\n    state: Annotated[CustomState, InjectedState]\n) -> str:\n    \"\"\"Retrieve the current user-name from state.\"\"\"\n    # Return stored name or a default if not set\n    return state.get(\"user_name\", \"Unknown user\")\n\n# Example agent setup\nagent = create_react_agent(\n    model=\"anthropic:claude-3-7-sonnet-latest\",\n    tools=[get_user_name],\n    state_schema=CustomState,\n)\n\n# Invocation: reads the name from state (initially empty)\nagent.invoke({\"messages\": \"what's my name?\"})\n```\n\nUse a tool that returns a `Command` to **update** `user_name` and append a confirmation message:\n\n```python hl_lines=\"12 13 14 15 16 17\"\nfrom typing import Annotated\nfrom langgraph.types import Command\nfrom langchain_core.messages import ToolMessage\nfrom langchain_core.tools import tool, InjectedToolCallId\n\n@tool\ndef update_user_name(\n    new_name: str,\n    tool_call_id: Annotated[str, InjectedToolCallId]\n) -> Command:\n    \"\"\"Update user-name in short-term memory.\"\"\"\n    return Command(update={\n        \"user_name\": new_name,\n        \"messages\": [\n            ToolMessage(f\"Updated user name to {new_name}\", tool_call_id=tool_call_id)\n        ]\n    })\n```\n\n!!! important\n\nIf you want to use tools that return `Command` and update graph state, you can either use prebuilt [`create_react_agent`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.chat_agent_executor.create_react_agent) / [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode) components, or implement your own tool-executing node that collects `Command` objects returned by the tools and returns a list of them, e.g.:\n\n```python\n    def call_tools(state):\n        ...\n        commands = [tools_by_name[tool_call[\"name\"]].invoke(tool_call) for tool_call in tool_calls]\n        return commands\n    ```\n\n### Long-term memory\n\nUse [long-term memory](../concepts/memory.md#long-term-memory) to store user-specific or application-specific data across conversations. This is useful for applications like chatbots, where you want to remember user preferences or other information.\n\nTo use long-term memory, you need to:\n\n1. [Configure a store](memory/add-memory.md#add-long-term-memory) to persist data across invocations.\n2. Access the store from within tools.\n\nTo **access** information in the store:\n\n```python hl_lines=\"4 11 13\"\nfrom langchain_core.runnables import RunnableConfig\nfrom langchain_core.tools import tool\nfrom langgraph.graph import StateGraph\nfrom langgraph.config import get_store\n\n@tool\ndef get_user_info(config: RunnableConfig) -> str:\n    \"\"\"Look up user info.\"\"\"\n    # Same as that provided to `builder.compile(store=store)`\n    # or `create_react_agent`\n    store = get_store()\n    user_id = config[\"configurable\"].get(\"user_id\")\n    user_info = store.get((\"users\",), user_id)\n    return str(user_info.value) if user_info else \"Unknown user\"\n\nbuilder = StateGraph(...)\n...\ngraph = builder.compile(store=store)\n```\n\n??? example \"Access long-term memory\"\n\n```python hl_lines=\"7 9 22 24 30 36\"\n    from langchain_core.runnables import RunnableConfig\n    from langchain_core.tools import tool\n    from langgraph.config import get_store\n    from langgraph.prebuilt import create_react_agent\n    from langgraph.store.memory import InMemoryStore\n\nstore = InMemoryStore() # (1)!\n\nstore.put(  # (2)!\n        (\"users\",),  # (3)!\n        \"user_123\",  # (4)!\n        {\n            \"name\": \"John Smith\",\n            \"language\": \"English\",\n        } # (5)!\n    )\n\n@tool\n    def get_user_info(config: RunnableConfig) -> str:\n        \"\"\"Look up user info.\"\"\"\n        # Same as that provided to `create_react_agent`\n        store = get_store() # (6)!\n        user_id = config[\"configurable\"].get(\"user_id\")\n        user_info = store.get((\"users\",), user_id) # (7)!\n        return str(user_info.value) if user_info else \"Unknown user\"\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[get_user_info],\n        store=store # (8)!\n    )\n\n# Run the agent\n    agent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"look up user information\"}]},\n        config={\"configurable\": {\"user_id\": \"user_123\"}}\n    )\n    ```\n\n1. The `InMemoryStore` is a store that stores data in memory. In a production setting, you would typically use a database or other persistent storage. Please review the [store documentation][../reference/store.md) for more options. If you're deploying with **LangGraph Platform**, the platform will provide a production-ready store for you.\n    2. For this example, we write some sample data to the store using the `put` method. Please see the [BaseStore.put](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore.put) API reference for more details.\n    3. The first argument is the namespace. This is used to group related data together. In this case, we are using the `users` namespace to group user data.\n    4. A key within the namespace. This example uses a user ID for the key.\n    5. The data that we want to store for the given user.\n    6. The `get_store` function is used to access the store. You can call it from anywhere in your code, including tools and prompts. This function returns the store that was passed to the agent when it was created.\n    7. The `get` method is used to retrieve data from the store. The first argument is the namespace, and the second argument is the key. This will return a `StoreValue` object, which contains the value and metadata about the value.\n    8. The `store` is passed to the agent. This enables the agent to access the store when running tools. You can also use the `get_store` function to access the store from anywhere in your code.\n\nTo **update** information in the store:\n\n```python hl_lines=\"4 11 13\"\nfrom langchain_core.runnables import RunnableConfig\nfrom langchain_core.tools import tool\nfrom langgraph.graph import StateGraph\nfrom langgraph.config import get_store\n\n@tool\ndef save_user_info(user_info: str, config: RunnableConfig) -> str:\n    \"\"\"Save user info.\"\"\"\n    # Same as that provided to `builder.compile(store=store)`\n    # or `create_react_agent`\n    store = get_store()\n    user_id = config[\"configurable\"].get(\"user_id\")\n    store.put((\"users\",), user_id, user_info)\n    return \"Successfully saved user info.\"\n\nbuilder = StateGraph(...)\n...\ngraph = builder.compile(store=store)\n```\n\n??? example \"Update long-term memory\"\n\n```python hl_lines=\"18 20 26 32\"\n    from typing_extensions import TypedDict\n\nfrom langchain_core.tools import tool\n    from langgraph.config import get_store\n    from langchain_core.runnables import RunnableConfig\n    from langgraph.prebuilt import create_react_agent\n    from langgraph.store.memory import InMemoryStore\n\nstore = InMemoryStore() # (1)!\n\nclass UserInfo(TypedDict): # (2)!\n        name: str\n\n@tool\n    def save_user_info(user_info: UserInfo, config: RunnableConfig) -> str: # (3)!\n        \"\"\"Save user info.\"\"\"\n        # Same as that provided to `create_react_agent`\n        store = get_store() # (4)!\n        user_id = config[\"configurable\"].get(\"user_id\")\n        store.put((\"users\",), user_id, user_info) # (5)!\n        return \"Successfully saved user info.\"\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[save_user_info],\n        store=store\n    )\n\n# Run the agent\n    agent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"My name is John Smith\"}]},\n        config={\"configurable\": {\"user_id\": \"user_123\"}} # (6)!\n    )\n\n# You can access the store directly to get the value\n    store.get((\"users\",), \"user_123\").value\n    ```\n\n1. The `InMemoryStore` is a store that stores data in memory. In a production setting, you would typically use a database or other persistent storage. Please review the [store documentation](../reference/store.md) for more options. If you're deploying with **LangGraph Platform**, the platform will provide a production-ready store for you.\n    2. The `UserInfo` class is a `TypedDict` that defines the structure of the user information. The LLM will use this to format the response according to the schema.\n    3. The `save_user_info` function is a tool that allows an agent to update user information. This could be useful for a chat application where the user wants to update their profile information.\n    4. The `get_store` function is used to access the store. You can call it from anywhere in your code, including tools and prompts. This function returns the store that was passed to the agent when it was created.\n    5. The `put` method is used to store data in the store. The first argument is the namespace, and the second argument is the key. This will store the user information in the store.\n    6. The `user_id` is passed in the config. This is used to identify the user whose information is being updated.\n\n## Advanced tool features\n\n### Immediate return\n\nUse `return_direct=True` to immediately return a tool's result without executing additional logic.\n\nThis is useful for tools that should not trigger further processing or tool calls, allowing you to return results directly to the user.\n\n```python hl_lines=\"1\"\n@tool(return_direct=True)\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n```\n\n??? example \"Extended example: Using return_direct in a prebuilt agent\"\n\n```python hl_lines=\"4\"\n    from langchain_core.tools import tool\n    from langgraph.prebuilt import create_react_agent\n\n@tool(return_direct=True)\n    def add(a: int, b: int) -> int:\n        \"\"\"Add two numbers\"\"\"\n        return a + b\n\nagent = create_react_agent(\n        model=\"anthropic:claude-3-7-sonnet-latest\",\n        tools=[add]\n    )\n\nagent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what's 3 + 5?\"}]}\n    )\n    ```\n\n!!! important \"Using without prebuilt components\"\n\nIf you are building a custom workflow and are not relying on `create_react_agent` or `ToolNode`, you will also\n    need to implement the control flow to handle `return_direct=True`.\n\n### Force tool use\n\nIf you need to force a specific tool to be used, you will need to configure this at the **model** level using the `tool_choice` parameter in the bind_tools method.\n\nForce specific tool usage via tool_choice:\n\n```python hl_lines=\"11\"\n@tool(return_direct=True)\ndef greet(user_name: str) -> int:\n    \"\"\"Greet user.\"\"\"\n    return f\"Hello {user_name}!\"\n\ntools = [greet]\n\nconfigured_model = model.bind_tools(\n    tools,\n    # Force the use of the 'greet' tool\n    tool_choice={\"type\": \"tool\", \"name\": \"greet\"}\n)\n```\n\n??? example \"Extended example: Force tool usage in an agent\"\n\nTo force the agent to use specific tools, you can set the `tool_choice` option in `model.bind_tools()`:\n\n```python hl_lines=\"3 11\"\n    from langchain_core.tools import tool\n\n@tool(return_direct=True)\n    def greet(user_name: str) -> int:\n        \"\"\"Greet user.\"\"\"\n        return f\"Hello {user_name}!\"\n\ntools = [greet]\n\nagent = create_react_agent(\n        model=model.bind_tools(tools, tool_choice={\"type\": \"tool\", \"name\": \"greet\"}),\n        tools=tools\n    )\n\nagent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"Hi, I am Bob\"}]}\n    )\n    ```\n\n!!! Warning \"Avoid infinite loops\"\n\nForcing tool usage without stopping conditions can create infinite loops. Use one of the following safeguards:\n\n- Mark the tool with [`return_direct=True`](#immediate-return) to end the loop after execution.\n    - Set [`recursion_limit`](../concepts/low_level.md#recursion-limit) to restrict the number of execution steps.\n\n!!! tip \"Tool choice configuration\"\n\nThe `tool_choice` parameter is used to configure which tool should be used by the model when it decides to call a tool. This is useful when you want to ensure that a specific tool is always called for a particular task or when you want to override the model's default behavior of choosing a tool based on its internal logic.\n\nNote that not all models support this feature, and the exact configuration may vary depending on the model you are using.\n\n### Disable parallel calls", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "For supported providers, you can disable parallel tool calling by setting `parallel_tool_calls=False` via the `model.bind_tools()` method:\n\n```python hl_lines=\"3\"\nmodel.bind_tools(\n    tools,\n    parallel_tool_calls=False\n)\n```\n\n??? example \"Extended example: disable parallel tool calls in a prebuilt agent\"\n\n```python hl_lines=\"15\"\n    from langchain.chat_models import init_chat_model\n\ndef add(a: int, b: int) -> int:\n        \"\"\"Add two numbers\"\"\"\n        return a + b\n\ndef multiply(a: int, b: int) -> int:\n        \"\"\"Multiply two numbers.\"\"\"\n        return a * b\n\nmodel = init_chat_model(\"anthropic:claude-3-5-sonnet-latest\", temperature=0)\n    tools = [add, multiply]\n    agent = create_react_agent(\n        # disable parallel tool calls\n        model=model.bind_tools(tools, parallel_tool_calls=False),\n        tools=tools\n    )\n\nagent.invoke(\n        {\"messages\": [{\"role\": \"user\", \"content\": \"what's 3 + 5 and 4 * 7?\"}]}\n    )\n    ```\n\n### Handle errors\n\nLangGraph provides built-in error handling for tool execution through the prebuilt [ToolNode](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode) component, used both independently and in prebuilt agents.\n\nBy **default**, `ToolNode` catches exceptions raised during tool execution and returns them as `ToolMessage` objects with a status indicating an error.\n\n```python\nfrom langchain_core.messages import AIMessage\nfrom langgraph.prebuilt import ToolNode\n\ndef multiply(a: int, b: int) -> int:\n    if a == 42:\n        raise ValueError(\"The ultimate error\")\n    return a * b\n\n# Default error handling (enabled by default)\ntool_node = ToolNode([multiply])\n\nmessage = AIMessage(\n    content=\"\",\n    tool_calls=[{\n        \"name\": \"multiply\",\n        \"args\": {\"a\": 42, \"b\": 7},\n        \"id\": \"tool_call_id\",\n        \"type\": \"tool_call\"\n    }]\n)\n\nresult = tool_node.invoke({\"messages\": [message]})\n```\n\nOutput:\n\n```pycon\n{'messages': [\n    ToolMessage(\n        content=\"Error: ValueError('The ultimate error')\\n Please fix your mistakes.\",\n        name='multiply',\n        tool_call_id='tool_call_id',\n        status='error'\n    )\n]}\n```\n\n#### Disable error handling\n\nTo propagate exceptions directly, disable error handling:\n\n```python\ntool_node = ToolNode([multiply], handle_tool_errors=False)\n```\n\nWith error handling disabled, exceptions raised by tools will propagate up, requiring explicit management.\n\n#### Custom error messages\n\nProvide a custom error message by setting the error handling parameter to a string:\n\n```python\ntool_node = ToolNode(\n    [multiply],\n    handle_tool_errors=\"Can't use 42 as the first operand, please switch operands!\"\n)\n```\n\nExample output:\n\n```python\n{'messages': [\n    ToolMessage(\n        content=\"Can't use 42 as the first operand, please switch operands!\",\n        name='multiply',\n        tool_call_id='tool_call_id',\n        status='error'\n    )\n]}\n```\n\n#### Error handling in agents\n\nError handling in prebuilt agents (`create_react_agent`) leverages `ToolNode`:\n\n```python\nfrom langgraph.prebuilt import create_react_agent\n\nagent = create_react_agent(\n    model=\"anthropic:claude-3-7-sonnet-latest\",\n    tools=[multiply]\n)\n\n# Default error handling\nagent.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"what's 42 x 7?\"}]})\n```\n\nTo disable or customize error handling in prebuilt agents, explicitly pass a configured `ToolNode`:\n\n```python\ncustom_tool_node = ToolNode(\n    [multiply],\n    handle_tool_errors=\"Cannot use 42 as a first operand!\"\n)\n\nagent_custom = create_react_agent(\n    model=\"anthropic:claude-3-7-sonnet-latest\",\n    tools=custom_tool_node\n)\n\nagent_custom.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"what's 42 x 7?\"}]})\n```\n\n### Handle large numbers of tools\n\nAs the number of available tools grows, you may want to limit the scope of the LLM's selection, to decrease token consumption and to help manage sources of error in LLM reasoning.\n\nTo address this, you can dynamically adjust the tools available to a model by retrieving relevant tools at runtime using semantic search.\n\nSee [`langgraph-bigtool`](https://github.com/langchain-ai/langgraph-bigtool) prebuilt library for a ready-to-use implementation.\n\n## Prebuilt tools\n\n### LLM provider tools\n\nYou can use prebuilt tools from model providers by passing a dictionary with tool specs to the `tools` parameter of `create_react_agent`. For example, to use the `web_search_preview` tool from OpenAI:\n\n```python\nfrom langgraph.prebuilt import create_react_agent\n\nagent = create_react_agent(\n    model=\"openai:gpt-4o-mini\",\n    tools=[{\"type\": \"web_search_preview\"}]\n)\nresponse = agent.invoke(\n    {\"messages\": [\"What was a positive news story from today?\"]}\n)\n```\n\nPlease consult the documentation for the specific model you are using to see which tools are available and how to use them.\n\n### LangChain tools\n\nAdditionally, LangChain supports a wide range of prebuilt tool integrations for interacting with APIs, databases, file systems, web data, and more. These tools extend the functionality of agents and enable rapid development.\n\nYou can browse the full list of available integrations in the [LangChain integrations directory](https://python.langchain.com/docs/integrations/tools/).\n\nSome commonly used tool categories include:\n\n- **Search**: Bing, SerpAPI, Tavily\n- **Code interpreters**: Python REPL, Node.js REPL\n- **Databases**: SQL, MongoDB, Redis\n- **Web data**: Web scraping and browsing\n- **APIs**: OpenWeatherMap, NewsAPI, and others\n\nThese integrations can be configured and added to your agents using the same `tools` parameter shown in the examples above.\n\n---\nhow-tos/cross-thread-persistence-functional.ipynb\n---\n\n# How to add cross-thread persistence (functional API)\n\n!!! info \"Prerequisites\"\n\nThis guide assumes familiarity with the following:\n    \n    - <a href=\"../../concepts/functional_api/\">Functional API</a>\n    - <a href=\"../../concepts/persistence/\">Persistence</a>\n    - <a href=\"../../concepts/memory/\">Memory</a>\n    - [Chat Models](https://python.langchain.com/docs/concepts/chat_models/)\n\nLangGraph allows you to persist data across **different <a href=\"../../concepts/persistence/#threads\">threads</a>**. For instance, you can store information about users (their names or preferences) in a shared (cross-thread) memory and reuse them in the new threads (e.g., new conversations).\n\nWhen using the <a href=\"../../concepts/functional_api/\">functional API</a>, you can set it up to store and retrieve memories by using the [Store](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore) interface:\n\n1. Create an instance of a `Store`\n\n```python\n    from langgraph.store.memory import InMemoryStore, BaseStore\n    \n    store = InMemoryStore()\n    ```\n\n2. Pass the `store` instance to the `entrypoint()` decorator and expose `store` parameter in the function signature:\n\n```python\n    from langgraph.func import entrypoint\n\n@entrypoint(store=store)\n    def workflow(inputs: dict, store: BaseStore):\n        my_task(inputs).result()\n        ...\n    ```\n    \nIn this guide, we will show how to construct and use a workflow that has a shared memory implemented using the [Store](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore) interface.\n\n!!! note Note\n\nSupport for the [`Store`](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore) API that is used in this guide was added in LangGraph `v0.2.32`.\n\nSupport for __index__ and __query__ arguments of the [`Store`](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore) API that is used in this guide was added in LangGraph `v0.2.54`.\n\n!!! tip \"Note\"\n\nIf you need to add cross-thread persistence to a `StateGraph`, check out this <a href=\"../cross-thread-persistence\">how-to guide</a>.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys\n\n```shell\npip install -U langchain_anthropic langchain_openai langgraph\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"ANTHROPIC_API_KEY\")\n_set_env(\"OPENAI_API_KEY\")\n```\n\n!!! tip \"Set up [LangSmith](https://smith.langchain.com) for LangGraph development\"\n\nSign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started [here](https://docs.smith.langchain.com)\n\n## Example: simple chatbot with long-term memory\n\n### Define store\n\nIn this example we will create a workflow that will be able to retrieve information about a user's preferences. We will do so by defining an `InMemoryStore` - an object that can store data in memory and query that data.\n\nWhen storing objects using the `Store` interface you define two things:\n\n* the namespace for the object, a tuple (similar to directories)\n* the object key (similar to filenames)\n\nIn our example, we'll be using `(\"memories\", <user_id>)` as namespace and random UUID as key for each new memory.\n\nImportantly, to determine the user, we will be passing `user_id` via the config keyword argument of the node function.\n\nLet's first define our store!\n\n```python\nfrom langgraph.store.memory import InMemoryStore\nfrom langchain_openai import OpenAIEmbeddings\n\nin_memory_store = InMemoryStore(\n    index={\n        \"embed\": OpenAIEmbeddings(model=\"text-embedding-3-small\"),\n        \"dims\": 1536,\n    }\n)\n```\n\n### Create workflow\n\n```python\nimport uuid\n\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.runnables import RunnableConfig\nfrom langchain_core.messages import BaseMessage\nfrom langgraph.func import entrypoint, task\nfrom langgraph.graph import add_messages\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.store.base import BaseStore\n\nmodel = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n\n@task\ndef call_model(messages: list[BaseMessage], memory_store: BaseStore, user_id: str):\n    namespace = (\"memories\", user_id)\n    last_message = messages[-1]\n    memories = memory_store.search(namespace, query=str(last_message.content))\n    info = \"\\n\".join([d.value[\"data\"] for d in memories])\n    system_msg = f\"You are a helpful assistant talking to the user. User info: {info}\"\n\n# Store new memories if the user asks the model to remember\n    if \"remember\" in last_message.content.lower():\n        memory = \"User name is Bob\"\n        memory_store.put(namespace, str(uuid.uuid4()), {\"data\": memory})\n\nresponse = model.invoke([{\"role\": \"system\", \"content\": system_msg}] + messages)\n    return response\n\n# NOTE: we're passing the store object here when creating a workflow via entrypoint()\n@entrypoint(checkpointer=InMemorySaver(), store=in_memory_store)\ndef workflow(\n    inputs: list[BaseMessage],\n    *,\n    previous: list[BaseMessage],\n    config: RunnableConfig,\n    store: BaseStore,\n):\n    user_id = config[\"configurable\"][\"user_id\"]\n    previous = previous or []\n    inputs = add_messages(previous, inputs)\n    response = call_model(inputs, store, user_id).result()\n    return entrypoint.final(value=response, save=add_messages(inputs, response))\n```\n\n!!! note Note\n\nIf you're using LangGraph Cloud or LangGraph Studio, you __don't need__ to pass store to the entrypoint decorator, since it's done automatically.\n\n### Run the workflow!\n\nNow let's specify a user ID in the config and tell the model our name:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\", \"user_id\": \"1\"}}\ninput_message = {\"role\": \"user\", \"content\": \"Hi! Remember: my name is Bob\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nHello Bob! Nice to meet you. I'll remember that your name is Bob. How can I help you today?\n```\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"2\", \"user_id\": \"1\"}}\ninput_message = {\"role\": \"user\", \"content\": \"what is my name?\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nYour name is Bob.\n```\nWe can now inspect our in-memory store and verify that we have in fact saved the memories for the user:\n\n```python\nfor memory in in_memory_store.search((\"memories\", \"1\")):\n    print(memory.value)\n```\n```output\n{'data': 'User name is Bob'}\n```\nLet's now run the workflow for another user to verify that the memories about the first user are self contained:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"3\", \"user_id\": \"2\"}}\ninput_message = {\"role\": \"user\", \"content\": \"what is my name?\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nI don't have any information about your name. I can only see our current conversation without any prior context or personal details about you. If you'd like me to know your name, feel free to tell me!\n```\n\n---\nhow-tos/multi-agent-network-functional.ipynb\n---\n\n# How to build a multi-agent network (functional API)\n\n!!! info \"Prerequisites\" \n    This guide assumes familiarity with the following:\n\n- <a href=\"../../concepts/multi_agent\">Multi-agent systems</a>\n    - <a href=\"../../concepts/functional_api\">Functional API</a>\n    - <a href=\"../../concepts/low_level/#command\">Command</a>\n    - <a href=\"../../concepts/low_level/\">LangGraph Glossary</a>\n\nIn this how-to guide we will demonstrate how to implement a <a href=\"../../concepts/multi_agent#network\">multi-agent network</a> architecture where each agent can communicate with every other agent (many-to-many connections) and can decide which agent to call next. We will be using <a href=\"../../concepts/functional_api\">functional API</a> — individual agents will be defined as tasks and the agent handoffs will be defined in the main [entrypoint()][langgraph.func.entrypoint]:\n\n```python\nfrom langgraph.func import entrypoint\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_core.tools import tool\n\n# Define a tool to signal intent to hand off to a different agent\n@tool(return_direct=True)\ndef transfer_to_hotel_advisor():\n    \"\"\"Ask hotel advisor agent for help.\"\"\"\n    return \"Successfully transferred to hotel advisor\"\n\n# define an agent\ntravel_advisor_tools = [transfer_to_hotel_advisor, ...]\ntravel_advisor = create_react_agent(model, travel_advisor_tools)\n\n# define a task that calls an agent\n@task\ndef call_travel_advisor(messages):\n    response = travel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\n# define the multi-agent network workflow\n@entrypoint()\ndef workflow(messages):\n    call_active_agent = call_travel_advisor\n    while True:\n        agent_messages = call_active_agent(messages).result()\n        messages = messages + agent_messages\n        call_active_agent = get_next_agent(messages)\n    return messages\n```\n\n## Setup\n\nFirst, let's install the required packages\n\n```shell\npip install -U langgraph langchain-anthropic\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"ANTHROPIC_API_KEY\")\n```\n```output\nANTHROPIC_API_KEY:  ········\n```\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\n## Travel agent example\n\nIn this example we will build a team of travel assistant agents that can communicate with each other.\n\nWe will create 2 agents:\n\n* `travel_advisor`: can help with travel destination recommendations. Can ask `hotel_advisor` for help.\n* `hotel_advisor`: can help with hotel recommendations. Can ask `travel_advisor` for help.\n\nThis is a fully-connected network - every agent can talk to any other agent.\n\nFirst, let's create some of the tools that the agents will be using:\n\n```python\nimport random\nfrom typing_extensions import Literal\nfrom langchain_core.tools import tool\n\n@tool\ndef get_travel_recommendations():\n    \"\"\"Get recommendation for travel destinations\"\"\"\n    return random.choice([\"aruba\", \"turks and caicos\"])\n\n@tool\ndef get_hotel_recommendations(location: Literal[\"aruba\", \"turks and caicos\"]):\n    \"\"\"Get hotel recommendations for a given destination.\"\"\"\n    return {\n        \"aruba\": [\n            \"The Ritz-Carlton, Aruba (Palm Beach)\"\n            \"Bucuti & Tara Beach Resort (Eagle Beach)\"\n        ],\n        \"turks and caicos\": [\"Grace Bay Club\", \"COMO Parrot Cay\"],\n    }[location]\n\n@tool(return_direct=True)\ndef transfer_to_hotel_advisor():\n    \"\"\"Ask hotel advisor agent for help.\"\"\"\n    return \"Successfully transferred to hotel advisor\"\n\n@tool(return_direct=True)\ndef transfer_to_travel_advisor():\n    \"\"\"Ask travel advisor agent for help.\"\"\"\n    return \"Successfully transferred to travel advisor\"\n```\n\n!!! note \"Transfer tools\"\n\nYou might have noticed that we're using `@tool(return_direct=True)` in the transfer tools. This is done so that individual agents (e.g., `travel_advisor`) can exit the ReAct loop early once these tools are called. This is the desired behavior, as we want to detect when the agent calls this tool and hand control off _immediately_ to a different agent. \n    \n    **NOTE**: This is meant to work with the prebuilt [`create_react_agent`][langgraph.prebuilt.chat_agent_executor.create_react_agent] -- if you are building a custom agent, make sure to manually add logic for handling early exit for tools that are marked with `return_direct`.\n\nNow let's define our agent tasks and combine them into a single multi-agent network workflow:\n\n```python\nfrom langchain_core.messages import AIMessage\nfrom langchain_anthropic import ChatAnthropic\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.graph import add_messages\nfrom langgraph.func import entrypoint, task\n\nmodel = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n\n# Define travel advisor ReAct agent\ntravel_advisor_tools = [\n    get_travel_recommendations,\n    transfer_to_hotel_advisor,\n]\ntravel_advisor = create_react_agent(\n    model,\n    travel_advisor_tools,\n    prompt=(\n        \"You are a general travel expert that can recommend travel destinations (e.g. countries, cities, etc). \"\n        \"If you need hotel recommendations, ask 'hotel_advisor' for help. \"\n        \"You MUST include human-readable response before transferring to another agent.\"\n    ),\n)\n\n@task\ndef call_travel_advisor(messages):\n    # You can also add additional logic like changing the input to the agent / output from the agent, etc.\n    # NOTE: we're invoking the ReAct agent with the full history of messages in the state\n    response = travel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\n# Define hotel advisor ReAct agent\nhotel_advisor_tools = [get_hotel_recommendations, transfer_to_travel_advisor]\nhotel_advisor = create_react_agent(\n    model,\n    hotel_advisor_tools,\n    prompt=(\n        \"You are a hotel expert that can provide hotel recommendations for a given destination. \"\n        \"If you need help picking travel destinations, ask 'travel_advisor' for help.\"\n        \"You MUST include human-readable response before transferring to another agent.\"\n    ),\n)\n\n@task\ndef call_hotel_advisor(messages):\n    response = hotel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\n@entrypoint()\ndef workflow(messages):\n    messages = add_messages([], messages)\n\ncall_active_agent = call_travel_advisor\n    while True:\n        agent_messages = call_active_agent(messages).result()\n        messages = add_messages(messages, agent_messages)\n        ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))\n        if not ai_msg.tool_calls:\n            break\n\ntool_call = ai_msg.tool_calls[-1]\n        if tool_call[\"name\"] == \"transfer_to_travel_advisor\":\n            call_active_agent = call_travel_advisor\n        elif tool_call[\"name\"] == \"transfer_to_hotel_advisor\":\n            call_active_agent = call_hotel_advisor\n        else:\n            raise ValueError(f\"Expected transfer tool, got '{tool_call['name']}'\")\n\nreturn messages\n```\n\nLastly, let's define a helper to render the agent outputs:\n\n```python\nfrom langchain_core.messages import convert_to_messages\n\ndef pretty_print_messages(update):\n    if isinstance(update, tuple):\n        ns, update = update\n        # skip parent graph updates in the printouts\n        if len(ns) == 0:\n            return\n\ngraph_id = ns[-1].split(\":\")[0]\n        print(f\"Update from subgraph {graph_id}:\")\n        print(\"\\n\")\n\nfor node_name, node_update in update.items():\n        print(f\"Update from node {node_name}:\")\n        print(\"\\n\")\n\nfor m in convert_to_messages(node_update[\"messages\"]):\n            m.pretty_print()\n        print(\"\\n\")\n```\n\nLet's test it out using the same input as our original multi-agent system:\n\n```python\nfor chunk in workflow.stream(\n    [\n        {\n            \"role\": \"user\",\n            \"content\": \"i wanna go somewhere warm in the caribbean. pick one destination and give me hotel recommendations\",\n        }\n    ],\n    subgraphs=True,\n):\n    pretty_print_messages(chunk)\n```\n```output\nUpdate from subgraph call_travel_advisor:\n\nUpdate from node agent:\n\n================================== Ai Message ==================================\n\n[{'text': \"I'll help you find a warm Caribbean destination and then get some hotel recommendations for you.\\n\\nLet me first get some destination recommendations for the Caribbean region.\", 'type': 'text'}, {'id': 'toolu_015vT8PkPq1VXvjrDvSpWUwJ', 'input': {}, 'name': 'get_travel_recommendations', 'type': 'tool_use'}]\nTool Calls:\n  get_travel_recommendations (toolu_015vT8PkPq1VXvjrDvSpWUwJ)\n Call ID: toolu_015vT8PkPq1VXvjrDvSpWUwJ\n  Args:\n\nUpdate from subgraph call_travel_advisor:\n\nUpdate from node tools:\n\n================================= Tool Message =================================\nName: get_travel_recommendations\n\nturks and caicos\n\nUpdate from subgraph call_travel_advisor:\n\nUpdate from node agent:\n\n================================== Ai Message ==================================\n\n[{'text': \"Based on the recommendation, I suggest Turks and Caicos! This beautiful British Overseas Territory is known for its stunning white-sand beaches, crystal-clear turquoise waters, and year-round warm weather. Grace Bay Beach in Providenciales is consistently ranked among the world's best beaches. The islands offer excellent snorkeling, diving, and water sports opportunities, plus a relaxed Caribbean atmosphere.\\n\\nNow, let me connect you with our hotel advisor to get some specific hotel recommendations for Turks and Caicos.\", 'type': 'text'}, {'id': 'toolu_01JY7pNNWFuaWoe9ymxFYiPV', 'input': {}, 'name': 'transfer_to_hotel_advisor', 'type': 'tool_use'}]\nTool Calls:\n  transfer_to_hotel_advisor (toolu_01JY7pNNWFuaWoe9ymxFYiPV)\n Call ID: toolu_01JY7pNNWFuaWoe9ymxFYiPV\n  Args:\n\nUpdate from subgraph call_travel_advisor:\n\nUpdate from node tools:\n\n================================= Tool Message =================================\nName: transfer_to_hotel_advisor\n\nSuccessfully transferred to hotel advisor\n\nUpdate from subgraph call_hotel_advisor:\n\nUpdate from node agent:\n\n================================== Ai Message ==================================\n\n[{'text': 'Let me get some hotel recommendations for Turks and Caicos:', 'type': 'text'}, {'id': 'toolu_0129ELa7jFocn16bowaGNapg', 'input': {'location': 'turks and caicos'}, 'name': 'get_hotel_recommendations', 'type': 'tool_use'}]\nTool Calls:\n  get_hotel_recommendations (toolu_0129ELa7jFocn16bowaGNapg)\n Call ID: toolu_0129ELa7jFocn16bowaGNapg\n  Args:\n    location: turks and caicos\n\nUpdate from subgraph call_hotel_advisor:\n\nUpdate from node tools:\n\n================================= Tool Message =================================\nName: get_hotel_recommendations\n\n[\"Grace Bay Club\", \"COMO Parrot Cay\"]\n\nUpdate from subgraph call_hotel_advisor:\n\nUpdate from node agent:\n\n================================== Ai Message ==================================\n\nHere are two excellent hotel options in Turks and Caicos:\n\n1. Grace Bay Club: This luxury resort is located on the world-famous Grace Bay Beach. It offers all-oceanfront suites, exceptional dining options, and personalized service. The resort features adult-only and family-friendly sections, making it perfect for any type of traveler.\n\n2. COMO Parrot Cay: This exclusive private island resort offers the ultimate luxury escape. It's known for its pristine beach, world-class spa, and holistic wellness programs. The resort provides an intimate, secluded experience with top-notch amenities and service.\n\nWould you like more specific information about either of these properties or would you like to explore hotels in another destination?\n```\nVoila - `travel_advisor` picks a destination and then makes a decision to call `hotel_advisor` for more info!\n\n---\nhow-tos/multi-agent-multi-turn-convo-functional.ipynb\n---\n\n# How to add multi-turn conversation in a multi-agent application (functional API)\n\n!!! info \"Prerequisites\"\n    This guide assumes familiarity with the following:\n\n- <a href=\"../../concepts/multi_agent\">Multi-agent systems</a>\n    - <a href=\"../../concepts/human_in_the_loop\">Human-in-the-loop</a>\n    - <a href=\"../../concepts/functional_api\">Functional API</a>\n    - <a href=\"../../concepts/low_level/#command\">Command</a>\n    - <a href=\"../../concepts/low_level/\">LangGraph Glossary</a>\n\nIn this how-to guide, we’ll build an application that allows an end-user to engage in a *multi-turn conversation* with one or more agents. We'll create a node that uses an <a href=\"../../reference/types/#langgraph.types.interrupt\">`interrupt`</a> to collect user input and routes back to the **active** agent.\n\nThe agents will be implemented as tasks in a workflow that executes agent steps and determines the next action:\n\n1. **Wait for user input** to continue the conversation, or\n2. **Route to another agent** (or back to itself, such as in a loop) via a <a href=\"../../concepts/multi_agent/#handoffs\">**handoff**</a>.\n\n```python\nfrom langgraph.func import entrypoint, task\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_core.tools import tool\nfrom langgraph.types import interrupt\n\n# Define a tool to signal intent to hand off to a different agent\n# Note: this is not using Command(goto) syntax for navigating to different agents:\n# `workflow()` below handles the handoffs explicitly\n@tool(return_direct=True)\ndef transfer_to_hotel_advisor():\n    \"\"\"Ask hotel advisor agent for help.\"\"\"\n    return \"Successfully transferred to hotel advisor\"\n\n# define an agent\ntravel_advisor_tools = [transfer_to_hotel_advisor, ...]\ntravel_advisor = create_react_agent(model, travel_advisor_tools)\n\n# define a task that calls an agent\n@task\ndef call_travel_advisor(messages):\n    response = travel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\n# define the multi-agent network workflow\n@entrypoint(checkpointer)\ndef workflow(messages):\n    call_active_agent = call_travel_advisor\n    while True:\n        agent_messages = call_active_agent(messages).result()\n        ai_msg = get_last_ai_msg(agent_messages)\n        if not ai_msg.tool_calls:\n            user_input = interrupt(value=\"Ready for user input.\")\n            messages = messages + [{\"role\": \"user\", \"content\": user_input}]\n            continue", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "messages = messages + agent_messages\n        call_active_agent = get_next_agent(messages)\n    return entrypoint.final(value=agent_messages[-1], save=messages)\n```\n\n## Setup\n\nFirst, let's install the required packages\n\n```python\n# %%capture --no-stderr\n# %pip install -U langgraph langchain-anthropic\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"ANTHROPIC_API_KEY\")\n```\n```output\nANTHROPIC_API_KEY:  ········\n```\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\nIn this example we will build a team of travel assistant agents that can communicate with each other.\n\nWe will create 2 agents:\n\n* `travel_advisor`: can help with travel destination recommendations. Can ask `hotel_advisor` for help.\n* `hotel_advisor`: can help with hotel recommendations. Can ask `travel_advisor` for help.\n\nThis is a fully-connected network - every agent can talk to any other agent.\n\n```python\nimport random\nfrom typing_extensions import Literal\nfrom langchain_core.tools import tool\n\n@tool\ndef get_travel_recommendations():\n    \"\"\"Get recommendation for travel destinations\"\"\"\n    return random.choice([\"aruba\", \"turks and caicos\"])\n\n@tool\ndef get_hotel_recommendations(location: Literal[\"aruba\", \"turks and caicos\"]):\n    \"\"\"Get hotel recommendations for a given destination.\"\"\"\n    return {\n        \"aruba\": [\n            \"The Ritz-Carlton, Aruba (Palm Beach)\"\n            \"Bucuti & Tara Beach Resort (Eagle Beach)\"\n        ],\n        \"turks and caicos\": [\"Grace Bay Club\", \"COMO Parrot Cay\"],\n    }[location]\n\n@tool(return_direct=True)\ndef transfer_to_hotel_advisor():\n    \"\"\"Ask hotel advisor agent for help.\"\"\"\n    return \"Successfully transferred to hotel advisor\"\n\n@tool(return_direct=True)\ndef transfer_to_travel_advisor():\n    \"\"\"Ask travel advisor agent for help.\"\"\"\n    return \"Successfully transferred to travel advisor\"\n```\n\n!!! note \"Transfer tools\"\n\nYou might have noticed that we're using `@tool(return_direct=True)` in the transfer tools. This is done so that individual agents (e.g., `travel_advisor`) can exit the ReAct loop early once these tools are called. This is the desired behavior, as we want to detect when the agent calls this tool and hand control off _immediately_ to a different agent. \n    \n    **NOTE**: This is meant to work with the prebuilt [`create_react_agent`][langgraph.prebuilt.chat_agent_executor.create_react_agent] -- if you are building a custom agent, make sure to manually add logic for handling early exit for tools that are marked with `return_direct`.\n\nLet's now create our agents using the prebuilt [`create_react_agent`][langgraph.prebuilt.chat_agent_executor.create_react_agent] and our multi-agent workflow. Note that will be calling [`interrupt`][langgraph.types.interrupt] every time after we get the final response from each of the agents.\n\n```python\nimport uuid\n\nfrom langchain_core.messages import AIMessage\nfrom langchain_anthropic import ChatAnthropic\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.graph import add_messages\nfrom langgraph.func import entrypoint, task\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.types import interrupt, Command\n\nmodel = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n\n# Define travel advisor ReAct agent\ntravel_advisor_tools = [\n    get_travel_recommendations,\n    transfer_to_hotel_advisor,\n]\ntravel_advisor = create_react_agent(\n    model,\n    travel_advisor_tools,\n    prompt=(\n        \"You are a general travel expert that can recommend travel destinations (e.g. countries, cities, etc). \"\n        \"If you need hotel recommendations, ask 'hotel_advisor' for help. \"\n        \"You MUST include human-readable response before transferring to another agent.\"\n    ),\n)\n\n@task\ndef call_travel_advisor(messages):\n    # You can also add additional logic like changing the input to the agent / output from the agent, etc.\n    # NOTE: we're invoking the ReAct agent with the full history of messages in the state\n    response = travel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\n# Define hotel advisor ReAct agent\nhotel_advisor_tools = [get_hotel_recommendations, transfer_to_travel_advisor]\nhotel_advisor = create_react_agent(\n    model,\n    hotel_advisor_tools,\n    prompt=(\n        \"You are a hotel expert that can provide hotel recommendations for a given destination. \"\n        \"If you need help picking travel destinations, ask 'travel_advisor' for help.\"\n        \"You MUST include human-readable response before transferring to another agent.\"\n    ),\n)\n\n@task\ndef call_hotel_advisor(messages):\n    response = hotel_advisor.invoke({\"messages\": messages})\n    return response[\"messages\"]\n\ncheckpointer = InMemorySaver()\n\ndef string_to_uuid(input_string):\n    return str(uuid.uuid5(uuid.NAMESPACE_URL, input_string))\n\n@entrypoint(checkpointer=checkpointer)\ndef multi_turn_graph(messages, previous):\n    previous = previous or []\n    messages = add_messages(previous, messages)\n    call_active_agent = call_travel_advisor\n    while True:\n        agent_messages = call_active_agent(messages).result()\n        messages = add_messages(messages, agent_messages)\n        # Find the last AI message\n        # If one of the handoff tools is called, the last message returned\n        # by the agent will be a ToolMessage because we set them to have\n        # \"return_direct=True\". This means that the last AIMessage will\n        # have tool calls.\n        # Otherwise, the last returned message will be an AIMessage with\n        # no tool calls, which means we are ready for new input.\n        ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))\n        if not ai_msg.tool_calls:\n            user_input = interrupt(value=\"Ready for user input.\")\n            # Add user input as a human message\n            # NOTE: we generate unique ID for the human message based on its content\n            # it's important, since on subsequent invocations previous user input (interrupt) values\n            # will be looked up again and we will attempt to add them again here\n            # `add_messages` deduplicates messages based on the ID, ensuring correct message history\n            human_message = {\n                \"role\": \"user\",\n                \"content\": user_input,\n                \"id\": string_to_uuid(user_input),\n            }\n            messages = add_messages(messages, [human_message])\n            continue\n\ntool_call = ai_msg.tool_calls[-1]\n        if tool_call[\"name\"] == \"transfer_to_hotel_advisor\":\n            call_active_agent = call_hotel_advisor\n        elif tool_call[\"name\"] == \"transfer_to_travel_advisor\":\n            call_active_agent = call_travel_advisor\n        else:\n            raise ValueError(f\"Expected transfer tool, got '{tool_call['name']}'\")\n\nreturn entrypoint.final(value=agent_messages[-1], save=messages)\n```\n\n## Test multi-turn conversation\n\nLet's test a multi turn conversation with this application.\n\n```python\nthread_config = {\"configurable\": {\"thread_id\": uuid.uuid4()}}\n\ninputs = [\n    # 1st round of conversation,\n    {\n        \"role\": \"user\",\n        \"content\": \"i wanna go somewhere warm in the caribbean\",\n        \"id\": str(uuid.uuid4()),\n    },\n    # Since we're using `interrupt`, we'll need to resume using the Command primitive.\n    # 2nd round of conversation,\n    Command(\n        resume=\"could you recommend a nice hotel in one of the areas and tell me which area it is.\"\n    ),\n    # 3rd round of conversation,\n    Command(\n        resume=\"i like the first one. could you recommend something to do near the hotel?\"\n    ),\n]\n\nfor idx, user_input in enumerate(inputs):\n    print()\n    print(f\"--- Conversation Turn {idx + 1} ---\")\n    print()\n    print(f\"User: {user_input}\")\n    print()\n    for update in multi_turn_graph.stream(\n        user_input,\n        config=thread_config,\n        stream_mode=\"updates\",\n    ):\n        for node_id, value in update.items():\n            if isinstance(value, list) and value:\n                last_message = value[-1]\n                if isinstance(last_message, dict) or last_message.type != \"ai\":\n                    continue\n                print(f\"{node_id}: {last_message.content}\")\n```\n```output\n--- Conversation Turn 1 ---\n\nUser: {'role': 'user', 'content': 'i wanna go somewhere warm in the caribbean', 'id': 'f48d82a7-7efa-43f5-ad4c-541758c95f61'}\n\ncall_travel_advisor: Based on the recommendations, Aruba would be an excellent choice for your Caribbean getaway! Known as \"One Happy Island,\" Aruba offers:\n- Year-round warm weather with consistent temperatures around 82°F (28°C)\n- Beautiful white sand beaches like Eagle Beach and Palm Beach\n- Crystal clear waters perfect for swimming and snorkeling\n- Minimal rainfall and location outside the hurricane belt\n- Rich culture blending Dutch and Caribbean influences\n- Various activities from water sports to desert-like landscape exploration\n- Excellent dining and shopping options\n\nWould you like me to help you find suitable accommodations in Aruba? I can transfer you to our hotel advisor who can recommend specific hotels based on your preferences.\n\n--- Conversation Turn 2 ---\n\nUser: Command(resume='could you recommend a nice hotel in one of the areas and tell me which area it is.')\n\ncall_hotel_advisor: I can recommend two excellent options in different areas:\n\n1. The Ritz-Carlton, Aruba - Located in Palm Beach\n- Luxury beachfront resort\n- Located in the vibrant Palm Beach area, known for its lively atmosphere\n- Close to restaurants, shopping, and nightlife\n- Perfect for those who want a more active vacation with plenty of amenities nearby\n\n2. Bucuti & Tara Beach Resort - Located in Eagle Beach\n- Adults-only boutique resort\n- Situated on the quieter Eagle Beach\n- Known for its romantic atmosphere and excellent service\n- Ideal for couples seeking a more peaceful, intimate setting\n\nWould you like more specific information about either of these properties or their locations?\n\n--- Conversation Turn 3 ---\n\nUser: Command(resume='i like the first one. could you recommend something to do near the hotel?')\n\ncall_travel_advisor: Near The Ritz-Carlton in Palm Beach, here are some popular activities you can enjoy:\n\n1. Palm Beach Strip - Take a walk along this bustling strip filled with restaurants, shops, and bars\n2. Visit the Bubali Bird Sanctuary - Just a short distance away\n3. Try your luck at the Stellaris Casino - Located right in The Ritz-Carlton\n4. Water Sports at Palm Beach - Right in front of the hotel you can:\n   - Go parasailing\n   - Try jet skiing\n   - Take a sunset sailing cruise\n5. Visit the Palm Beach Plaza Mall - High-end shopping just a short walk away\n6. Enjoy dinner at Madame Janette's - One of Aruba's most famous restaurants nearby\n\nWould you like more specific information about any of these activities or other suggestions in the area?\n```\n\n---\nhow-tos/persistence-functional.ipynb\n---\n\n# How to add thread-level persistence (functional API)\n\n!!! info \"Prerequisites\"\n\nThis guide assumes familiarity with the following:\n    \n    - <a href=\"../../concepts/functional_api/\">Functional API</a>\n    - <a href=\"../../concepts/persistence/\">Persistence</a>\n    - <a href=\"../../concepts/memory/\">Memory</a>\n    - [Chat Models](https://python.langchain.com/docs/concepts/chat_models/)\n\n!!! info \"Not needed for LangGraph API users\"\n\nIf you're using the LangGraph API, you needn't manually implement a checkpointer. The API automatically handles checkpointing for you. This guide is relevant when implementing LangGraph in your own custom server.\n\nMany AI applications need memory to share context across multiple interactions on the same <a href=\"../../concepts/persistence#threads\">thread</a> (e.g., multiple turns of a conversation). In LangGraph functional API, this kind of memory can be added to any [entrypoint()][langgraph.func.entrypoint] workflow using [thread-level persistence](https://langchain-ai.github.io/langgraph/concepts/persistence).\n\nWhen creating a LangGraph workflow, you can set it up to persist its results by using a [checkpointer](https://langchain-ai.github.io/langgraph/reference/checkpoints/#basecheckpointsaver):\n\n1. Create an instance of a checkpointer:\n\n```python\n    from langgraph.checkpoint.memory import InMemorySaver\n    \n    checkpointer = InMemorySaver()       \n    ```\n\n2. Pass `checkpointer` instance to the `entrypoint()` decorator:\n\n```python\n    from langgraph.func import entrypoint\n    \n    @entrypoint(checkpointer=checkpointer)\n    def workflow(inputs)\n        ...\n    ```\n\n3. Optionally expose `previous` parameter in the workflow function signature:\n\n```python\n    @entrypoint(checkpointer=checkpointer)\n    def workflow(\n        inputs,\n        *,\n        # you can optionally specify `previous` in the workflow function signature\n        # to access the return value from the workflow as of the last execution\n        previous\n    ):\n        previous = previous or []\n        combined_inputs = previous + inputs\n        result = do_something(combined_inputs)\n        ...\n    ```\n\n4. Optionally choose which values will be returned from the workflow and which will be saved by the checkpointer as `previous`:\n\n```python\n    @entrypoint(checkpointer=checkpointer)\n    def workflow(inputs, *, previous):\n        ...\n        result = do_something(...)\n        return entrypoint.final(value=result, save=combine(inputs, result))\n    ```\n\nThis guide shows how you can add thread-level persistence to your workflow.\n\n!!! tip \"Note\"\n\nIf you need memory that is __shared__ across multiple conversations or users (cross-thread persistence), check out this <a href=\"../cross-thread-persistence-functional\">how-to guide</a>.\n\n!!! tip \"Note\"\n\nIf you need to add thread-level persistence to a `StateGraph`, check out this <a href=\"../persistence\">how-to guide</a>.\n\n## Setup\n\nFirst we need to install the packages required\n\n```shell\npip install --quiet -U langgraph langchain_anthropic\n```\n\nNext, we need to set API key for Anthropic (the LLM we will use).\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"ANTHROPIC_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\n## Example: simple chatbot with short-term memory\n\nWe will be using a workflow with a single task that calls a [chat model](https://python.langchain.com/docs/concepts/chat_models/).\n\nLet's first define the model we'll be using:\n\n```python\nfrom langchain_anthropic import ChatAnthropic\n\nmodel = ChatAnthropic(model=\"claude-3-5-sonnet-latest\")\n```\n\nNow we can define our task and workflow. To add in persistence, we need to pass in a [Checkpointer](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.base.BaseCheckpointSaver) to the [entrypoint()][langgraph.func.entrypoint] decorator.\n\n```python\nfrom langchain_core.messages import BaseMessage\nfrom langgraph.graph import add_messages\nfrom langgraph.func import entrypoint, task\nfrom langgraph.checkpoint.memory import InMemorySaver\n\n@task\ndef call_model(messages: list[BaseMessage]):\n    response = model.invoke(messages)\n    return response\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(inputs: list[BaseMessage], *, previous: list[BaseMessage]):\n    if previous:\n        inputs = add_messages(previous, inputs)\n\nresponse = call_model(inputs).result()\n    return entrypoint.final(value=response, save=add_messages(inputs, response))\n```\n\nIf we try to use this workflow, the context of the conversation will be persisted across interactions:\n\n!!! note Note\n\nIf you're using LangGraph Platform or LangGraph Studio, you __don't need__ to pass checkpointer to the entrypoint decorator, since it's done automatically.\n\nWe can now interact with the agent and see that it remembers previous messages!\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\ninput_message = {\"role\": \"user\", \"content\": \"hi! I'm bob\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nHi Bob! I'm Claude. Nice to meet you! How are you today?\n```\nYou can always resume previous threads:\n\n```python\ninput_message = {\"role\": \"user\", \"content\": \"what's my name?\"}\nfor chunk in workflow.stream([input_message], config, stream_mode=\"values\"):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nYour name is Bob.\n```\nIf we want to start a new conversation, we can pass in a different `thread_id`. Poof! All the memories are gone!\n\n```python\ninput_message = {\"role\": \"user\", \"content\": \"what's my name?\"}\nfor chunk in workflow.stream(\n    [input_message],\n    {\"configurable\": {\"thread_id\": \"2\"}},\n    stream_mode=\"values\",\n):\n    chunk.pretty_print()\n```\n```output\n================================== Ai Message ==================================\n\nI don't know your name unless you tell me. Each conversation I have starts fresh, so I don't have access to any previous interactions or personal information unless you share it with me.\n```\n!!! tip \"Streaming tokens\"\n\nIf you would like to stream LLM tokens from your chatbot, you can use `stream_mode=\"messages\"`. Check out this <a href=\"../streaming-tokens\">how-to guide</a> to learn more.\n\n---\nhow-tos/create-react-agent-manage-message-history.ipynb\n---\n\n# How to manage conversation history in a ReAct Agent\n\n!!! info \"Prerequisites\"\n    This guide assumes familiarity with the following:\n\n- <a href=\"../create-react-agent\">Prebuilt create_react_agent</a>\n    - <a href=\"../../concepts/persistence\">Persistence</a>\n    - <a href=\"../../concepts/memory/#short-term-memory\">Short-term Memory</a>\n    - [Trimming Messages](https://python.langchain.com/docs/how_to/trim_messages/)\n\nMessage history can grow quickly and exceed LLM context window size, whether you're building chatbots with many conversation turns or agentic systems with numerous tool calls. There are several strategies for managing the message history:\n\n* <a href=\"#keep-the-original-message-history-unmodified\">message trimming</a> — remove first or last N messages in the history\n* <a href=\"#summarizing-message-history\">summarization</a> — summarize earlier messages in the history and replace them with a summary\n* custom strategies (e.g., message filtering, etc.)\n\nTo manage message history in `create_react_agent`, you need to define a `pre_model_hook` function or [runnable](https://python.langchain.com/docs/concepts/runnables/) that takes graph state an returns a state update:\n\n* Trimming example:\n    ```python hl_lines=\"1 2 3 4 19 25\"\n    from langchain_core.messages.utils import (\n        trim_messages, \n        count_tokens_approximately\n    )\n    from langgraph.prebuilt import create_react_agent\n    \n    # This function will be called every time before the node that calls LLM\n    def pre_model_hook(state):\n        trimmed_messages = trim_messages(\n            state[\"messages\"],\n            strategy=\"last\",\n            token_counter=count_tokens_approximately,\n            max_tokens=384,\n            start_on=\"human\",\n            end_on=(\"human\", \"tool\"),\n        )\n        # You can return updated messages either under `llm_input_messages` or \n        # `messages` key (see the note below)\n        return {\"llm_input_messages\": trimmed_messages}\n\ncheckpointer = InMemorySaver()\n    agent = create_react_agent(\n        model,\n        tools,\n        pre_model_hook=pre_model_hook,\n        checkpointer=checkpointer,\n    )\n    ```\n\n* Summarization example:\n    ```python hl_lines=\"1 20 27 28\"\n    from langmem.short_term import SummarizationNode\n    from langchain_core.messages.utils import count_tokens_approximately\n    from langgraph.prebuilt.chat_agent_executor import AgentState\n    from langgraph.checkpoint.memory import InMemorySaver\n    from typing import Any\n    \n    model = ChatOpenAI(model=\"gpt-4o\")\n    \n    summarization_node = SummarizationNode(\n        token_counter=count_tokens_approximately,\n        model=model,\n        max_tokens=384,\n        max_summary_tokens=128,\n        output_messages_key=\"llm_input_messages\",\n    )\n\nclass State(AgentState):\n        # NOTE: we're adding this key to keep track of previous summary information\n        # to make sure we're not summarizing on every LLM call\n        context: dict[str, Any]\n    \n    \n    checkpointer = InMemorySaver()\n    graph = create_react_agent(\n        model,\n        tools,\n        pre_model_hook=summarization_node,\n        state_schema=State,\n        checkpointer=checkpointer,\n    )\n    ```\n\n!!! Important\n    \n    * To **keep the original message history unmodified** in the graph state and pass the updated history **only as the input to the LLM**, return updated messages under `llm_input_messages` key\n    * To **overwrite the original message history** in the graph state with the updated history, return updated messages under `messages` key\n    \n    To overwrite the `messages` key, you need to do the following:\n\n```python\n    from langchain_core.messages import RemoveMessage\n    from langgraph.graph.message import REMOVE_ALL_MESSAGES\n\ndef pre_model_hook(state):\n        updated_messages = ...\n        return {\n            \"messages\": [RemoveMessage(id=REMOVE_ALL_MESSAGES), *updated_messages]\n            ...\n        }\n    ```\n\n## Setup\n\nFirst, let's install the required packages and set our API keys\n\n```shell\npip install -U langgraph langchain-openai langmem\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\n## Keep the original message history unmodified\n\nLet's build a ReAct agent with a step that manages the conversation history: when the length of the history exceeds a specified number of tokens, we will call [`trim_messages`](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.utils.trim_messages.html) utility that that will reduce the history while satisfying LLM provider constraints.\n\nThere are two ways that the updated message history can be applied inside ReAct agent:\n\n* <a href=\"#keep-the-original-message-history-unmodified\">**Keep the original message history unmodified**</a> in the graph state and pass the updated history **only as the input to the LLM**\n  * <a href=\"#overwrite-the-original-message-history\">**Overwrite the original message history**</a> in the graph state with the updated history\n\nLet's start by implementing the first one. We'll need to first define model and tools for our agent:\n\n```python\nfrom langchain_openai import ChatOpenAI\n\nmodel = ChatOpenAI(model=\"gpt-4o\", temperature=0)\n\ndef get_weather(location: str) -> str:\n    \"\"\"Use this to get weather information.\"\"\"\n    if any([city in location.lower() for city in [\"nyc\", \"new york city\"]]):\n        return \"It might be cloudy in nyc, with a chance of rain and temperatures up to 80 degrees.\"\n    elif any([city in location.lower() for city in [\"sf\", \"san francisco\"]]):\n        return \"It's always sunny in sf\"\n    else:\n        return f\"I am not sure what the weather is in {location}\"\n\ntools = [get_weather]\n```\n\nNow let's implement `pre_model_hook` — a function that will be added as a new node and called every time **before** the node that calls the LLM (the `agent` node).\n\nOur implementation will wrap the `trim_messages` call and return the trimmed messages under `llm_input_messages`. This will **keep the original message history unmodified** in the graph state and pass the updated history **only as the input to the LLM**\n\n```python hl_lines=\"4 5 6 7 22 29\"\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.checkpoint.memory import InMemorySaver\n\nfrom langchain_core.messages.utils import (\n    trim_messages,\n    count_tokens_approximately,\n)\n\n# This function will be added as a new node in ReAct agent graph\n# that will run every time before the node that calls the LLM.\n# The messages returned by this function will be the input to the LLM.\ndef pre_model_hook(state):\n    trimmed_messages = trim_messages(\n        state[\"messages\"],\n        strategy=\"last\",\n        token_counter=count_tokens_approximately,\n        max_tokens=384,\n        start_on=\"human\",\n        end_on=(\"human\", \"tool\"),\n    )\n    return {\"llm_input_messages\": trimmed_messages}\n\ncheckpointer = InMemorySaver()\ngraph = create_react_agent(\n    model,\n    tools,\n    pre_model_hook=pre_model_hook,\n    checkpointer=checkpointer,\n)\n```\n\n```python\nfrom IPython.display import display, Image\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n<p>\n\n</p>\n\nWe'll also define a utility to render the agent outputs nicely:\n\n```python\ndef print_stream(stream, output_messages_key=\"llm_input_messages\"):\n    for chunk in stream:\n        for node, update in chunk.items():\n            print(f\"Update from node: {node}\")\n            messages_key = (\n                output_messages_key if node == \"pre_model_hook\" else \"messages\"\n            )\n            for message in update[messages_key]:\n                if isinstance(message, tuple):\n                    print(message)\n                else:\n                    message.pretty_print()\n\nprint(\"\\n\\n\")\n```\n\nNow let's run the agent with a few different queries to reach the specified max tokens limit:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\ninputs = {\"messages\": [(\"user\", \"What's the weather in NYC?\")]}\nresult = graph.invoke(inputs, config=config)\n\ninputs = {\"messages\": [(\"user\", \"What's it known for?\")]}\nresult = graph.invoke(inputs, config=config)\n```\n\nLet's see how many tokens we have in the message history so far:\n\n```python\nmessages = result[\"messages\"]\ncount_tokens_approximately(messages)\n```\n\n```output\n415\n```\n\nYou can see that we are close to the `max_tokens` threshold, so on the next invocation we should see `pre_model_hook` kick-in and trim the message history. Let's run it again:\n\n```python\ninputs = {\"messages\": [(\"user\", \"where can i find the best bagel?\")]}\nprint_stream(graph.stream(inputs, config=config, stream_mode=\"updates\"))\n```\n```output\nUpdate from node: pre_model_hook\n================================ Human Message =================================\n\nWhat's it known for?\n================================== Ai Message ==================================", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "New York City is known for a variety of iconic landmarks, cultural institutions, and vibrant neighborhoods. Some of the most notable features include:\n\n1. **Statue of Liberty**: A symbol of freedom and democracy, located on Liberty Island.\n2. **Times Square**: Known for its bright lights, Broadway theaters, and bustling atmosphere.\n3. **Central Park**: A large public park offering a natural retreat in the middle of the city.\n4. **Empire State Building**: An iconic skyscraper offering panoramic views of the city.\n5. **Broadway**: Famous for its world-class theater productions.\n6. **Wall Street**: The financial hub of the United States.\n7. **Museums**: Including the Metropolitan Museum of Art, Museum of Modern Art (MoMA), and the American Museum of Natural History.\n8. **Diverse Cuisine**: A melting pot of cultures offering a wide range of culinary experiences.\n9. **Cultural Diversity**: A rich tapestry of cultures and communities from around the world.\n10. **Fashion**: A global fashion capital, hosting events like New York Fashion Week.\n\nThese are just a few highlights of what makes New York City a unique and vibrant place.\n================================ Human Message =================================\n\nwhere can i find the best bagel?\n\nUpdate from node: agent\n================================== Ai Message ==================================\n\nNew York City is famous for its bagels, and there are several places renowned for serving some of the best. Here are a few top spots where you can find excellent bagels in NYC:\n\n1. **Ess-a-Bagel**: Known for their large, chewy bagels with a variety of spreads and toppings.\n2. **Russ & Daughters**: A classic spot offering traditional bagels with high-quality smoked fish and cream cheese.\n3. **H&H Bagels**: Famous for their fresh, hand-rolled bagels.\n4. **Murray’s Bagels**: Offers a wide selection of bagels and spreads, with a no-toasting policy to preserve freshness.\n5. **Absolute Bagels**: Known for their authentic, fluffy bagels and a variety of cream cheese options.\n6. **Tompkins Square Bagels**: Offers creative bagel sandwiches and a wide range of spreads.\n7. **Bagel Hole**: Known for their smaller, denser bagels with a crispy crust.\n\nEach of these places has its own unique style and flavor, so it might be worth trying a few to find your personal favorite!\n```\nYou can see that the `pre_model_hook` node now only returned the last 3 messages, as expected. However, the existing message history is untouched:\n\n```python\nupdated_messages = graph.get_state(config).values[\"messages\"]\nassert [(m.type, m.content) for m in updated_messages[: len(messages)]] == [\n    (m.type, m.content) for m in messages\n]\n```\n\n## Overwrite the original message history\n\nLet's now change the `pre_model_hook` to **overwrite** the message history in the graph state. To do this, we’ll return the updated messages under `messages` key. We’ll also include a special `RemoveMessage(REMOVE_ALL_MESSAGES)` object, which tells `create_react_agent` to remove previous messages from the graph state:\n\n```python hl_lines=\"16 23\"\nfrom langchain_core.messages import RemoveMessage\nfrom langgraph.graph.message import REMOVE_ALL_MESSAGES\n\ndef pre_model_hook(state):\n    trimmed_messages = trim_messages(\n        state[\"messages\"],\n        strategy=\"last\",\n        token_counter=count_tokens_approximately,\n        max_tokens=384,\n        start_on=\"human\",\n        end_on=(\"human\", \"tool\"),\n    )\n    # NOTE that we're now returning the messages under the `messages` key\n    # We also remove the existing messages in the history to ensure we're overwriting the history\n    return {\"messages\": [RemoveMessage(REMOVE_ALL_MESSAGES)] + trimmed_messages}\n\ncheckpointer = InMemorySaver()\ngraph = create_react_agent(\n    model,\n    tools,\n    pre_model_hook=pre_model_hook,\n    checkpointer=checkpointer,\n)\n```\n\nNow let's run the agent with the same queries as before:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\ninputs = {\"messages\": [(\"user\", \"What's the weather in NYC?\")]}\nresult = graph.invoke(inputs, config=config)\n\ninputs = {\"messages\": [(\"user\", \"What's it known for?\")]}\nresult = graph.invoke(inputs, config=config)\nmessages = result[\"messages\"]\n\ninputs = {\"messages\": [(\"user\", \"where can i find the best bagel?\")]}\nprint_stream(\n    graph.stream(inputs, config=config, stream_mode=\"updates\"),\n    output_messages_key=\"messages\",\n)\n```\n```output\nUpdate from node: pre_model_hook\n================================ Remove Message ================================\n\n================================ Human Message =================================\n\nWhat's it known for?\n================================== Ai Message ==================================\n\nNew York City is known for a variety of iconic landmarks, cultural institutions, and vibrant neighborhoods. Some of the most notable features include:\n\n1. **Statue of Liberty**: A symbol of freedom and democracy, located on Liberty Island.\n2. **Times Square**: Known for its bright lights, Broadway theaters, and bustling atmosphere.\n3. **Central Park**: A large public park offering a natural oasis amidst the urban environment.\n4. **Empire State Building**: An iconic skyscraper offering panoramic views of the city.\n5. **Broadway**: Famous for its world-class theater productions and musicals.\n6. **Wall Street**: The financial hub of the United States, located in the Financial District.\n7. **Museums**: Including the Metropolitan Museum of Art, Museum of Modern Art (MoMA), and the American Museum of Natural History.\n8. **Diverse Cuisine**: A melting pot of cultures, offering a wide range of international foods.\n9. **Cultural Diversity**: Known for its diverse population and vibrant cultural scene.\n10. **Brooklyn Bridge**: An iconic suspension bridge connecting Manhattan and Brooklyn.\n\nThese are just a few highlights, as NYC is a city with endless attractions and activities.\n================================ Human Message =================================\n\nwhere can i find the best bagel?\n\nUpdate from node: agent\n================================== Ai Message ==================================\n\nNew York City is famous for its bagels, and there are several places renowned for serving some of the best. Here are a few top spots where you can find delicious bagels in NYC:\n\n1. **Ess-a-Bagel**: Known for its large, chewy bagels and a wide variety of spreads and toppings. Locations in Midtown and the East Village.\n\n2. **Russ & Daughters**: A historic appetizing store on the Lower East Side, famous for its bagels with lox and cream cheese.\n\n3. **Absolute Bagels**: Located on the Upper West Side, this spot is popular for its fresh, fluffy bagels.\n\n4. **Murray’s Bagels**: Known for its traditional, hand-rolled bagels. Located in Greenwich Village.\n\n5. **Tompkins Square Bagels**: Offers a wide selection of bagels and creative cream cheese flavors. Located in the East Village.\n\n6. **Bagel Hole**: A small shop in Park Slope, Brooklyn, known for its classic, no-frills bagels.\n\n7. **Leo’s Bagels**: Located in the Financial District, known for its authentic New York-style bagels.\n\nEach of these places has its own unique style and flavor, so it might be worth trying a few to find your personal favorite!\n```\nYou can see that the `pre_model_hook` node returned the last 3 messages again. However, this time, the message history is modified in the graph state as well:\n\n```python\nupdated_messages = graph.get_state(config).values[\"messages\"]\nassert (\n    # First 2 messages in the new history are the same as last 2 messages in the old\n    [(m.type, m.content) for m in updated_messages[:2]]\n    == [(m.type, m.content) for m in messages[-2:]]\n)\n```\n\n## Summarizing message history\n\nFinally, let's apply a different strategy for managing message history — summarization. Just as with trimming, you can choose to keep original message history unmodified or overwrite it. The example below will only show the former.\n\nWe will use the [`SummarizationNode`](https://langchain-ai.github.io/langmem/guides/summarization/#using-summarizationnode) from the prebuilt `langmem` library. Once the message history reaches the token limit, the summarization node will summarize earlier messages to make sure they fit into `max_tokens`.\n\n```python hl_lines=\"1 20 28 29\"\nfrom langmem.short_term import SummarizationNode\nfrom langgraph.prebuilt.chat_agent_executor import AgentState\nfrom typing import Any\n\nmodel = ChatOpenAI(model=\"gpt-4o\")\nsummarization_model = model.bind(max_tokens=128)\n\nsummarization_node = SummarizationNode(\n    token_counter=count_tokens_approximately,\n    model=summarization_model,\n    max_tokens=384,\n    max_summary_tokens=128,\n    output_messages_key=\"llm_input_messages\",\n)\n\nclass State(AgentState):\n    # NOTE: we're adding this key to keep track of previous summary information\n    # to make sure we're not summarizing on every LLM call\n    context: dict[str, Any]\n\ncheckpointer = InMemorySaver()\ngraph = create_react_agent(\n    # limit the output size to ensure consistent behavior\n    model.bind(max_tokens=256),\n    tools,\n    pre_model_hook=summarization_node,\n    state_schema=State,\n    checkpointer=checkpointer,\n)\n```\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\ninputs = {\"messages\": [(\"user\", \"What's the weather in NYC?\")]}\n\nresult = graph.invoke(inputs, config=config)\n\ninputs = {\"messages\": [(\"user\", \"What's it known for?\")]}\nresult = graph.invoke(inputs, config=config)\n\ninputs = {\"messages\": [(\"user\", \"where can i find the best bagel?\")]}\nprint_stream(graph.stream(inputs, config=config, stream_mode=\"updates\"))\n```\n```output\nUpdate from node: pre_model_hook\n================================ System Message ================================\n\nSummary of the conversation so far: The user asked about the current weather in New York City. In response, the assistant provided information that it might be cloudy, with a chance of rain, and temperatures reaching up to 80 degrees.\n================================ Human Message =================================\n\nWhat's it known for?\n================================== Ai Message ==================================\n\nNew York City, often referred to as NYC, is known for its:\n\n1. **Landmarks and Iconic Sites**:\n   - **Statue of Liberty**: A symbol of freedom and democracy.\n   - **Central Park**: A vast green oasis in the middle of the city.\n   - **Empire State Building**: Once the tallest building in the world, offering stunning views of the city.\n   - **Times Square**: Known for its bright lights and bustling atmosphere.\n\n2. **Cultural Institutions**:\n   - **Broadway**: Renowned for theatrical performances and musicals.\n   - **Metropolitan Museum of Art** and **Museum of Modern Art (MoMA)**: World-class art collections.\n   - **American Museum of Natural History**: Known for its extensive exhibits ranging from dinosaurs to space exploration.\n   \n3. **Diverse Neighborhoods and Cuisine**:\n   - NYC is famous for having a melting pot of cultures, reflected in neighborhoods like Chinatown, Little Italy, and Harlem.\n   - The city offers a wide range of international cuisines, from street food to high-end dining.\n\n4. **Financial District**:\n   - Home to Wall Street, the New York Stock Exchange (NYSE), and other major financial institutions.\n\n5. **Media and Entertainment**:\n   - Major hub for television, film, and media, with numerous studios and networks based there.\n\n6. **Fashion**:\n   - Often referred to as one of the \"Big Four\" fashion capitals, hosting events like New York Fashion Week.\n\n7. **Sports**:\n   - Known for its passionate sports culture with teams like the Yankees (MLB), Mets (MLB), Knicks (NBA), and Rangers (NHL).\n\nThese elements, among others, contribute to NYC's reputation as a vibrant and dynamic city.\n================================ Human Message =================================\n\nwhere can i find the best bagel?\n\nUpdate from node: agent\n================================== Ai Message ==================================\n\nFinding the best bagel in New York City can be subjective, as there are many beloved spots across the city. However, here are some renowned bagel shops you might want to try:\n\n1. **Ess-a-Bagel**: Known for its chewy and flavorful bagels, located in Midtown and Stuyvesant Town.\n\n2. **Bagel Hole**: A favorite for traditionalists, offering classic and dense bagels, located in Park Slope, Brooklyn.\n\n3. **Russ & Daughters**: A legendary appetizing store on the Lower East Side, famous for their bagels with lox.\n\n4. **Murray’s Bagels**: Located in Greenwich Village, known for their fresh and authentic New York bagels.\n\n5. **Absolute Bagels**: Located on the Upper West Side, they’re known for their fresh, fluffy bagels with a variety of spreads.\n\n6. **Tompkins Square Bagels**: In the East Village, famous for their creative cream cheese options and fresh bagels.\n\n7. **Zabar’s**: A landmark on the Upper West Side known for their classic bagels and smoked fish.\n\nEach of these spots offers a unique take on the classic New York bagel experience, and trying several might be the best way to discover your personal favorite!\n```\nYou can see that the earlier messages have now been replaced with the summary of the earlier conversation!\n\n---\nhow-tos/autogen-integration-functional.ipynb\n---\n\n# How to integrate LangGraph (functional API) with AutoGen, CrewAI, and other frameworks\n\nLangGraph is a framework for building agentic and multi-agent applications. LangGraph can be easily integrated with other agent frameworks.\n\nThe primary reasons you might want to integrate LangGraph with other agent frameworks:\n\n- create <a href=\"../../concepts/multi_agent\">multi-agent systems</a> where individual agents are built with different frameworks\n- leverage LangGraph to add features like <a href=\"../../concepts/persistence\">persistence</a>, <a href=\"../../concepts/streaming\">streaming</a>, <a href=\"../../concepts/memory\">short and long-term memory</a> and more\n\nThe simplest way to integrate agents from other frameworks is by calling those agents inside a LangGraph <a href=\"../../concepts/low_level/#nodes\">node</a>:\n\n```python\nimport autogen\nfrom langgraph.func import entrypoint, task\n\nautogen_agent = autogen.AssistantAgent(name=\"assistant\", ...)\nuser_proxy = autogen.UserProxyAgent(name=\"user_proxy\", ...)\n\n@task\ndef call_autogen_agent(messages):\n    response = user_proxy.initiate_chat(\n        autogen_agent,\n        message=messages[-1],\n        ...\n    )\n    ...\n\n@entrypoint()\ndef workflow(messages):\n    response = call_autogen_agent(messages).result()\n    return response\n\nworkflow.invoke(\n    [\n        {\n            \"role\": \"user\",\n            \"content\": \"Find numbers between 10 and 30 in fibonacci sequence\",\n        }\n    ]\n)\n```\n\nIn this guide we show how to build a LangGraph chatbot that integrates with AutoGen, but you can follow the same approach with other frameworks.\n\n## Setup\n\n```python\n%pip install autogen langgraph\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n```output\nOPENAI_API_KEY:  ········\n```\n## Define AutoGen agent\n\nHere we define our AutoGen agent. Adapted from official tutorial [here](https://github.com/microsoft/autogen/blob/0.2/notebook/agentchat_web_info.ipynb).\n\n```python\nimport autogen\nimport os\n\nconfig_list = [{\"model\": \"gpt-4o\", \"api_key\": os.environ[\"OPENAI_API_KEY\"]}]\n\nllm_config = {\n    \"timeout\": 600,\n    \"cache_seed\": 42,\n    \"config_list\": config_list,\n    \"temperature\": 0,\n}\n\nautogen_agent = autogen.AssistantAgent(\n    name=\"assistant\",\n    llm_config=llm_config,\n)\n\nuser_proxy = autogen.UserProxyAgent(\n    name=\"user_proxy\",\n    human_input_mode=\"NEVER\",\n    max_consecutive_auto_reply=10,\n    is_termination_msg=lambda x: x.get(\"content\", \"\").rstrip().endswith(\"TERMINATE\"),\n    code_execution_config={\n        \"work_dir\": \"web\",\n        \"use_docker\": False,\n    },  # Please set use_docker=True if docker is available to run the generated code. Using docker is safer than running the generated code directly.\n    llm_config=llm_config,\n    system_message=\"Reply TERMINATE if the task has been solved at full satisfaction. Otherwise, reply CONTINUE, or the reason why the task is not solved yet.\",\n)\n```\n\n---\n\n## Create the workflow\n\nWe will now create a LangGraph chatbot graph that calls AutoGen agent.\n\n```python\nfrom langchain_core.messages import convert_to_openai_messages, BaseMessage\nfrom langgraph.func import entrypoint, task\nfrom langgraph.graph import add_messages\nfrom langgraph.checkpoint.memory import InMemorySaver\n\n@task\ndef call_autogen_agent(messages: list[BaseMessage]):\n    # convert to openai-style messages\n    messages = convert_to_openai_messages(messages)\n    response = user_proxy.initiate_chat(\n        autogen_agent,\n        message=messages[-1],\n        # pass previous message history as context\n        carryover=messages[:-1],\n    )\n    # get the final response from the agent\n    content = response.chat_history[-1][\"content\"]\n    return {\"role\": \"assistant\", \"content\": content}\n\n# add short-term memory for storing conversation history\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(messages: list[BaseMessage], previous: list[BaseMessage]):\n    messages = add_messages(previous or [], messages)\n    response = call_autogen_agent(messages).result()\n    return entrypoint.final(value=response, save=add_messages(messages, response))\n```\n\n## Run the graph\n\nWe can now run the graph.\n\n```python hl_lines=\"2 11\"\n# pass the thread ID to persist agent outputs for future interactions\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\nfor chunk in workflow.stream(\n    [\n        {\n            \"role\": \"user\",\n            \"content\": \"Find numbers between 10 and 30 in fibonacci sequence\",\n        }\n    ],\n    config,\n):\n    print(chunk)\n```\n```output\nuser_proxy (to assistant):\n\nFind numbers between 10 and 30 in fibonacci sequence\n\n--------------------------------------------------------------------------------\nassistant (to user_proxy):\n\nTo find numbers between 10 and 30 in the Fibonacci sequence, we can generate the Fibonacci sequence and check which numbers fall within this range. Here's a plan:\n\n1. Generate Fibonacci numbers starting from 0.\n2. Continue generating until the numbers exceed 30.\n3. Collect and print the numbers that are between 10 and 30.\n\nLet's implement this in Python:\n\n\\`\\`\\`python\n# filename: fibonacci_range.py\n\ndef fibonacci_sequence():\n    a, b = 0, 1\n    while a <= 30:\n        if 10 <= a <= 30:\n            print(a)\n        a, b = b, a + b\n\nfibonacci_sequence()\n\\`\\`\\`\n\nThis script will print the Fibonacci numbers between 10 and 30. Please execute the code to see the result.\n\n--------------------------------------------------------------------------------\n\n>>>>>>>> EXECUTING CODE BLOCK 0 (inferred language is python)...\nuser_proxy (to assistant):\n\nexitcode: 0 (execution succeeded)\nCode output: \n13\n21\n\n--------------------------------------------------------------------------------\nassistant (to user_proxy):\n\nThe Fibonacci numbers between 10 and 30 are 13 and 21.\n\nThese numbers are part of the Fibonacci sequence, which is generated by adding the two preceding numbers to get the next number, starting from 0 and 1.\n\nThe sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n\nAs you can see, 13 and 21 are the only numbers in this sequence that fall between 10 and 30.\n\nTERMINATE\n\n--------------------------------------------------------------------------------\n{'call_autogen_agent': {'role': 'assistant', 'content': 'The Fibonacci numbers between 10 and 30 are 13 and 21. \\n\\nThese numbers are part of the Fibonacci sequence, which is generated by adding the two preceding numbers to get the next number, starting from 0 and 1. \\n\\nThe sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\\n\\nAs you can see, 13 and 21 are the only numbers in this sequence that fall between 10 and 30.\\n\\nTERMINATE'}}\n{'workflow': {'role': 'assistant', 'content': 'The Fibonacci numbers between 10 and 30 are 13 and 21. \\n\\nThese numbers are part of the Fibonacci sequence, which is generated by adding the two preceding numbers to get the next number, starting from 0 and 1. \\n\\nThe sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\\n\\nAs you can see, 13 and 21 are the only numbers in this sequence that fall between 10 and 30.\\n\\nTERMINATE'}}\n```\nSince we're leveraging LangGraph's [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) features we can now continue the conversation using the same thread ID -- LangGraph will automatically pass previous history to the AutoGen agent:\n\n```python hl_lines=\"8\"\nfor chunk in workflow.stream(\n    [\n        {\n            \"role\": \"user\",\n            \"content\": \"Multiply the last number by 3\",\n        }\n    ],\n    config,\n):\n    print(chunk)\n```\n```output\nuser_proxy (to assistant):\n\nMultiply the last number by 3\nContext: \nFind numbers between 10 and 30 in fibonacci sequence\nThe Fibonacci numbers between 10 and 30 are 13 and 21.\n\nThese numbers are part of the Fibonacci sequence, which is generated by adding the two preceding numbers to get the next number, starting from 0 and 1.\n\nThe sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n\nAs you can see, 13 and 21 are the only numbers in this sequence that fall between 10 and 30.\n\nTERMINATE\n\n--------------------------------------------------------------------------------\nassistant (to user_proxy):\n\nThe last number in the Fibonacci sequence between 10 and 30 is 21. Multiplying 21 by 3 gives:\n\n21 * 3 = 63\n\nTERMINATE\n\n--------------------------------------------------------------------------------\n{'call_autogen_agent': {'role': 'assistant', 'content': 'The last number in the Fibonacci sequence between 10 and 30 is 21. Multiplying 21 by 3 gives:\\n\\n21 * 3 = 63\\n\\nTERMINATE'}}\n{'workflow': {'role': 'assistant', 'content': 'The last number in the Fibonacci sequence between 10 and 30 is 21. Multiplying 21 by 3 gives:\\n\\n21 * 3 = 63\\n\\nTERMINATE'}}\n```\n\n---\nhow-tos/many-tools.ipynb\n---\n\n# How to handle large numbers of tools\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Prerequisites</p>\n    <p>\n        This guide assumes familiarity with the following:\n        <ul>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#tools\">\n                    Tools\n                </a>\n            </li>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#chat-models/\">\n                    Chat Models\n                </a>\n            </li>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#embedding-models\">\n                    Embedding Models\n                </a>\n            </li>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#vector-stores\">\n                    Vectorstores\n                </a>\n            </li>   \n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#documents\">\n                    Document\n                </a>\n            </li>\n        </ul>\n    </p>\n</div>\n\nThe subset of available tools to call is generally at the discretion of the model (although many providers also enable the user to [specify or constrain the choice of tool](https://python.langchain.com/docs/how_to/tool_choice/)). As the number of available tools grows, you may want to limit the scope of the LLM's selection, to decrease token consumption and to help manage sources of error in LLM reasoning.\n\nHere we will demonstrate how to dynamically adjust the tools available to a model. Bottom line up front: like [RAG](https://python.langchain.com/docs/concepts/#retrieval) and similar methods, we prefix the model invocation by retrieving over available tools. Although we demonstrate one implementation that searches over tool descriptions, the details of the tool selection can be customized as needed.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys\n\n```shell\npip install --quiet -U langgraph langchain_openai numpy\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\n## Define the tools\n\nLet's consider a toy example in which we have one tool for each publicly traded company in the [S&P 500 index](https://en.wikipedia.org/wiki/S%26P_500). Each tool fetches company-specific information based on the year provided as a parameter.\n\nWe first construct a registry that associates a unique identifier with a schema for each tool. We will represent the tools using JSON schema, which can be bound directly to chat models supporting tool calling.\n\n```python\nimport re\nimport uuid\n\nfrom langchain_core.tools import StructuredTool\n\ndef create_tool(company: str) -> dict:\n    \"\"\"Create schema for a placeholder tool.\"\"\"\n    # Remove non-alphanumeric characters and replace spaces with underscores for the tool name\n    formatted_company = re.sub(r\"[^\\w\\s]\", \"\", company).replace(\" \", \"_\")\n\ndef company_tool(year: int) -> str:\n        # Placeholder function returning static revenue information for the company and year\n        return f\"{company} had revenues of $100 in {year}.\"\n\nreturn StructuredTool.from_function(\n        company_tool,\n        name=formatted_company,\n        description=f\"Information about {company}\",\n    )\n\n# Abbreviated list of S&P 500 companies for demonstration\ns_and_p_500_companies = [\n    \"3M\",\n    \"A.O. Smith\",\n    \"Abbott\",\n    \"Accenture\",\n    \"Advanced Micro Devices\",\n    \"Yum! Brands\",\n    \"Zebra Technologies\",\n    \"Zimmer Biomet\",\n    \"Zoetis\",\n]\n\n# Create a tool for each company and store it in a registry with a unique UUID as the key\ntool_registry = {\n    str(uuid.uuid4()): create_tool(company) for company in s_and_p_500_companies\n}\n```\n\n## Define the graph\n\n### Tool selection\n\nWe will construct a node that retrieves a subset of available tools given the information in the state-- such as a recent user message. In general, the full scope of [retrieval solutions](https://python.langchain.com/docs/concepts/#retrieval) are available for this step. As a simple solution, we index embeddings of tool descriptions in a vector store, and associate user queries to tools via semantic search.\n\n```python\nfrom langchain_core.documents import Document\nfrom langchain_core.vectorstores import InMemoryVectorStore\nfrom langchain_openai import OpenAIEmbeddings\n\ntool_documents = [\n    Document(\n        page_content=tool.description,\n        id=id,\n        metadata={\"tool_name\": tool.name},\n    )\n    for id, tool in tool_registry.items()\n]\n\nvector_store = InMemoryVectorStore(embedding=OpenAIEmbeddings())\ndocument_ids = vector_store.add_documents(tool_documents)\n```\n\n### Incorporating with an agent\n\nWe will use a typical React agent graph (e.g., as used in the [quickstart](https://langchain-ai.github.io/langgraph/tutorials/introduction/#part-2-enhancing-the-chatbot-with-tools)), with some modifications:\n\n- We add a `selected_tools` key to the state, which stores our selected subset of tools;\n- We set the entry point of the graph to be a `select_tools` node, which populates this element of the state;\n- We bind the selected subset of tools to the chat model within the `agent` node.\n\n```python\nfrom typing import Annotated", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "from langchain_openai import ChatOpenAI\nfrom typing_extensions import TypedDict\n\nfrom langgraph.graph import StateGraph, START\nfrom langgraph.graph.message import add_messages\nfrom langgraph.prebuilt import ToolNode, tools_condition\n\n# Define the state structure using TypedDict.\n# It includes a list of messages (processed by add_messages)\n# and a list of selected tool IDs.\nclass State(TypedDict):\n    messages: Annotated[list, add_messages]\n    selected_tools: list[str]\n\nbuilder = StateGraph(State)\n\n# Retrieve all available tools from the tool registry.\ntools = list(tool_registry.values())\nllm = ChatOpenAI()\n\n# The agent function processes the current state\n# by binding selected tools to the LLM.\ndef agent(state: State):\n    # Map tool IDs to actual tools\n    # based on the state's selected_tools list.\n    selected_tools = [tool_registry[id] for id in state[\"selected_tools\"]]\n    # Bind the selected tools to the LLM for the current interaction.\n    llm_with_tools = llm.bind_tools(selected_tools)\n    # Invoke the LLM with the current messages and return the updated message list.\n    return {\"messages\": [llm_with_tools.invoke(state[\"messages\"])]}\n\n# The select_tools function selects tools based on the user's last message content.\ndef select_tools(state: State):\n    last_user_message = state[\"messages\"][-1]\n    query = last_user_message.content\n    tool_documents = vector_store.similarity_search(query)\n    return {\"selected_tools\": [document.id for document in tool_documents]}\n\nbuilder.add_node(\"agent\", agent)\nbuilder.add_node(\"select_tools\", select_tools)\n\ntool_node = ToolNode(tools=tools)\nbuilder.add_node(\"tools\", tool_node)\n\nbuilder.add_conditional_edges(\"agent\", tools_condition, path_map=[\"tools\", \"__end__\"])\nbuilder.add_edge(\"tools\", \"agent\")\nbuilder.add_edge(\"select_tools\", \"agent\")\nbuilder.add_edge(START, \"select_tools\")\ngraph = builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ntry:\n    display(Image(graph.get_graph().draw_mermaid_png()))\nexcept Exception:\n    # This requires some extra dependencies and is optional\n    pass\n```\n\n<p>\n\n</p>\n\n```python\nuser_input = \"Can you give me some information about AMD in 2022?\"\n\nresult = graph.invoke({\"messages\": [(\"user\", user_input)]})\n```\n\n```python\nprint(result[\"selected_tools\"])\n```\n```output\n['ab9c0d59-3d16-448d-910c-73cf10a26020', 'f5eff8f6-7fb9-47b6-b54f-19872a52db84', '2962e168-9ef4-48dc-8b7c-9227e7956d39', '24a9fb82-19fe-4a88-944e-47bc4032e94a']\n```\n\n```python\nfor message in result[\"messages\"]:\n    message.pretty_print()\n```\n```output\n================================ Human Message =================================\n\nCan you give me some information about AMD in 2022?\n================================== Ai Message ==================================\nTool Calls:\n  Advanced_Micro_Devices (call_CRxQ0oT7NY7lqf35DaRNTJ35)\n Call ID: call_CRxQ0oT7NY7lqf35DaRNTJ35\n  Args:\n    year: 2022\n================================= Tool Message =================================\nName: Advanced_Micro_Devices\n\nAdvanced Micro Devices had revenues of $100 in 2022.\n================================== Ai Message ==================================\n\nIn 2022, Advanced Micro Devices (AMD) had revenues of $100.\n```\n## Repeating tool selection\n\nTo manage errors from incorrect tool selection, we could revisit the `select_tools` node. One option for implementing this is to modify `select_tools` to generate the vector store query using all messages in the state (e.g., with a chat model) and add an edge routing from `tools` to `select_tools`.\n\nWe implement this change below. For demonstration purposes, we simulate an error in the initial tool selection by adding a `hack_remove_tool_condition` to the `select_tools` node, which removes the correct tool on the first iteration of the node. Note that on the second iteration, the agent finishes the run as it has access to the correct tool.\n\n<div class=\"admonition note\">\n    <p class=\"admonition-title\">Using Pydantic with LangChain</p>\n    <p>\n        This notebook uses Pydantic v2 <code>BaseModel</code>, which requires <code>langchain-core >= 0.3</code>. Using <code>langchain-core < 0.3</code> will result in errors due to mixing of Pydantic v1 and v2 <code>BaseModels</code>.\n    </p>\n</div>\n\n```python\nfrom langchain_core.messages import HumanMessage, SystemMessage, ToolMessage\nfrom langgraph.pregel.retry import RetryPolicy\n\nfrom pydantic import BaseModel, Field\n\nclass QueryForTools(BaseModel):\n    \"\"\"Generate a query for additional tools.\"\"\"\n\nquery: str = Field(..., description=\"Query for additional tools.\")\n\ndef select_tools(state: State):\n    \"\"\"Selects tools based on the last message in the conversation state.\n\nIf the last message is from a human, directly uses the content of the message\n    as the query. Otherwise, constructs a query using a system message and invokes\n    the LLM to generate tool suggestions.\n    \"\"\"\n    last_message = state[\"messages\"][-1]\n    hack_remove_tool_condition = False  # Simulate an error in the first tool selection\n\nif isinstance(last_message, HumanMessage):\n        query = last_message.content\n        hack_remove_tool_condition = True  # Simulate wrong tool selection\n    else:\n        assert isinstance(last_message, ToolMessage)\n        system = SystemMessage(\n            \"Given this conversation, generate a query for additional tools. \"\n            \"The query should be a short string containing what type of information \"\n            \"is needed. If no further information is needed, \"\n            \"set more_information_needed False and populate a blank string for the query.\"\n        )\n        input_messages = [system] + state[\"messages\"]\n        response = llm.bind_tools([QueryForTools], tool_choice=True).invoke(\n            input_messages\n        )\n        query = response.tool_calls[0][\"args\"][\"query\"]\n\n# Search the tool vector store using the generated query\n    tool_documents = vector_store.similarity_search(query)\n    if hack_remove_tool_condition:\n        # Simulate error by removing the correct tool from the selection\n        selected_tools = [\n            document.id\n            for document in tool_documents\n            if document.metadata[\"tool_name\"] != \"Advanced_Micro_Devices\"\n        ]\n    else:\n        selected_tools = [document.id for document in tool_documents]\n    return {\"selected_tools\": selected_tools}\n\ngraph_builder = StateGraph(State)\ngraph_builder.add_node(\"agent\", agent)\ngraph_builder.add_node(\n    \"select_tools\", select_tools, retry_policy=RetryPolicy(max_attempts=3)\n)\n\ntool_node = ToolNode(tools=tools)\ngraph_builder.add_node(\"tools\", tool_node)\n\ngraph_builder.add_conditional_edges(\n    \"agent\",\n    tools_condition,\n)\ngraph_builder.add_edge(\"tools\", \"select_tools\")\ngraph_builder.add_edge(\"select_tools\", \"agent\")\ngraph_builder.add_edge(START, \"select_tools\")\ngraph = graph_builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ntry:\n    display(Image(graph.get_graph().draw_mermaid_png()))\nexcept Exception:\n    # This requires some extra dependencies and is optional\n    pass\n```\n\n<p>\n\n</p>\n\n```python\nuser_input = \"Can you give me some information about AMD in 2022?\"\n\nresult = graph.invoke({\"messages\": [(\"user\", user_input)]})\n```\n\n```python\nfor message in result[\"messages\"]:\n    message.pretty_print()\n```\n```output\n================================ Human Message =================================\n\nCan you give me some information about AMD in 2022?\n================================== Ai Message ==================================\nTool Calls:\n  Accenture (call_qGmwFnENwwzHOYJXiCAaY5Mx)\n Call ID: call_qGmwFnENwwzHOYJXiCAaY5Mx\n  Args:\n    year: 2022\n================================= Tool Message =================================\nName: Accenture\n\nAccenture had revenues of $100 in 2022.\n================================== Ai Message ==================================\nTool Calls:\n  Advanced_Micro_Devices (call_u9e5UIJtiieXVYi7Y9GgyDpn)\n Call ID: call_u9e5UIJtiieXVYi7Y9GgyDpn\n  Args:\n    year: 2022\n================================= Tool Message =================================\nName: Advanced_Micro_Devices\n\nAdvanced Micro Devices had revenues of $100 in 2022.\n================================== Ai Message ==================================\n\nIn 2022, AMD had revenues of $100.\n```\n## Next steps\n\nThis guide provides a minimal implementation for dynamically selecting tools. There is a host of possible improvements and optimizations:\n\n- **Repeating tool selection**: Here, we repeated tool selection by modifying the `select_tools` node. Another option is to equip the agent with a `reselect_tools` tool, allowing it to re-select tools at its discretion.\n- **Optimizing tool selection**: In general, the full scope of [retrieval solutions](https://python.langchain.com/docs/concepts/#retrieval) are available for tool selection. Additional options include:\n  - Group tools and retrieve over groups;\n  - Use a chat model to select tools or groups of tool.\n\n---\nhow-tos/react-agent-from-scratch.ipynb\n---\n\n# How to create a ReAct agent from scratch\n\n!!! info \"Prerequisites\"\n    This guide assumes familiarity with the following:\n    \n    - <a href=\"../../concepts/agentic_concepts/#tool-calling-agent\">Tool calling agent</a>\n    - [Chat Models](https://python.langchain.com/docs/concepts/chat_models/)\n    - [Messages](https://python.langchain.com/docs/concepts/messages/)\n    - <a href=\"../../concepts/low_level/\">LangGraph Glossary</a>\n\nUsing the prebuilt ReAct agent [create_react_agent][langgraph.prebuilt.chat_agent_executor.create_react_agent] is a great way to get started, but sometimes you might want more control and customization. In those cases, you can create a custom ReAct agent. This guide shows how to implement ReAct agent from scratch using LangGraph.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys:\n\n```shell\npip install -U langgraph langchain-openai\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n     <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for better debugging</p>\n     <p style=\"padding-top: 5px;\">\n         Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM aps built with LangGraph — read more about how to get started in the <a href=\"https://docs.smith.langchain.com\">docs</a>. \n     </p>\n </div>\n\n## Create ReAct agent\n\nNow that you have installed the required packages and set your environment variables, we can code our ReAct agent!\n\n### Define graph state\n\nWe are going to define the most basic ReAct state in this example, which will just contain a list of messages.\n\nFor your specific use case, feel free to add any other state keys that you need.\n\n```python\nfrom typing import (\n    Annotated,\n    Sequence,\n    TypedDict,\n)\nfrom langchain_core.messages import BaseMessage\nfrom langgraph.graph.message import add_messages\n\nclass AgentState(TypedDict):\n    \"\"\"The state of the agent.\"\"\"\n\n# add_messages is a reducer\n    # See https://langchain-ai.github.io/langgraph/concepts/low_level/#reducers\n    messages: Annotated[Sequence[BaseMessage], add_messages]\n```\n\n### Define model and tools\n\nNext, let's define the tools and model we will use for our example.\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.tools import tool\n\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\n\n@tool\ndef get_weather(location: str):\n    \"\"\"Call to get the weather from a specific location.\"\"\"\n    # This is a placeholder for the actual implementation\n    # Don't let the LLM know this though 😊\n    if any([city in location.lower() for city in [\"sf\", \"san francisco\"]]):\n        return \"It's sunny in San Francisco, but you better look out if you're a Gemini 😈.\"\n    else:\n        return f\"I am not sure what the weather is in {location}\"\n\ntools = [get_weather]\n\nmodel = model.bind_tools(tools)\n```\n\n### Define nodes and edges\n\nNext let's define our nodes and edges. In our basic ReAct agent there are only two nodes, one for calling the model and one for using tools, however you can modify this basic structure to work better for your use case. The tool node we define here is a simplified version of the prebuilt [`ToolNode`](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/), which has some additional features.\n\nPerhaps you want to add a node for [adding structured output](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/) or a node for executing some external action (sending an email, adding a calendar event, etc.). Maybe you just want to change the way the `call_model` node works and how `should_continue` decides whether to call tools - the possibilities are endless and LangGraph makes it easy to customize this basic structure for your specific use case.\n\n```python\nimport json\nfrom langchain_core.messages import ToolMessage, SystemMessage\nfrom langchain_core.runnables import RunnableConfig\n\ntools_by_name = {tool.name: tool for tool in tools}\n\n# Define our tool node\ndef tool_node(state: AgentState):\n    outputs = []\n    for tool_call in state[\"messages\"][-1].tool_calls:\n        tool_result = tools_by_name[tool_call[\"name\"]].invoke(tool_call[\"args\"])\n        outputs.append(\n            ToolMessage(\n                content=json.dumps(tool_result),\n                name=tool_call[\"name\"],\n                tool_call_id=tool_call[\"id\"],\n            )\n        )\n    return {\"messages\": outputs}\n\n# Define the node that calls the model\ndef call_model(\n    state: AgentState,\n    config: RunnableConfig,\n):\n    # this is similar to customizing the create_react_agent with 'prompt' parameter, but is more flexible\n    system_prompt = SystemMessage(\n        \"You are a helpful AI assistant, please respond to the users query to the best of your ability!\"\n    )\n    response = model.invoke([system_prompt] + state[\"messages\"], config)\n    # We return a list, because this will get added to the existing list\n    return {\"messages\": [response]}\n\n# Define the conditional edge that determines whether to continue or not\ndef should_continue(state: AgentState):\n    messages = state[\"messages\"]\n    last_message = messages[-1]\n    # If there is no function call, then we finish\n    if not last_message.tool_calls:\n        return \"end\"\n    # Otherwise if there is, we continue\n    else:\n        return \"continue\"\n```\n\n### Define the graph\n\nNow that we have defined all of our nodes and edges, we can define and compile our graph. Depending on if you have added more nodes or different edges, you will need to edit this to fit your specific use case.\n\n```python\nfrom langgraph.graph import StateGraph, END\n\n# Define a new graph\nworkflow = StateGraph(AgentState)\n\n# Define the two nodes we will cycle between\nworkflow.add_node(\"agent\", call_model)\nworkflow.add_node(\"tools\", tool_node)\n\n# Set the entrypoint as `agent`\n# This means that this node is the first one called\nworkflow.set_entry_point(\"agent\")\n\n# We now add a conditional edge\nworkflow.add_conditional_edges(\n    # First, we define the start node. We use `agent`.\n    # This means these are the edges taken after the `agent` node is called.\n    \"agent\",\n    # Next, we pass in the function that will determine which node is called next.\n    should_continue,\n    # Finally we pass in a mapping.\n    # The keys are strings, and the values are other nodes.\n    # END is a special node marking that the graph should finish.\n    # What will happen is we will call `should_continue`, and then the output of that\n    # will be matched against the keys in this mapping.\n    # Based on which one it matches, that node will then be called.\n    {\n        # If `tools`, then we call the tool node.\n        \"continue\": \"tools\",\n        # Otherwise we finish.\n        \"end\": END,\n    },\n)\n\n# We now add a normal edge from `tools` to `agent`.\n# This means that after `tools` is called, `agent` node is called next.\nworkflow.add_edge(\"tools\", \"agent\")\n\n# Now we can compile and visualize our graph\ngraph = workflow.compile()\n\nfrom IPython.display import Image, display\n\ntry:\n    display(Image(graph.get_graph().draw_mermaid_png()))\nexcept Exception:\n    # This requires some extra dependencies and is optional\n    pass\n```\n\n<p>\n\n</p>\n\n## Use ReAct agent\n\nNow that we have created our react agent, let's actually put it to the test!\n\n```python\n# Helper function for formatting the stream nicely\ndef print_stream(stream):\n    for s in stream:\n        message = s[\"messages\"][-1]\n        if isinstance(message, tuple):\n            print(message)\n        else:\n            message.pretty_print()\n\ninputs = {\"messages\": [(\"user\", \"what is the weather in sf\")]}\nprint_stream(graph.stream(inputs, stream_mode=\"values\"))\n```\n```output\n================================ Human Message =================================\n\nwhat is the weather in sf\n================================== Ai Message ==================================\nTool Calls:\n  get_weather (call_azW0cQ4XjWWj0IAkWAxq9nLB)\n Call ID: call_azW0cQ4XjWWj0IAkWAxq9nLB\n  Args:\n    location: San Francisco\n================================= Tool Message =================================\nName: get_weather\n\n\"It's sunny in San Francisco, but you better look out if you're a Gemini \\ud83d\\ude08.\"\n================================== Ai Message ==================================\n\nThe weather in San Francisco is sunny! However, it seems there's a playful warning for Geminis. Enjoy the sunshine!\n```\nPerfect! The graph correctly calls the `get_weather` tool and responds to the user after receiving the information from the tool.\n\n---\nhow-tos/react-agent-structured-output.ipynb\n---\n\n# How to force tool-calling agent to structure output\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Prerequisites</p>\n    <p>\n        This guide assumes familiarity with the following:\n        <ul>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#structured-output\">\n                    Structured Output\n                </a>\n            </li>            \n            <li>\n                <a href=\"https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/#tool-calling-agent\">\n                    Tool calling agent\n                </a>\n            </li>                \n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#chat-models\">\n                    Chat Models\n                </a>\n            </li>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#messages\">\n                    Messages\n                </a>\n            </li>\n            <li>\n                <a href=\"https://langchain-ai.github.io/langgraph/concepts/low_level/\">\n                    LangGraph Glossary\n                </a>\n            </li>\n        </ul>\n    </p>\n</div>\n\nYou might want your agent to return its output in a structured format. For example, if the output of the agent is used by some other downstream software, you may want the output to be in the same structured format every time the agent is invoked to ensure consistency.\n\nThis notebook will walk through two different options for forcing a tool calling agent to structure its output. We will be using a basic [ReAct agent](https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/) (a model node and a tool-calling node) together with a third node at the end that will format response for the user. Both of the options will use the same graph structure as shown in the diagram below, but will have different mechanisms under the hood.\n\n**Option 1**\n\nThe first way you can force your tool calling agent to have structured output is to bind the output you would like as an additional tool for the `agent` node to use. In contrast to the basic ReAct agent, the `agent` node in this case is not selecting between `tools` and `END` but rather selecting between the specific tools it calls. The expected flow in this case is that the LLM in the `agent` node will first select the action tool, and after receiving the action tool output it will call the response tool, which will then route to the `respond` node which simply structures the arguments from the `agent` node tool call.\n\n**Pros and Cons**\n\nThe benefit to this format is that you only need one LLM, and can save money and latency because of this. The downside to this option is that it isn't guaranteed that the single LLM will call the correct tool when you want it to. We can help the LLM by setting `tool_choice` to `any` when we use `bind_tools` which forces the LLM to select at least one tool at every turn, but this is far from a foolproof strategy. In addition, another downside is that the agent might call *multiple* tools, so we need to check for this explicitly in our routing function (or if we are using OpenAI we can set `parallell_tool_calling=False` to ensure only one tool is called at a time).\n\n**Option 2**\n\nThe second way you can force your tool calling agent to have structured output is to use a second LLM (in this case `model_with_structured_output`) to respond to the user.\n\nIn this case, you will define a basic ReAct agent normally, but instead of having the `agent` node choose between the `tools` node and ending the conversation, the `agent` node will choose between the `tools` node and the `respond` node. The `respond` node will contain a second LLM that uses structured output, and once called will return directly to the user. You can think of this method as basic ReAct with one extra step before responding to the user.\n\n**Pros and Cons**\n\nThe benefit of this method is that it guarantees structured output (as long as `.with_structured_output` works as expected with the LLM). The downside to using this approach is that it requires making an additional LLM call before responding to the user, which can increase costs as well as latency. In addition, by not providing the `agent` node LLM with information about the desired output schema there is a risk that the `agent` LLM will fail to call the correct tools required to answer in the correct output schema.\n\nNote that both of these options will follow the exact same graph structure (see the diagram above), in that they are both exact replicas of the basic ReAct architecture but with a `respond` node before the end.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys\n\n```shell\npip install -U langgraph langchain_anthropic\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"ANTHROPIC_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for LangGraph development</p>\n    <p style=\"padding-top: 5px;\">\n        Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started <a href=\"https://docs.smith.langchain.com\">here</a>. \n    </p>\n</div>\n\n## Define model, tools, and graph state\n\nNow we can define how we want to structure our output, define our graph state, and also our tools and the models we are going to use.\n\nTo use structured output, we will use the `with_structured_output` method from LangChain, which you can read more about [here](https://python.langchain.com/docs/how_to/structured_output/).\n\nWe are going to use a single tool in this example for finding the weather, and will return a structured weather response to the user.\n\n```python\nfrom pydantic import BaseModel, Field\nfrom typing import Literal\nfrom langchain_core.tools import tool\nfrom langchain_anthropic import ChatAnthropic\nfrom langgraph.graph import MessagesState\n\nclass WeatherResponse(BaseModel):\n    \"\"\"Respond to the user with this\"\"\"\n\ntemperature: float = Field(description=\"The temperature in fahrenheit\")\n    wind_directon: str = Field(\n        description=\"The direction of the wind in abbreviated form\"\n    )\n    wind_speed: float = Field(description=\"The speed of the wind in km/h\")\n\n# Inherit 'messages' key from MessagesState, which is a list of chat messages\nclass AgentState(MessagesState):\n    # Final structured response from the agent\n    final_response: WeatherResponse\n\n@tool\ndef get_weather(city: Literal[\"nyc\", \"sf\"]):\n    \"\"\"Use this to get weather information.\"\"\"\n    if city == \"nyc\":\n        return \"It is cloudy in NYC, with 5 mph winds in the North-East direction and a temperature of 70 degrees\"\n    elif city == \"sf\":\n        return \"It is 75 degrees and sunny in SF, with 3 mph winds in the South-East direction\"\n    else:\n        raise AssertionError(\"Unknown city\")\n\ntools = [get_weather]\n\nmodel = ChatAnthropic(model=\"claude-3-opus-20240229\")\n\nmodel_with_tools = model.bind_tools(tools)\nmodel_with_structured_output = model.with_structured_output(WeatherResponse)\n```\n\n## Option 1: Bind output as tool\n\nLet's now examine how we would use the single LLM option.\n\n### Define Graph\n\nThe graph definition is very similar to the one above, the only difference is we no longer call an LLM in the `response` node, and instead bind the `WeatherResponse` tool to our LLM that already contains the `get_weather` tool.\n\n```python\nfrom langgraph.graph import StateGraph, END\nfrom langgraph.prebuilt import ToolNode\n\ntools = [get_weather, WeatherResponse]\n\n# Force the model to use tools by passing tool_choice=\"any\"\nmodel_with_response_tool = model.bind_tools(tools, tool_choice=\"any\")\n\n# Define the function that calls the model\ndef call_model(state: AgentState):\n    response = model_with_response_tool.invoke(state[\"messages\"])\n    # We return a list, because this will get added to the existing list\n    return {\"messages\": [response]}\n\n# Define the function that responds to the user\ndef respond(state: AgentState):\n    # Construct the final answer from the arguments of the last tool call\n    weather_tool_call = state[\"messages\"][-1].tool_calls[0]\n    response = WeatherResponse(**weather_tool_call[\"args\"])\n    # Since we're using tool calling to return structured output,\n    # we need to add  a tool message corresponding to the WeatherResponse tool call,\n    # This is due to LLM providers' requirement that AI messages with tool calls\n    # need to be followed by a tool message for each tool call\n    tool_message = {\n        \"type\": \"tool\",\n        \"content\": \"Here is your structured response\",\n        \"tool_call_id\": weather_tool_call[\"id\"],\n    }\n    # We return the final answer\n    return {\"final_response\": response, \"messages\": [tool_message]}\n\n# Define the function that determines whether to continue or not\ndef should_continue(state: AgentState):\n    messages = state[\"messages\"]\n    last_message = messages[-1]\n    # If there is only one tool call and it is the response tool call we respond to the user\n    if (\n        len(last_message.tool_calls) == 1\n        and last_message.tool_calls[0][\"name\"] == \"WeatherResponse\"\n    ):\n        return \"respond\"\n    # Otherwise we will use the tool node again\n    else:\n        return \"continue\"\n\n# Define a new graph\nworkflow = StateGraph(AgentState)\n\n# Define the two nodes we will cycle between\nworkflow.add_node(\"agent\", call_model)\nworkflow.add_node(\"respond\", respond)\nworkflow.add_node(\"tools\", ToolNode(tools))\n\n# Set the entrypoint as `agent`\n# This means that this node is the first one called\nworkflow.set_entry_point(\"agent\")\n\n# We now add a conditional edge\nworkflow.add_conditional_edges(\n    \"agent\",\n    should_continue,\n    {\n        \"continue\": \"tools\",\n        \"respond\": \"respond\",\n    },\n)\n\nworkflow.add_edge(\"tools\", \"agent\")\nworkflow.add_edge(\"respond\", END)\ngraph = workflow.compile()\n```\n\n### Usage", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "Now we can run our graph to check that it worked as intended:\n\n```python\nanswer = graph.invoke(input={\"messages\": [(\"human\", \"what's the weather in SF?\")]})[\n    \"final_response\"\n]\n```\n\n```python\nanswer\n```\n\n```output\nWeatherResponse(temperature=75.0, wind_directon='SE', wind_speed=3.0)\n```\n\nAgain, the agent returned a `WeatherResponse` object as we expected.\n\n## Option 2: 2 LLMs\n\nLet's now dive into how we would use a second LLM to force structured output.\n\n### Define Graph\n\nWe can now define our graph:\n\n```python\nfrom langgraph.graph import StateGraph, END\nfrom langgraph.prebuilt import ToolNode\nfrom langchain_core.messages import HumanMessage\n\n# Define the function that calls the model\ndef call_model(state: AgentState):\n    response = model_with_tools.invoke(state[\"messages\"])\n    # We return a list, because this will get added to the existing list\n    return {\"messages\": [response]}\n\n# Define the function that responds to the user\ndef respond(state: AgentState):\n    # We call the model with structured output in order to return the same format to the user every time\n    # state['messages'][-2] is the last ToolMessage in the convo, which we convert to a HumanMessage for the model to use\n    # We could also pass the entire chat history, but this saves tokens since all we care to structure is the output of the tool\n    response = model_with_structured_output.invoke(\n        [HumanMessage(content=state[\"messages\"][-2].content)]\n    )\n    # We return the final answer\n    return {\"final_response\": response}\n\n# Define the function that determines whether to continue or not\ndef should_continue(state: AgentState):\n    messages = state[\"messages\"]\n    last_message = messages[-1]\n    # If there is no function call, then we respond to the user\n    if not last_message.tool_calls:\n        return \"respond\"\n    # Otherwise if there is, we continue\n    else:\n        return \"continue\"\n\n# Define a new graph\nworkflow = StateGraph(AgentState)\n\n# Define the two nodes we will cycle between\nworkflow.add_node(\"agent\", call_model)\nworkflow.add_node(\"respond\", respond)\nworkflow.add_node(\"tools\", ToolNode(tools))\n\n# Set the entrypoint as `agent`\n# This means that this node is the first one called\nworkflow.set_entry_point(\"agent\")\n\n# We now add a conditional edge\nworkflow.add_conditional_edges(\n    \"agent\",\n    should_continue,\n    {\n        \"continue\": \"tools\",\n        \"respond\": \"respond\",\n    },\n)\n\nworkflow.add_edge(\"tools\", \"agent\")\nworkflow.add_edge(\"respond\", END)\ngraph = workflow.compile()\n```\n\n### Usage\n\nWe can now invoke our graph to verify that the output is being structured as desired:\n\n```python\nanswer = graph.invoke(input={\"messages\": [(\"human\", \"what's the weather in SF?\")]})[\n    \"final_response\"\n]\n```\n\n```python\nanswer\n```\n\n```output\nWeatherResponse(temperature=75.0, wind_directon='SE', wind_speed=4.83)\n```\n\nAs we can see, the agent returned a `WeatherResponse` object as we expected. If would now be easy to use this agent in a more complex software stack without having to worry about the output of the agent not matching the format expected from the next step in the stack.\n\n---\nhow-tos/disable-streaming.ipynb\n---\n\n# How to disable streaming for models that don't support it\n\n<div class=\"admonition tip\">\n    <p class=\"admonition-title\">Prerequisites</p>\n    <p>\n        This guide assumes familiarity with the following:\n        <ul>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#streaming\">\n                    streaming\n                </a>                \n            </li>\n            <li>\n                <a href=\"https://python.langchain.com/docs/concepts/#chat-models/\">\n                    Chat Models\n                </a>\n            </li>\n        </ul>\n    </p>\n</div>\n\nSome chat models, including the new O1 models from OpenAI (depending on when you're reading this), do not support streaming. This can lead to issues when using the [astream_events API](https://python.langchain.com/docs/concepts/#astream_events), as it calls models in streaming mode, expecting streaming to function properly.\n\nIn this guide, we’ll show you how to disable streaming for models that don’t support it, ensuring they they're never called in streaming mode, even when invoked through the astream_events API.\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.graph import MessagesState\nfrom langgraph.graph import StateGraph, START, END\n\nllm = ChatOpenAI(model=\"o1-preview\", temperature=1)\n\ngraph_builder = StateGraph(MessagesState)\n\ndef chatbot(state: MessagesState):\n    return {\"messages\": [llm.invoke(state[\"messages\"])]}\n\ngraph_builder.add_node(\"chatbot\", chatbot)\ngraph_builder.add_edge(START, \"chatbot\")\ngraph_builder.add_edge(\"chatbot\", END)\ngraph = graph_builder.compile()\n```\n\n```python\nfrom IPython.display import Image, display\n\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n<p>\n\n</p>\n\n## Without disabling streaming\n\nNow that we've defined our graph, let's try to call `astream_events` without disabling streaming. This should throw an error because the `o1` model does not support streaming natively:\n\n```python\ninput = {\"messages\": {\"role\": \"user\", \"content\": \"how many r's are in strawberry?\"}}\ntry:\n    async for event in graph.astream_events(input, version=\"v2\"):\n        if event[\"event\"] == \"on_chat_model_end\":\n            print(event[\"data\"][\"output\"].content, end=\"\", flush=True)\nexcept:\n    print(\"Streaming not supported!\")\n```\n```output\nStreaming not supported!\n```\nAn error occurred as we expected, luckily there is an easy fix!\n\n## Disabling streaming\n\nNow without making any changes to our graph, let's set the [disable_streaming](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html#langchain_core.language_models.chat_models.BaseChatModel.disable_streaming) parameter on our model to be `True` which will solve the problem:\n\n```python\nllm = ChatOpenAI(model=\"o1-preview\", temperature=1, disable_streaming=True)\n\ngraph_builder = StateGraph(MessagesState)\n\ndef chatbot(state: MessagesState):\n    return {\"messages\": [llm.invoke(state[\"messages\"])]}\n\ngraph_builder.add_node(\"chatbot\", chatbot)\ngraph_builder.add_edge(START, \"chatbot\")\ngraph_builder.add_edge(\"chatbot\", END)\ngraph = graph_builder.compile()\n```\n\nAnd now, rerunning with the same input, we should see no errors:\n\n```python\ninput = {\"messages\": {\"role\": \"user\", \"content\": \"how many r's are in strawberry?\"}}\nasync for event in graph.astream_events(input, version=\"v2\"):\n    if event[\"event\"] == \"on_chat_model_end\":\n        print(event[\"data\"][\"output\"].content, end=\"\", flush=True)\n```\n```output\nThere are three \"r\"s in the word \"strawberry\".\n```\n\n---\nhow-tos/react-agent-from-scratch-functional.ipynb\n---\n\n# How to create a ReAct agent from scratch (Functional API)\n\n!!! info \"Prerequisites\"\n    This guide assumes familiarity with the following:\n    \n    - [Chat Models](https://python.langchain.com/docs/concepts/chat_models)\n    - [Messages](https://python.langchain.com/docs/concepts/messages)\n    - [Tool Calling](https://python.langchain.com/docs/concepts/tool_calling/)\n    - <a href=\"../../concepts/functional_api/#entrypoint\">Entrypoints</a> and <a href=\"../../concepts/functional_api/#task\">Tasks</a>\n\nThis guide demonstrates how to implement a ReAct agent using the LangGraph <a href=\"../../concepts/functional_api\">Functional API</a>.\n\nThe ReAct agent is a <a href=\"../../concepts/agentic_concepts/#tool-calling-agent\">tool-calling agent</a> that operates as follows:\n\n1. Queries are issued to a chat model;\n2. If the model generates no <a href=\"../../concepts/agentic_concepts/#tool-calling\">tool calls</a>, we return the model response.\n3. If the model generates tool calls, we execute the tool calls with available tools, append them as [tool messages](https://python.langchain.com/docs/concepts/messages/) to our message list, and repeat the process.\n\nThis is a simple and versatile set-up that can be extended with memory, human-in-the-loop capabilities, and other features. See the dedicated <a href=\"../../how-tos/#prebuilt-react-agent\">how-to guides</a> for examples.\n\n## Setup\n\nFirst, let's install the required packages and set our API keys:\n\n```shell\npip install -U langgraph langchain-openai\n```\n\n```python\nimport getpass\nimport os\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n_set_env(\"OPENAI_API_KEY\")\n```\n\n<div class=\"admonition tip\">\n     <p class=\"admonition-title\">Set up <a href=\"https://smith.langchain.com\">LangSmith</a> for better debugging</p>\n     <p style=\"padding-top: 5px;\">\n         Sign up for LangSmith to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM aps built with LangGraph — read more about how to get started in the <a href=\"https://docs.smith.langchain.com\">docs</a>. \n     </p>\n </div>\n\n## Create ReAct agent\n\nNow that you have installed the required packages and set your environment variables, we can create our agent.\n\n### Define model and tools\n\nLet's first define the tools and model we will use for our example. Here we will use a single place-holder tool that gets a description of the weather for a location.\n\nWe will use an [OpenAI](https://python.langchain.com/docs/integrations/providers/openai/) chat model for this example, but any model [supporting tool-calling](https://python.langchain.com/docs/integrations/chat/) will suffice.\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.tools import tool\n\nmodel = ChatOpenAI(model=\"gpt-4o-mini\")\n\n@tool\ndef get_weather(location: str):\n    \"\"\"Call to get the weather from a specific location.\"\"\"\n    # This is a placeholder for the actual implementation\n    if any([city in location.lower() for city in [\"sf\", \"san francisco\"]]):\n        return \"It's sunny!\"\n    elif \"boston\" in location.lower():\n        return \"It's rainy!\"\n    else:\n        return f\"I am not sure what the weather is in {location}\"\n\ntools = [get_weather]\n```\n\n### Define tasks\n\nWe next define the <a href=\"../../concepts/functional_api/#task\">tasks</a> we will execute. Here there are two different tasks:\n\n1. **Call model**: We want to query our chat model with a list of messages.\n2. **Call tool**: If our model generates tool calls, we want to execute them.\n\n```python\nfrom langchain_core.messages import ToolMessage\nfrom langgraph.func import entrypoint, task\n\ntools_by_name = {tool.name: tool for tool in tools}\n\n@task\ndef call_model(messages):\n    \"\"\"Call model with a sequence of messages.\"\"\"\n    response = model.bind_tools(tools).invoke(messages)\n    return response\n\n@task\ndef call_tool(tool_call):\n    tool = tools_by_name[tool_call[\"name\"]]\n    observation = tool.invoke(tool_call[\"args\"])\n    return ToolMessage(content=observation, tool_call_id=tool_call[\"id\"])\n```\n\n### Define entrypoint\n\nOur <a href=\"../../concepts/functional_api/#entrypoint\">entrypoint</a> will handle the orchestration of these two tasks. As described above, when our `call_model` task generates tool calls, the `call_tool` task will generate responses for each. We append all messages to a single messages list.\n\n!!! tip\n    Note that because tasks return future-like objects, the below implementation executes tools in parallel.\n\n```python\nfrom langgraph.graph.message import add_messages\n\n@entrypoint()\ndef agent(messages):\n    llm_response = call_model(messages).result()\n    while True:\n        if not llm_response.tool_calls:\n            break\n\n# Execute tools\n        tool_result_futures = [\n            call_tool(tool_call) for tool_call in llm_response.tool_calls\n        ]\n        tool_results = [fut.result() for fut in tool_result_futures]\n\n# Append to message list\n        messages = add_messages(messages, [llm_response, *tool_results])\n\n# Call model again\n        llm_response = call_model(messages).result()\n\nreturn llm_response\n```\n\n## Usage\n\nTo use our agent, we invoke it with a messages list. Based on our implementation, these can be LangChain [message](https://python.langchain.com/docs/concepts/messages/) objects or OpenAI-style dicts:\n\n```python\nuser_message = {\"role\": \"user\", \"content\": \"What's the weather in san francisco?\"}\nprint(user_message)\n\nfor step in agent.stream([user_message]):\n    for task_name, message in step.items():\n        if task_name == \"agent\":\n            continue  # Just print task updates\n        print(f\"\\n{task_name}:\")\n        message.pretty_print()\n```\n```output\n{'role': 'user', 'content': \"What's the weather in san francisco?\"}\n\ncall_model:\n================================== Ai Message ==================================\nTool Calls:\n  get_weather (call_tNnkrjnoz6MNfCHJpwfuEQ0v)\n Call ID: call_tNnkrjnoz6MNfCHJpwfuEQ0v\n  Args:\n    location: san francisco\n\ncall_tool:\n================================= Tool Message =================================\n\nIt's sunny!\n\ncall_model:\n================================== Ai Message ==================================\n\nThe weather in San Francisco is sunny!\n```\nPerfect! The graph correctly calls the `get_weather` tool and responds to the user after receiving the information from the tool. Check out the LangSmith trace [here](https://smith.langchain.com/public/d5a0d5ea-bdaa-4032-911e-7db177c8141b/r).\n\n## Add thread-level persistence\n\nAdding <a href=\"../../concepts/persistence#threads\">thread-level persistence</a> lets us support conversational experiences with our agent: subsequent invocations will append to the prior messages list, retaining the full conversational context.\n\nTo add thread-level persistence to our agent:\n\n1. Select a <a href=\"../../concepts/persistence#checkpointer-libraries\">checkpointer</a>: here we will use <a href=\"../../reference/checkpoints/#langgraph.checkpoint.memory.InMemorySaver\">InMemorySaver</a>, a simple in-memory checkpointer.\n2. Update our entrypoint to accept the previous messages state as a second argument. Here, we simply append the message updates to the previous sequence of messages.\n3. Choose which values will be returned from the workflow and which will be saved by the checkpointer as `previous` using `entrypoint.final` (optional)\n\n```python hl_lines=\"3 6 7 8 9 30\"\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef agent(messages, previous):\n    if previous is not None:\n        messages = add_messages(previous, messages)\n\nllm_response = call_model(messages).result()\n    while True:\n        if not llm_response.tool_calls:\n            break\n\n# Execute tools\n        tool_result_futures = [\n            call_tool(tool_call) for tool_call in llm_response.tool_calls\n        ]\n        tool_results = [fut.result() for fut in tool_result_futures]\n\n# Append to message list\n        messages = add_messages(messages, [llm_response, *tool_results])\n\n# Call model again\n        llm_response = call_model(messages).result()\n\n# Generate final response\n    messages = add_messages(messages, llm_response)\n    return entrypoint.final(value=llm_response, save=messages)\n```\n\nWe will now need to pass in a config when running our application. The config will specify an identifier for the conversational thread.\n\n!!! tip\n\nRead more about thread-level persistence in our <a href=\"../../concepts/persistence/\">concepts page</a> and <a href=\"../../how-tos/#persistence\">how-to guides</a>.\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n```\n\nWe start a thread the same way as before, this time passing in the config:\n\n```python hl_lines=\"4\"\nuser_message = {\"role\": \"user\", \"content\": \"What's the weather in san francisco?\"}\nprint(user_message)\n\nfor step in agent.stream([user_message], config):\n    for task_name, message in step.items():\n        if task_name == \"agent\":\n            continue  # Just print task updates\n        print(f\"\\n{task_name}:\")\n        message.pretty_print()\n```\n```output\n{'role': 'user', 'content': \"What's the weather in san francisco?\"}\n\ncall_model:\n================================== Ai Message ==================================\nTool Calls:\n  get_weather (call_lubbUSdDofmOhFunPEZLBz3g)\n Call ID: call_lubbUSdDofmOhFunPEZLBz3g\n  Args:\n    location: San Francisco\n\ncall_tool:\n================================= Tool Message =================================\n\nIt's sunny!\n\ncall_model:\n================================== Ai Message ==================================\n\nThe weather in San Francisco is sunny!\n```\nWhen we ask a follow-up conversation, the model uses the prior context to infer that we are asking about the weather:\n\n```python\nuser_message = {\"role\": \"user\", \"content\": \"How does it compare to Boston, MA?\"}\nprint(user_message)\n\nfor step in agent.stream([user_message], config):\n    for task_name, message in step.items():\n        if task_name == \"agent\":\n            continue  # Just print task updates\n        print(f\"\\n{task_name}:\")\n        message.pretty_print()\n```\n```output\n{'role': 'user', 'content': 'How does it compare to Boston, MA?'}\n\ncall_model:\n================================== Ai Message ==================================\nTool Calls:\n  get_weather (call_8sTKYAhSIHOdjLD5d6gaswuV)\n Call ID: call_8sTKYAhSIHOdjLD5d6gaswuV\n  Args:\n    location: Boston, MA\n\ncall_tool:\n================================= Tool Message =================================\n\nIt's rainy!\n\ncall_model:\n================================== Ai Message ==================================\n\nCompared to San Francisco, which is sunny, Boston, MA is experiencing rainy weather.\n```\nIn the [LangSmith trace](https://smith.langchain.com/public/20a1116b-bb3b-44c1-8765-7a28663439d9/r), we can see that the full conversational context is retained in each model call.\n\n---\nconcepts/assistants.md\n---\n\n# Assistants\n\n**Assistants** allow you to manage configurations (like prompts, LLM selection, tools) separately from your graph's core logic, enabling rapid changes that don't alter the graph architecture. It is a way to create multiple specialized versions of the same graph architecture, each optimized for different use cases through context/configuration variations rather than structural changes.\n\nFor example, imagine a general-purpose writing agent built on a common graph architecture. While the structure remains the same, different writing styles—such as blog posts and tweets—require tailored configurations to optimize performance. To support these variations, you can create multiple assistants (e.g., one for blogs and another for tweets) that share the underlying graph but differ in model selection and system prompt.\n\n![assistant versions](img/assistants.png)\n\nThe LangGraph Cloud API provides several endpoints for creating and managing assistants and their versions. See the [API reference](../cloud/reference/api/api_ref.html#tag/assistants) for more details.\n\n!!! info\n\nAssistants are a [LangGraph Platform](langgraph_platform.md) concept. They are not available in the open source LangGraph library.\n\n## Configuration\n\nAssistants build on the LangGraph open source concepts of configuration and [runtime context](low_level.md#runtime-context).\n\nWhile these features are available in the open source LangGraph library, assistants are only present in [LangGraph Platform](langgraph_platform.md). This is due to the fact that assistants are tightly coupled to your deployed graph. Upon deployment, LangGraph Server will automatically create a default assistant for each graph using the graph's default context and configuration settings.\n\nIn practice, an assistant is just an _instance_ of a graph with a specific configuration. Therefore, multiple assistants can reference the same graph but can contain different configurations (e.g. prompts, models, tools). The LangGraph Server API provides several endpoints for creating and managing assistants. See the [API reference](../cloud/reference/api/api_ref.html) and [this how-to](../cloud/how-tos/configuration_cloud.md) for more details on how to create assistants.\n\n## Versioning\n\nAssistants support versioning to track changes over time.\nOnce you've created an assistant, subsequent edits to that assistant will create new versions. See [this how-to](../cloud/how-tos/configuration_cloud.md#create-a-new-version-for-your-assistant) for more details on how to manage assistant versions.\n\n## Execution\n\nA **run** is an invocation of an assistant. Each run may have its own input, configuration, context, and metadata, which may affect execution and output of the underlying graph. A run can optionally be executed on a [thread](./persistence.md#threads).\n\nThe LangGraph Platform API provides several endpoints for creating and managing runs. See the [API reference](../cloud/reference/api/api_ref.html#tag/thread-runs/) for more details.\n\n---\nconcepts/langgraph_studio.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Studio\n\n!!! info \"Prerequisites\"\n\n- [LangGraph Platform](./langgraph_platform.md)\n    - [LangGraph Server](./langgraph_server.md)\n    - [LangGraph CLI](./langgraph_cli.md)\n\nLangGraph Studio is a specialized agent IDE that enables visualization, interaction, and debugging of agentic systems that implement the LangGraph Server API protocol. Studio also integrates with LangSmith to enable tracing, evaluation, and prompt engineering.\n\n![](img/lg_studio.png)\n\n## Features\n\nKey features of LangGraph Studio:\n\n- Visualize your graph architecture\n- [Run and interact with your agent](../cloud/how-tos/invoke_studio.md)\n- [Manage assistants](../cloud/how-tos/studio/manage_assistants.md)\n- [Manage threads](../cloud/how-tos/threads_studio.md)\n- [Iterate on prompts](../cloud/how-tos/iterate_graph_studio.md)\n- [Run experiments over a dataset](../cloud/how-tos/studio/run_evals.md)\n- Manage [long term memory](memory.md)\n- Debug agent state via [time travel](time-travel.md)\n\nLangGraph Studio works for graphs that are deployed on [LangGraph Platform](../cloud/quick_start.md) or for graphs that are running locally via the [LangGraph Server](../tutorials/langgraph-platform/local-server.md).\n\nStudio supports two modes:\n\n### Graph mode\n\nGraph mode exposes the full feature-set of Studio and is useful when you would like as many details about the execution of your agent, including the nodes traversed, intermediate states, and LangSmith integrations (such as adding to datasets and playground).\n\n### Chat mode\n\nChat mode is a simpler UI for iterating on and testing chat-specific agents. It is useful for business users and those who want to test overall agent behavior. Chat mode is only supported for graph's whose state includes or extends [`MessagesState`](https://langchain-ai.github.io/langgraph/how-tos/graph-api/#messagesstate).\n\n## Learn more\n\n- See this guide on how to [get started](../cloud/how-tos/studio/quick_start.md) with LangGraph Studio.\n\n---\nconcepts/double_texting.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Double Texting\n\n!!! info \"Prerequisites\"\n    - [LangGraph Server](./langgraph_server.md)\n\nMany times users might interact with your graph in unintended ways. \nFor instance, a user may send one message and before the graph has finished running send a second message. \nMore generally, users may invoke the graph a second time before the first run has finished.\nWe call this \"double texting\".\n\nCurrently, LangGraph only addresses this as part of [LangGraph Platform](langgraph_platform.md), not in the open source.\nThe reason for this is that in order to handle this we need to know how the graph is deployed, and since LangGraph Platform deals with deployment the logic needs to live there.\nIf you do not want to use LangGraph Platform, we describe the options we have implemented in detail below.\n\n![](img/double_texting.png)\n\n## Reject\n\nThis is the simplest option, this just rejects any follow-up runs and does not allow double texting. \nSee the [how-to guide](../cloud/how-tos/reject_concurrent.md) for configuring the reject double text option.\n\n## Enqueue\n\nThis is a relatively simple option which continues the first run until it completes the whole run, then sends the new input as a separate run. \nSee the [how-to guide](../cloud/how-tos/enqueue_concurrent.md) for configuring the enqueue double text option.\n\n## Interrupt\n\nThis option interrupts the current execution but saves all the work done up until that point. \nIt then inserts the user input and continues from there.\n\nIf you enable this option, your graph should be able to handle weird edge cases that may arise. \nFor example, you could have called a tool but not yet gotten back a result from running that tool.\nYou may need to remove that tool call in order to not have a dangling tool call.\n\nSee the [how-to guide](../cloud/how-tos/interrupt_concurrent.md) for configuring the interrupt double text option.\n\n## Rollback\n\nThis option interrupts the current execution AND rolls back all work done up until that point, including the original run input. It then sends the new user input in, basically as if it was the original input.\n\nSee the [how-to guide](../cloud/how-tos/rollback_concurrent.md) for configuring the rollback double text option.\n\n---\nconcepts/pregel.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph runtime\n\n[Pregel](https://langchain-ai.github.io/langgraph/reference/pregel/) implements LangGraph's runtime, managing the execution of LangGraph applications.\n\nCompiling a [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.StateGraph) or creating an [entrypoint](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.entrypoint) produces a [Pregel](https://langchain-ai.github.io/langgraph/reference/pregel/) instance that can be invoked with input.\n\nThis guide explains the runtime at a high level and provides instructions for directly implementing applications with Pregel.\n\n> **Note:** The [Pregel](https://langchain-ai.github.io/langgraph/reference/pregel/) runtime is named after [Google's Pregel algorithm](https://research.google/pubs/pub37252/), which describes an efficient method for large-scale parallel computation using graphs.\n\n## Overview\n\nIn LangGraph, Pregel combines [**actors**](https://en.wikipedia.org/wiki/Actor_model) and **channels** into a single application. **Actors** read data from channels and write data to channels. Pregel organizes the execution of the application into multiple steps, following the **Pregel Algorithm**/**Bulk Synchronous Parallel** model.\n\nEach step consists of three phases:\n\n- **Plan**: Determine which **actors** to execute in this step. For example, in the first step, select the **actors** that subscribe to the special **input** channels; in subsequent steps, select the **actors** that subscribe to channels updated in the previous step.\n- **Execution**: Execute all selected **actors** in parallel, until all complete, or one fails, or a timeout is reached. During this phase, channel updates are invisible to actors until the next step.\n- **Update**: Update the channels with the values written by the **actors** in this step.\n\nRepeat until no **actors** are selected for execution, or a maximum number of steps is reached.\n\n## Actors\n\nAn **actor** is a `PregelNode`. It subscribes to channels, reads data from them, and writes data to them. It can be thought of as an **actor** in the Pregel algorithm. `PregelNodes` implement LangChain's Runnable interface.\n\n## Channels\n\nChannels are used to communicate between actors (PregelNodes). Each channel has a value type, an update type, and an update function – which takes a sequence of updates and modifies the stored value. Channels can be used to send data from one chain to another, or to send data from a chain to itself in a future step. LangGraph provides a number of built-in channels:", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "- [LastValue](https://langchain-ai.github.io/langgraph/reference/channels/#langgraph.channels.LastValue): The default channel, stores the last value sent to the channel, useful for input and output values, or for sending data from one step to the next.\n- [Topic](https://langchain-ai.github.io/langgraph/reference/channels/#langgraph.channels.Topic): A configurable PubSub Topic, useful for sending multiple values between **actors**, or for accumulating output. Can be configured to deduplicate values or to accumulate values over the course of multiple steps.\n- [BinaryOperatorAggregate](https://langchain-ai.github.io/langgraph/reference/pregel/#langgraph.pregel.Pregel--advanced-channels-context-and-binaryoperatoraggregate): stores a persistent value, updated by applying a binary operator to the current value and each update sent to the channel, useful for computing aggregates over multiple steps; e.g.,`total = BinaryOperatorAggregate(int, operator.add)`\n\n## Examples\n\nWhile most users will interact with Pregel through the [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.StateGraph) API or the [entrypoint](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.entrypoint) decorator, it is possible to interact with Pregel directly.\n\nBelow are a few different examples to give you a sense of the Pregel API.\n\n=== \"Single node\"\n\n```python\n    from langgraph.channels import EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder\n\nnode1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\")\n    )\n\napp = Pregel(\n        nodes={\"node1\": node1},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"b\"],\n    )\n\napp.invoke({\"a\": \"foo\"})\n    ```\n\n```con\n    {'b': 'foofoo'}\n    ```\n\n=== \"Multiple nodes\"\n\n```python\n    from langgraph.channels import LastValue, EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder\n\nnode1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\")\n    )\n\nnode2 = (\n        NodeBuilder().subscribe_only(\"b\")\n        .do(lambda x: x + x)\n        .write_to(\"c\")\n    )\n\napp = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": LastValue(str),\n            \"c\": EphemeralValue(str),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"b\", \"c\"],\n    )\n\napp.invoke({\"a\": \"foo\"})\n    ```\n\n```con\n    {'b': 'foofoo', 'c': 'foofoofoofoo'}\n    ```\n\n=== \"Topic\"\n\n```python\n    from langgraph.channels import EphemeralValue, Topic\n    from langgraph.pregel import Pregel, NodeBuilder\n\nnode1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\", \"c\")\n    )\n\nnode2 = (\n        NodeBuilder().subscribe_to(\"b\")\n        .do(lambda x: x[\"b\"] + x[\"b\"])\n        .write_to(\"c\")\n    )\n\napp = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n            \"c\": Topic(str, accumulate=True),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"c\"],\n    )\n\napp.invoke({\"a\": \"foo\"})\n    ```\n\n```pycon\n    {'c': ['foofoo', 'foofoofoofoo']}\n    ```\n\n=== \"BinaryOperatorAggregate\"\n\nThis examples demonstrates how to use the BinaryOperatorAggregate channel to implement a reducer.\n\n```python\n    from langgraph.channels import EphemeralValue, BinaryOperatorAggregate\n    from langgraph.pregel import Pregel, NodeBuilder\n\nnode1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\", \"c\")\n    )\n\nnode2 = (\n        NodeBuilder().subscribe_only(\"b\")\n        .do(lambda x: x + x)\n        .write_to(\"c\")\n    )\n\ndef reducer(current, update):\n        if current:\n            return current + \" | \" + update\n        else:\n            return update\n\napp = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n            \"c\": BinaryOperatorAggregate(str, operator=reducer),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"c\"],\n    )\n\napp.invoke({\"a\": \"foo\"})\n    ```\n\n=== \"Cycle\"\n\nThis example demonstrates how to introduce a cycle in the graph, by having\n    a chain write to a channel it subscribes to. Execution will continue\n    until a `None` value is written to the channel.\n\n```python\n    from langgraph.channels import EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder, ChannelWriteEntry\n\nexample_node = (\n        NodeBuilder().subscribe_only(\"value\")\n        .do(lambda x: x + x if len(x) < 10 else None)\n        .write_to(ChannelWriteEntry(\"value\", skip_none=True))\n    )\n\napp = Pregel(\n        nodes={\"example_node\": example_node},\n        channels={\n            \"value\": EphemeralValue(str),\n        },\n        input_channels=[\"value\"],\n        output_channels=[\"value\"],\n    )\n\napp.invoke({\"value\": \"a\"})\n    ```\n\n```pycon\n    {'value': 'aaaaaaaaaaaaaaaa'}\n    ```\n\n## High-level API\n\nLangGraph provides two high-level APIs for creating a Pregel application: the [StateGraph (Graph API)](./low_level.md) and the [Functional API](functional_api.md).\n\n=== \"StateGraph (Graph API)\"\n\nThe [StateGraph (Graph API)](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.StateGraph) is a higher-level abstraction that simplifies the creation of Pregel applications. It allows you to define a graph of nodes and edges. When you compile the graph, the StateGraph API automatically creates the Pregel application for you.\n\n```python\n    from typing import TypedDict, Optional\n\nfrom langgraph.constants import START\n    from langgraph.graph import StateGraph\n\nclass Essay(TypedDict):\n        topic: str\n        content: Optional[str]\n        score: Optional[float]\n\ndef write_essay(essay: Essay):\n        return {\n            \"content\": f\"Essay about {essay['topic']}\",\n        }\n\ndef score_essay(essay: Essay):\n        return {\n            \"score\": 10\n        }\n\nbuilder = StateGraph(Essay)\n    builder.add_node(write_essay)\n    builder.add_node(score_essay)\n    builder.add_edge(START, \"write_essay\")\n\n# Compile the graph.\n    # This will return a Pregel instance.\n    graph = builder.compile()\n    ```\n\nThe compiled Pregel instance will be associated with a list of nodes and channels. You can inspect the nodes and channels by printing them.\n\n```python\n    print(graph.nodes)\n    ```\n\nYou will see something like this:\n\n```pycon\n    {'__start__': <langgraph.pregel.read.PregelNode at 0x7d05e3ba1810>,\n     'write_essay': <langgraph.pregel.read.PregelNode at 0x7d05e3ba14d0>,\n     'score_essay': <langgraph.pregel.read.PregelNode at 0x7d05e3ba1710>}\n    ```\n\n```python\n    print(graph.channels)\n    ```\n\nYou should see something like this\n\n```pycon\n    {'topic': <langgraph.channels.last_value.LastValue at 0x7d05e3294d80>,\n     'content': <langgraph.channels.last_value.LastValue at 0x7d05e3295040>,\n     'score': <langgraph.channels.last_value.LastValue at 0x7d05e3295980>,\n     '__start__': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e3297e00>,\n     'write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e32960c0>,\n     'score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8ab80>,\n     'branch:__start__:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e32941c0>,\n     'branch:__start__:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d88800>,\n     'branch:write_essay:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e3295ec0>,\n     'branch:write_essay:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8ac00>,\n     'branch:score_essay:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d89700>,\n     'branch:score_essay:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8b400>,\n     'start:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8b280>}\n    ```\n\n=== \"Functional API\"\n\nIn the [Functional API](functional_api.md), you can use an [`entrypoint`](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.entrypoint) to create a Pregel application. The `entrypoint` decorator allows you to define a function that takes input and returns output.\n\n```python\n    from typing import TypedDict, Optional\n\nfrom langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.func import entrypoint\n\nclass Essay(TypedDict):\n        topic: str\n        content: Optional[str]\n        score: Optional[float]\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\n    def write_essay(essay: Essay):\n        return {\n            \"content\": f\"Essay about {essay['topic']}\",\n        }\n\nprint(\"Nodes: \")\n    print(write_essay.nodes)\n    print(\"Channels: \")\n    print(write_essay.channels)\n    ```\n\n```pycon\n    Nodes:\n    {'write_essay': <langgraph.pregel.read.PregelNode object at 0x7d05e2f9aad0>}\n    Channels:\n    {'__start__': <langgraph.channels.ephemeral_value.EphemeralValue object at 0x7d05e2c906c0>, '__end__': <langgraph.channels.last_value.LastValue object at 0x7d05e2c90c40>, '__previous__': <langgraph.channels.last_value.LastValue object at 0x7d05e1007280>}\n    ```\n\n---\nconcepts/plans.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Platform Plans\n\n## Overview\nLangGraph Platform is a solution for deploying agentic applications in production.\nThere are three different plans for using it.\n\n- **Developer**: All [LangSmith](https://smith.langchain.com/) users have access to this plan. You can sign up for this plan simply by creating a LangSmith account. This gives you access to the [local deployment](./deployment_options.md#free-deployment) option.\n- **Plus**: All [LangSmith](https://smith.langchain.com/) users with a [Plus account](https://docs.smith.langchain.com/administration/pricing) have access to this plan. You can sign up for this plan simply by upgrading your LangSmith account to the Plus plan type. This gives you access to the [Cloud](./deployment_options.md#cloud-saas) deployment option.\n- **Enterprise**: This is separate from LangSmith plans. You can sign up for this plan by [contacting our sales team](https://www.langchain.com/contact-sales). This gives you access to all [deployment options](./deployment_options.md).\n\n## Plan Details\n\n|                                                                  | Developer                                   | Plus                                                  | Enterprise                                          |\n|------------------------------------------------------------------|---------------------------------------------|-------------------------------------------------------|-----------------------------------------------------|\n| Deployment Options                                               | Local                          | Cloud SaaS                                         | <ul><li>Cloud SaaS</li><li>Self-Hosted Data Plane</li><li>Self-Hosted Control Plane</li><li>Standalone Container</li></ul> |\n| Usage                                                            | Free | See [Pricing](https://www.langchain.com/langgraph-platform-pricing) | Custom                                              |\n| APIs for retrieving and updating state and conversational history | ✅                                           | ✅                                                     | ✅                                                   |\n| APIs for retrieving and updating long-term memory                | ✅                                           | ✅                                                     | ✅                                                   |\n| Horizontally scalable task queues and servers                    | ✅                                           | ✅                                                     | ✅                                                   |\n| Real-time streaming of outputs and intermediate steps            | ✅                                           | ✅                                                     | ✅                                                   |\n| Assistants API (configurable templates for LangGraph apps)       | ✅                                           | ✅                                                     | ✅                                                   |\n| Cron scheduling                                                  | --                                          | ✅                                                     | ✅                                                   |\n| LangGraph Studio for prototyping                                 | \t✅                                         | ✅                                                    | ✅                                                  |\n| Authentication & authorization to call the LangGraph APIs        | --                                          | Coming Soon!                                          | Coming Soon!                                        |\n| Smart caching to reduce traffic to LLM API                       | --                                          | Coming Soon!                                          | Coming Soon!                                        |\n| Publish/subscribe API for state                                  | --                                          | Coming Soon!                                          | Coming Soon!                                        |\n| Scheduling prioritization                                        | --                                          | Coming Soon!                                          | Coming Soon!                                        |\n\nFor pricing information, see [LangGraph Platform Pricing](https://www.langchain.com/langgraph-platform-pricing).\n\n## Related\n\nFor more information, please see:\n\n* [Deployment Options conceptual guide](./deployment_options.md)\n* [LangGraph Platform Pricing](https://www.langchain.com/langgraph-platform-pricing)\n* [LangSmith Plans](https://docs.smith.langchain.com/administration/pricing)\n\n---\nconcepts/template_applications.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Template Applications\n\nTemplates are open source reference applications designed to help you get started quickly when building with LangGraph. They provide working examples of common agentic workflows that can be customized to your needs.\n\nYou can create an application from a template using the LangGraph CLI.\n\n!!! info \"Requirements\"\n\n- Python >= 3.11\n    - [LangGraph CLI](https://langchain-ai.github.io/langgraph/cloud/reference/cli/): Requires langchain-cli[inmem] >= 0.1.58\n\n## Install the LangGraph CLI\n\n```bash\npip install \"langgraph-cli[inmem]\" --upgrade\n```\n\nOr via [`uv`](https://docs.astral.sh/uv/getting-started/installation/) (recommended):\n\n```bash\nuvx --from \"langgraph-cli[inmem]\" langgraph dev --help\n```\n\n## Available Templates\n\n| Template | Description | Link |\n| -------- | ----------- | ------ |\n| **New LangGraph Project** | A simple, minimal chatbot with memory. | [Repo](https://github.com/langchain-ai/new-langgraph-project) |\n| **ReAct Agent** | A simple agent that can be flexibly extended to many tools. | [Repo](https://github.com/langchain-ai/react-agent) |\n| **Memory Agent** | A ReAct-style agent with an additional tool to store memories for use across threads. | [Repo](https://github.com/langchain-ai/memory-agent) |\n| **Retrieval Agent** | An agent that includes a retrieval-based question-answering system. | [Repo](https://github.com/langchain-ai/retrieval-agent-template) |\n| **Data-Enrichment Agent** | An agent that performs web searches and organizes its findings into a structured format. | [Repo](https://github.com/langchain-ai/data-enrichment) |\n\n## 🌱 Create a LangGraph App\n\nTo create a new app from a template, use the `langgraph new` command.\n\n```bash\nlanggraph new\n```\n\nOr via [`uv`](https://docs.astral.sh/uv/getting-started/installation/) (recommended):\n\n```bash\nuvx --from \"langgraph-cli[inmem]\" langgraph new\n```\n\n## Next Steps\n\nReview the `README.md` file in the root of your new LangGraph app for more information about the template and how to customize it.\n\nAfter configuring the app properly and adding your API keys, you can start the app using the LangGraph CLI:\n\n```bash\nlanggraph dev\n```\n\nOr via [`uv`](https://docs.astral.sh/uv/getting-started/installation/) (recommended):\n\n```bash\nuvx --from \"langgraph-cli[inmem]\" --with-editable . langgraph dev\n```\n\n!!! info \"Missing Local Package?\"\n\nIf you are not using `uv` and run into a \"`ModuleNotFoundError`\" or \"`ImportError`\", even after installing the local package (`pip install -e .`), it is likely the case that you need to install the CLI into your local virtual environment to make the CLI \"aware\" of the local package. You can do this by running `python -m pip install \"langgraph-cli[inmem]\"` and re-activating your virtual environment before running `langgraph dev`.\n\nSee the following guides for more information on how to deploy your app:\n\n- **[Launch Local LangGraph Server](../tutorials/langgraph-platform/local-server.md)**: This quick start guide shows how to start a LangGraph Server locally for the **ReAct Agent** template. The steps are similar for other templates.\n- **[Deploy to LangGraph Platform](../cloud/quick_start.md)**: Deploy your LangGraph app using LangGraph Platform.\n\n---\nconcepts/tools.md\n---\n\n# Tools\n\nMany AI applications interact with users via natural language. However, some use cases require models to interface directly with external systems—such as APIs, databases, or file systems—using structured input. In these scenarios, [tool calling](../how-tos/tool-calling.md) enables models to generate requests that conform to a specified input schema.\n\n**Tools** encapsulate a callable function and its input schema. These can be passed to compatible [chat models](https://python.langchain.com/docs/concepts/chat_models), allowing the model to decide whether to invoke a tool and with what arguments.\n\n## Tool calling\n\n![Diagram of a tool call by a model](./img/tool_call.png)\n\nTool calling is typically **conditional**. Based on the user input and available tools, the model may choose to issue a tool call request. This request is returned in an `AIMessage` object, which includes a `tool_calls` field that specifies the tool name and input arguments:\n\n```python\nllm_with_tools.invoke(\"What is 2 multiplied by 3?\")\n# -> AIMessage(tool_calls=[{'name': 'multiply', 'args': {'a': 2, 'b': 3}, ...}])\n```\n\n```\nAIMessage(\n  tool_calls=[\n    ToolCall(name=\"multiply\", args={\"a\": 2, \"b\": 3}),\n    ...\n  ]\n)\n```\n\nIf the input is unrelated to any tool, the model returns only a natural language message:\n\n```python\nllm_with_tools.invoke(\"Hello world!\")  # -> AIMessage(content=\"Hello!\")\n```\n\nImportantly, the model does not execute the tool—it only generates a request. A separate executor (such as a runtime or agent) is responsible for handling the tool call and returning the result.\n\nSee the [tool calling guide](../how-tos/tool-calling.md) for more details.\n\n## Prebuilt tools\n\nLangChain provides prebuilt tool integrations for common external systems including APIs, databases, file systems, and web data.\n\nBrowse the [integrations directory](https://python.langchain.com/docs/integrations/tools/) for available tools.\n\nCommon categories:\n\n- **Search**: Bing, SerpAPI, Tavily\n- **Code execution**: Python REPL, Node.js REPL\n- **Databases**: SQL, MongoDB, Redis\n- **Web data**: Scraping and browsing\n- **APIs**: OpenWeatherMap, NewsAPI, etc.\n\n## Custom tools\n\nYou can define custom tools using the `@tool` decorator or plain Python functions. For example:\n\n```python\nfrom langchain_core.tools import tool\n\n@tool\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n```\n\nSee the [tool calling guide](../how-tos/tool-calling.md) for more details.\n\n## Tool execution\n\nWhile the model determines when to call a tool, execution of the tool call must be handled by a runtime component.\n\nLangGraph provides prebuilt components for this:\n\n- [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode): A prebuilt node that executes tools.\n- [`create_react_agent`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.chat_agent_executor.create_react_agent): Constructs a full agent that manages tool calling automatically.\n\n---\nconcepts/subgraphs.md\n---\n\n# Subgraphs\n\nA subgraph is a [graph](./low_level.md#graphs) that is used as a [node](./low_level.md#nodes) in another graph — this is the concept of encapsulation applied to LangGraph. Subgraphs allow you to build complex systems with multiple components that are themselves graphs.\n\n![Subgraph](./img/subgraph.png)\n\nSome reasons for using subgraphs are:\n\n- building [multi-agent systems](./multi_agent.md)\n- when you want to reuse a set of nodes in multiple graphs\n- when you want different teams to work on different parts of the graph independently, you can define each part as a subgraph, and as long as the subgraph interface (the input and output schemas) is respected, the parent graph can be built without knowing any details of the subgraph\n\nThe main question when adding subgraphs is how the parent graph and subgraph communicate, i.e. how they pass the [state](./low_level.md#state) between each other during the graph execution. There are two scenarios:\n\n- parent and subgraph have **shared state keys** in their state [schemas](./low_level.md#state). In this case, you can [include the subgraph as a node in the parent graph](../how-tos/subgraph.ipynb#shared-state-schemas)\n\n```python hl_lines=\"12 17\"\n  from langgraph.graph import StateGraph, MessagesState, START\n\n# Subgraph\n\ndef call_model(state: MessagesState):\n      response = model.invoke(state[\"messages\"])\n      return {\"messages\": response}\n\nsubgraph_builder = StateGraph(State)\n  subgraph_builder.add_node(call_model)\n  ...\n  subgraph = subgraph_builder.compile()\n\n# Parent graph\n\nbuilder = StateGraph(State)\n  builder.add_node(\"subgraph_node\", subgraph)\n  builder.add_edge(START, \"subgraph_node\")\n  graph = builder.compile()\n  ...\n  graph.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"hi!\"}]})\n  ```\n\n- parent graph and subgraph have **different schemas** (no shared state keys in their state [schemas](./low_level.md#state)). In this case, you have to [call the subgraph from inside a node in the parent graph](../how-tos/subgraph.ipynb#different-state-schemas): this is useful when the parent graph and the subgraph have different state schemas and you need to transform state before or after calling the subgraph\n\n```python hl_lines=\"7 11 19 28\"\n  from typing_extensions import TypedDict, Annotated\n  from langchain_core.messages import AnyMessage\n  from langgraph.graph import StateGraph, MessagesState, START\n  from langgraph.graph.message import add_messages\n\nclass SubgraphMessagesState(TypedDict):\n      subgraph_messages: Annotated[list[AnyMessage], add_messages]\n\n# Subgraph\n\ndef call_model(state: SubgraphMessagesState):\n      response = model.invoke(state[\"subgraph_messages\"])\n      return {\"subgraph_messages\": response}\n\nsubgraph_builder = StateGraph(SubgraphMessagesState)\n  subgraph_builder.add_node(\"call_model_from_subgraph\", call_model)\n  subgraph_builder.add_edge(START, \"call_model_from_subgraph\")\n  ...\n  subgraph = subgraph_builder.compile()\n\n# Parent graph\n\ndef call_subgraph(state: MessagesState):\n      response = subgraph.invoke({\"subgraph_messages\": state[\"messages\"]})\n      return {\"messages\": response[\"subgraph_messages\"]}\n\nbuilder = StateGraph(State)\n  builder.add_node(\"subgraph_node\", call_subgraph)\n  builder.add_edge(START, \"subgraph_node\")\n  graph = builder.compile()\n  ...\n  graph.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"hi!\"}]})\n  ```\n\n---\nconcepts/langgraph_cloud.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Cloud SaaS\n\nTo deploy a [LangGraph Server](../concepts/langgraph_server.md), follow the how-to guide for [how to deploy to Cloud SaaS](../cloud/deployment/cloud.md).\n\n## Overview\n\nThe Cloud SaaS deployment option is a fully managed model for deployment where we manage the [control plane](./langgraph_control_plane.md) and [data plane](./langgraph_data_plane.md) in our cloud.\n\n|                                    | [Control plane](../concepts/langgraph_control_plane.md)                                                                                     | [Data plane](../concepts/langgraph_data_plane.md)                                                                                                   |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **What is it?**                    | <ul><li>Control plane UI for creating deployments and revisions</li><li>Control plane APIs for creating deployments and revisions</li></ul> | <ul><li>Data plane \"listener\" for reconciling deployments with control plane state</li><li>LangGraph Servers</li><li>Postgres, Redis, etc</li></ul> |\n| **Where is it hosted?**            | LangChain's cloud                                                                                                                           | LangChain's cloud                                                                                                                                   |\n| **Who provisions and manages it?** | LangChain                                                                                                                                   | LangChain                                                                                                                                           |\n\n## Architecture\n\n![Cloud SaaS](./img/self_hosted_control_plane_architecture.png)\n\n---\nconcepts/langgraph_components.md\n---\n\n## Components\n\nThe LangGraph Platform consists of components that work together to support the development, deployment, debugging, and monitoring of LangGraph applications:\n\n- [LangGraph Server](./langgraph_server.md): The server defines an opinionated API and architecture that incorporates best practices for deploying agentic applications, allowing you to focus on building your agent logic rather than developing server infrastructure.\n- [LangGraph CLI](./langgraph_cli.md): LangGraph CLI is a command-line interface that helps to interact with a local LangGraph\n- [LangGraph Studio](./langgraph_studio.md): LangGraph Studio is a specialized IDE that can connect to a LangGraph Server to enable visualization, interaction, and debugging of the application locally.\n- [Python/JS SDK](./sdk.md): The Python/JS SDK provides a programmatic way to interact with deployed LangGraph Applications.\n- [Remote Graph](../how-tos/use-remote-graph.md): A RemoteGraph allows you to interact with any deployed LangGraph application as though it were running locally.\n- [LangGraph control plane](./langgraph_control_plane.md): The LangGraph Control Plane refers to the Control Plane UI where users create and update LangGraph Servers and the Control Plane APIs that support the UI experience.\n- [LangGraph data plane](./langgraph_data_plane.md): The LangGraph Data Plane refers to LangGraph Servers, the corresponding infrastructure for each server, and the \"listener\" application that continuously polls for updates from the LangGraph Control Plane.", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "![LangGraph components](img/lg_platform.png)\n\n---\nconcepts/langgraph_standalone_container.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Standalone Container\n\nTo deploy a [LangGraph Server](../concepts/langgraph_server.md), follow the how-to guide for [how to deploy a Standalone Container](../cloud/deployment/standalone_container.md).\n\n## Overview\n\nThe Standalone Container deployment option is the least restrictive model for deployment. There is no [control plane](./langgraph_control_plane.md). [Data plane](./langgraph_data_plane.md) infrastructure is managed by you.\n\n|                   | [Control plane](../concepts/langgraph_control_plane.md) | [Data plane](../concepts/langgraph_data_plane.md) |\n|-------------------|-------------------|------------|\n| **What is it?** | n/a | <ul><li>LangGraph Servers</li><li>Postgres, Redis, etc</li></ul> |\n| **Where is it hosted?** | n/a | Your cloud |\n| **Who provisions and manages it?** | n/a | You |\n\n!!! warning\n\nLangGraph Platform should not be deployed in serverless environments. Scale to zero may cause task loss and scaling up will not work reliably.\n\n## Architecture\n\n![Standalone Container](./img/langgraph_platform_deployment_architecture.png)\n\n## Compute Platforms\n\n### Kubernetes\n\nThe Standalone Container deployment option supports deploying data plane infrastructure to a Kubernetes cluster.\n\n### Docker\n\nThe Standalone Container deployment option supports deploying data plane infrastructure to any Docker-supported compute platform.\n\n---\nconcepts/human_in_the_loop.md\n---\n\n---\nsearch:\n  boost: 2\ntags:\n  - human-in-the-loop\n  - hil\n  - overview\nhide:\n  - tags\n---\n\n# Human-in-the-loop\n\nTo review, edit, and approve tool calls in an agent or workflow, [use LangGraph's human-in-the-loop features](../how-tos/human_in_the_loop/add-human-in-the-loop.md) to enable human intervention at any point in a workflow. This is especially useful in large language model (LLM)-driven applications where model output may require validation, correction, or additional context.\n\n<figure markdown=\"1\">\n![image](../concepts/img/human_in_the_loop/tool-call-review.png){: style=\"max-height:400px\"}\n</figure>\n\n!!! tip\n\nFor information on how to use human-in-the-loop, see [Enable human intervention](../how-tos/human_in_the_loop/add-human-in-the-loop.md) and [Human-in-the-loop using Server API](../cloud/how-tos/add-human-in-the-loop.md).\n\n## Key capabilities\n\n* **Persistent execution state**: Interrupts use LangGraph's [persistence](./persistence.md) layer, which saves the graph state, to indefinitely pause graph execution until you resume. This is possible because LangGraph checkpoints the graph state after each step, which allows the system to persist execution context and later resume the workflow, continuing from where it left off. This supports asynchronous human review or input without time constraints.\n\nThere are two ways to pause a graph:\n\n- [Dynamic interrupts](../how-tos/human_in_the_loop/add-human-in-the-loop.md#pause-using-interrupt): Use `interrupt` to pause a graph from inside a specific node, based on the current state of the graph.\n    - [Static interrupts](../how-tos/human_in_the_loop/add-human-in-the-loop.md#debug-with-interrupts): Use `interrupt_before` and `interrupt_after` to pause the graph at pre-defined points, either before or after a node executes.\n\n<figure markdown=\"1\">\n    ![image](./img/breakpoints.png){: style=\"max-height:400px\"}\n    <figcaption>An example graph consisting of 3 sequential steps with a breakpoint before step_3. </figcaption> </figure>\n\n* **Flexible integration points**: Human-in-the-loop logic can be introduced at any point in the workflow. This allows targeted human involvement, such as approving API calls, correcting outputs, or guiding conversations.\n\n## Patterns\n\nThere are four typical design patterns that you can implement using `interrupt` and `Command`:\n\n- [Approve or reject](../how-tos/human_in_the_loop/add-human-in-the-loop.md#approve-or-reject): Pause the graph before a critical step, such as an API call, to review and approve the action. If the action is rejected, you can prevent the graph from executing the step, and potentially take an alternative action. This pattern often involves routing the graph based on the human's input.\n- [Edit graph state](../how-tos/human_in_the_loop/add-human-in-the-loop.md#review-and-edit-state): Pause the graph to review and edit the graph state. This is useful for correcting mistakes or updating the state with additional information. This pattern often involves updating the state with the human's input.\n- [Review tool calls](../how-tos/human_in_the_loop/add-human-in-the-loop.md#review-tool-calls): Pause the graph to review and edit tool calls requested by the LLM before tool execution.\n- [Validate human input](../how-tos/human_in_the_loop/add-human-in-the-loop.md#validate-human-input): Pause the graph to validate human input before proceeding with the next step.\n\n---\nconcepts/server-mcp.md\n---\n\n---\ntags:\n  - mcp\n  - platform\nhide:\n  - tags\n---\n\n# MCP endpoint in LangGraph Server\n\nThe [Model Context Protocol (MCP)](./mcp.md) is an open protocol for describing tools and data sources in a model-agnostic format, enabling LLMs to discover and use them via a structured API.\n\n[LangGraph Server](./langgraph_server.md) implements MCP using the [Streamable HTTP transport](https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/transports/#streamable-http). This allows LangGraph **agents** to be exposed as **MCP tools**, making them usable with any MCP-compliant client supporting Streamable HTTP.\n\nThe MCP endpoint is available at `/mcp` on [LangGraph Server](./langgraph_server.md).\n\n## Requirements\n\nTo use MCP, ensure you have the following dependencies installed:\n\n- `langgraph-api >= 0.2.3`\n- `langgraph-sdk >= 0.1.61`\n\nInstall them with:\n\n```bash\npip install \"langgraph-api>=0.2.3\" \"langgraph-sdk>=0.1.61\"\n```\n\n## Exposing an agent as MCP tool\n\nWhen deployed, your agent will appear as a tool in the MCP endpoint\nwith this configuration:\n\n- **Tool name**: The agent's name.\n- **Tool description**: The agent's description.\n- **Tool input schema**: The agent's input schema.\n\n### Setting name and description\n\nYou can set the name and description of your agent in `langgraph.json`:\n\n```json\n{\n  \"graphs\": {\n    \"my_agent\": {\n      \"path\": \"./my_agent/agent.py:graph\",\n      \"description\": \"A description of what the agent does\"\n    }\n  },\n  \"env\": \".env\"\n}\n```\n\nAfter deployment, you can update the name and description using the LangGraph SDK.\n\n### Schema\n\nDefine clear, minimal input and output schemas to avoid exposing unnecessary internal complexity to the LLM.\n\nThe default [MessagesState](./low_level.md#messagesstate) uses `AnyMessage`, which supports many message types but is too general for direct LLM exposure.\n\nInstead, define **custom agents or workflows** that use explicitly typed input and output structures.\n\nFor example, a workflow answering documentation questions might look like this:\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom typing_extensions import TypedDict\n\n# Define input schema\nclass InputState(TypedDict):\n    question: str\n\n# Define output schema\nclass OutputState(TypedDict):\n    answer: str\n\n# Combine input and output\nclass OverallState(InputState, OutputState):\n    pass\n\n# Define the processing node\ndef answer_node(state: InputState):\n    # Replace with actual logic and do something useful\n    return {\"answer\": \"bye\", \"question\": state[\"question\"]}\n\n# Build the graph with explicit schemas\nbuilder = StateGraph(OverallState, input_schema=InputState, output_schema=OutputState)\nbuilder.add_node(answer_node)\nbuilder.add_edge(START, \"answer_node\")\nbuilder.add_edge(\"answer_node\", END)\ngraph = builder.compile()\n\n# Run the graph\nprint(graph.invoke({\"question\": \"hi\"}))\n```\n\nFor more details, see the [low-level concepts guide](https://langchain-ai.github.io/langgraph/concepts/low_level/#state).\n\n## Usage overview\n\nTo enable MCP:\n\n- Upgrade to use langgraph-api>=0.2.3. If you are deploying LangGraph Platform, this will be done for you automatically if you create a new revision.\n- MCP tools (agents) will be automatically exposed.\n- Connect with any MCP-compliant client that supports Streamable HTTP.\n\n### Client\n\nUse an MCP-compliant client to connect to the LangGraph server. The following example shows how to connect using [langchain-mcp-adapters](https://github.com/langchain-ai/langchain-mcp-adapters).\n\nInstall the adapter with:\n\n```bash\npip install langchain-mcp-adapters\n```\n\nHere is an example of how to connect to a remote MCP endpoint and use an agent as a tool:\n\n```python\n# Create server parameters for stdio connection\nfrom mcp import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\nimport asyncio\n\nfrom langchain_mcp_adapters.tools import load_mcp_tools\nfrom langgraph.prebuilt import create_react_agent\n\nserver_params = {\n    \"url\": \"https://mcp-finance-agent.xxx.us.langgraph.app/mcp\",\n    \"headers\": {\n        \"X-Api-Key\":\"lsv2_pt_your_api_key\"\n    }\n}\n\nasync def main():\n    async with streamablehttp_client(**server_params) as (read, write, _):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection\n            await session.initialize()\n\n# Load the remote graph as if it was a tool\n            tools = await load_mcp_tools(session)\n\n# Create and run a react agent with the tools\n            agent = create_react_agent(\"openai:gpt-4.1\", tools)\n\n# Invoke the agent with a message\n            agent_response = await agent.ainvoke({\"messages\": \"What can the finance agent do for me?\"})\n            print(agent_response)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Session behavior\n\nThe current LangGraph MCP implementation does not support sessions. Each `/mcp` request is stateless and independent.\n\n## Authentication\n\nThe `/mcp` endpoint uses the same authentication as the rest of the LangGraph API. Refer to the [authentication guide](./auth.md) for setup details.\n\n## Disable MCP\n\nTo disable the MCP endpoint, set `disable_mcp` to `true` in your `langgraph.json` configuration file:\n\n```json\n{\n  \"http\": {\n    \"disable_mcp\": true\n  }\n}\n```\n\nThis will prevent the server from exposing the `/mcp` endpoint.\n\n---\nconcepts/langgraph_self_hosted_data_plane.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Self-Hosted Data Plane\n\nThere are two versions of the self-hosted deployment: [Self-Hosted Data Plane](./deployment_options.md#self-hosted-data-plane) and [Self-Hosted Control Plane](./deployment_options.md#self-hosted-control-plane).\n\n!!! info \"Important\"\n\nThe Self-Hosted Data Plane deployment option requires an [Enterprise](plans.md) plan.\n\n## Requirements\n\n- You use `langgraph-cli` and/or [LangGraph Studio](./langgraph_studio.md) app to test graph locally.\n- You use `langgraph build` command to build image.\n\n## Self-Hosted Data Plane\n\nThe [Self-Hosted Data Plane](../cloud/deployment/self_hosted_data_plane.md) deployment option is a \"hybrid\" model for deployment where we manage the [control plane](./langgraph_control_plane.md) in our cloud and you manage the [data plane](./langgraph_data_plane.md) in your cloud. This option provides a way to securely manage your data plane infrastructure, while offloading control plane management to us. When using the Self-Hosted Data Plane version, you authenticate with a [LangSmith](https://smith.langchain.com/) API key.\n\n|                                    | [Control plane](../concepts/langgraph_control_plane.md)                                                                                     | [Data plane](../concepts/langgraph_data_plane.md)                                                                                                   |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **What is it?**                    | <ul><li>Control plane UI for creating deployments and revisions</li><li>Control plane APIs for creating deployments and revisions</li></ul> | <ul><li>Data plane \"listener\" for reconciling deployments with control plane state</li><li>LangGraph Servers</li><li>Postgres, Redis, etc</li></ul> |\n| **Where is it hosted?**            | LangChain's cloud                                                                                                                           | Your cloud                                                                                                                                          |\n| **Who provisions and manages it?** | LangChain                                                                                                                                   | You                                                                                                                                                 |\n\nFor information on how to deploy a [LangGraph Server](../concepts/langgraph_server.md) to Self-Hosted Data Plane, see [Deploy to Self-Hosted Data Plane](../cloud/deployment/self_hosted_data_plane.md)\n\n### Architecture\n\n![Self-Hosted Data Plane Architecture](./img/self_hosted_data_plane_architecture.png)\n\n### Compute Platforms\n\n- **Kubernetes**: The Self-Hosted Data Plane deployment option supports deploying data plane infrastructure to any Kubernetes cluster.\n- **Amazon ECS**: Coming soon!\n\n!!! tip\nIf you would like to deploy to Kubernetes, you can follow the [Self-Hosted Data Plane deployment guide](../cloud/deployment/self_hosted_data_plane.md).\n\n---\nconcepts/streaming.md\n---\n\n---\nsearch:\nboost: 2\n---\n\n# Streaming\n\nLangGraph implements a streaming system to surface real-time updates, allowing for responsive and transparent user experiences.\n\nLangGraph’s streaming system lets you surface live feedback from graph runs to your app.  \nThere are three main categories of data you can stream:\n\n1. **Workflow progress** — get state updates after each graph node is executed.\n2. **LLM tokens** — stream language model tokens as they’re generated.\n3. **Custom updates** — emit user-defined signals (e.g., “Fetched 10/100 records”).\n\n## What’s possible with LangGraph streaming\n\n- [**Stream LLM tokens**](../how-tos/streaming.md#messages) — capture token streams from anywhere: inside nodes, subgraphs, or tools.\n- [**Emit progress notifications from tools**](../how-tos/streaming.md#stream-custom-data) — send custom updates or progress signals directly from tool functions.\n- [**Stream from subgraphs**](../how-tos/streaming.md#stream-subgraph-outputs) — include outputs from both the parent graph and any nested subgraphs.\n- [**Use any LLM**](../how-tos/streaming.md#use-with-any-llm) — stream tokens from any LLM, even if it's not a LangChain model using the `custom` streaming mode.\n- [**Use multiple streaming modes**](../how-tos/streaming.md#stream-multiple-modes) — choose from `values` (full state), `updates` (state deltas), `messages` (LLM tokens + metadata), `custom` (arbitrary user data), or `debug` (detailed traces).\n\n---\nconcepts/functional_api.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Functional API concepts\n\n## Overview\n\nThe **Functional API** allows you to add LangGraph's key features — [persistence](./persistence.md), [memory](../how-tos/memory/add-memory.md), [human-in-the-loop](./human_in_the_loop.md), and [streaming](./streaming.md) — to your applications with minimal changes to your existing code.\n\nIt is designed to integrate these features into existing code that may use standard language primitives for branching and control flow, such as `if` statements, `for` loops, and function calls. Unlike many data orchestration frameworks that require restructuring code into an explicit pipeline or DAG, the Functional API allows you to incorporate these capabilities without enforcing a rigid execution model.\n\nThe Functional API uses two key building blocks:\n\n- **`@entrypoint`** – Marks a function as the starting point of a workflow, encapsulating logic and managing execution flow, including handling long-running tasks and interrupts.\n- **`@task`** – Represents a discrete unit of work, such as an API call or data processing step, that can be executed asynchronously within an entrypoint. Tasks return a future-like object that can be awaited or resolved synchronously.\n\nThis provides a minimal abstraction for building workflows with state management and streaming.\n\n!!! tip\n\nFor information on how to use the functional API, see [Use Functional API](../how-tos/use-functional-api.md).\n\n## Functional API vs. Graph API\n\nFor users who prefer a more declarative approach, LangGraph's [Graph API](./low_level.md) allows you to define workflows using a Graph paradigm. Both APIs share the same underlying runtime, so you can use them together in the same application.\n\nHere are some key differences:\n\n- **Control flow**: The Functional API does not require thinking about graph structure. You can use standard Python constructs to define workflows. This will usually trim the amount of code you need to write.\n- **Short-term memory**: The **GraphAPI** requires declaring a [**State**](./low_level.md#state) and may require defining [**reducers**](./low_level.md#reducers) to manage updates to the graph state. `@entrypoint` and `@tasks` do not require explicit state management as their state is scoped to the function and is not shared across functions.\n- **Checkpointing**: Both APIs generate and use checkpoints. In the **Graph API** a new checkpoint is generated after every [superstep](./low_level.md). In the **Functional API**, when tasks are executed, their results are saved to an existing checkpoint associated with the given entrypoint instead of creating a new checkpoint.\n- **Visualization**: The Graph API makes it easy to visualize the workflow as a graph which can be useful for debugging, understanding the workflow, and sharing with others. The Functional API does not support visualization as the graph is dynamically generated during runtime.\n\n## Example\n\nBelow we demonstrate a simple application that writes an essay and [interrupts](human_in_the_loop.md) to request human review.\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import interrupt\n\n@task\ndef write_essay(topic: str) -> str:\n    \"\"\"Write an essay about the given topic.\"\"\"\n    time.sleep(1) # A placeholder for a long-running task.\n    return f\"An essay about topic: {topic}\"\n\n@entrypoint(checkpointer=InMemorySaver())\ndef workflow(topic: str) -> dict:\n    \"\"\"A simple workflow that writes an essay and asks for a review.\"\"\"\n    essay = write_essay(\"cat\").result()\n    is_approved = interrupt({\n        # Any json-serializable payload provided to interrupt as argument.\n        # It will be surfaced on the client side as an Interrupt when streaming data\n        # from the workflow.\n        \"essay\": essay, # The essay we want reviewed.\n        # We can add any additional information that we need.\n        # For example, introduce a key called \"action\" with some instructions.\n        \"action\": \"Please approve/reject the essay\",\n    })\n\nreturn {\n        \"essay\": essay, # The essay that was generated\n        \"is_approved\": is_approved, # Response from HIL\n    }\n```\n\n??? example \"Detailed Explanation\"\n\nThis workflow will write an essay about the topic \"cat\" and then pause to get a review from a human. The workflow can be interrupted for an indefinite amount of time until a review is provided.\n\nWhen the workflow is resumed, it executes from the very start, but because the result of the `writeEssay` task was already saved, the task result will be loaded from the checkpoint instead of being recomputed.\n\n```python\n    import time\n    import uuid\n    from langgraph.func import entrypoint, task\n    from langgraph.types import interrupt\n    from langgraph.checkpoint.memory import InMemorySaver\n\n@task\n    def write_essay(topic: str) -> str:\n        \"\"\"Write an essay about the given topic.\"\"\"\n        time.sleep(1)  # This is a placeholder for a long-running task.\n        return f\"An essay about topic: {topic}\"\n\n@entrypoint(checkpointer=InMemorySaver())\n    def workflow(topic: str) -> dict:\n        \"\"\"A simple workflow that writes an essay and asks for a review.\"\"\"\n        essay = write_essay(\"cat\").result()\n        is_approved = interrupt(\n            {\n                # Any json-serializable payload provided to interrupt as argument.\n                # It will be surfaced on the client side as an Interrupt when streaming data\n                # from the workflow.\n                \"essay\": essay,  # The essay we want reviewed.\n                # We can add any additional information that we need.\n                # For example, introduce a key called \"action\" with some instructions.\n                \"action\": \"Please approve/reject the essay\",\n            }\n        )\n        return {\n            \"essay\": essay,  # The essay that was generated\n            \"is_approved\": is_approved,  # Response from HIL\n        }\n\nthread_id = str(uuid.uuid4())\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n    for item in workflow.stream(\"cat\", config):\n        print(item)\n    # > {'write_essay': 'An essay about topic: cat'}\n    # > {\n    # >     '__interrupt__': (\n    # >        Interrupt(\n    # >            value={\n    # >                'essay': 'An essay about topic: cat',\n    # >                'action': 'Please approve/reject the essay'\n    # >            },\n    # >            id='b9b2b9d788f482663ced6dc755c9e981'\n    # >        ),\n    # >    )\n    # > }\n    ```\n\nAn essay has been written and is ready for review. Once the review is provided, we can resume the workflow:\n\n```python\n    from langgraph.types import Command\n\n# Get review from a user (e.g., via a UI)\n    # In this case, we're using a bool, but this can be any json-serializable value.\n    human_review = True\n\nfor item in workflow.stream(Command(resume=human_review), config):\n        print(item)\n    ```\n\n```pycon\n    {'workflow': {'essay': 'An essay about topic: cat', 'is_approved': False}}\n    ```\n\nThe workflow has been completed and the review has been added to the essay.\n\n## Entrypoint\n\nThe [`@entrypoint`](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.entrypoint) decorator can be used to create a workflow from a function. It encapsulates workflow logic and manages execution flow, including handling _long-running tasks_ and [interrupts](./human_in_the_loop.md).\n\n### Definition\n\nAn **entrypoint** is defined by decorating a function with the `@entrypoint` decorator.\n\nThe function **must accept a single positional argument**, which serves as the workflow input. If you need to pass multiple pieces of data, use a dictionary as the input type for the first argument.\n\nDecorating a function with an `entrypoint` produces a [`Pregel`](https://langchain-ai.github.io/langgraph/reference/pregel/#langgraph.pregel.Pregel.stream) instance which helps to manage the execution of the workflow (e.g., handles streaming, resumption, and checkpointing).\n\nYou will usually want to pass a **checkpointer** to the `@entrypoint` decorator to enable persistence and use features like **human-in-the-loop**.\n\n=== \"Sync\"\n\n```python\n    from langgraph.func import entrypoint\n\n@entrypoint(checkpointer=checkpointer)\n    def my_workflow(some_input: dict) -> int:\n        # some logic that may involve long-running tasks like API calls,\n        # and may be interrupted for human-in-the-loop.\n        ...\n        return result\n    ```\n\n=== \"Async\"\n\n```python\n    from langgraph.func import entrypoint\n\n@entrypoint(checkpointer=checkpointer)\n    async def my_workflow(some_input: dict) -> int:\n        # some logic that may involve long-running tasks like API calls,\n        # and may be interrupted for human-in-the-loop\n        ...\n        return result\n    ```\n\n!!! important \"Serialization\"\n\nThe **inputs** and **outputs** of entrypoints must be JSON-serializable to support checkpointing. Please see the [serialization](#serialization) section for more details.\n\n### Injectable parameters\n\nWhen declaring an `entrypoint`, you can request access to additional parameters that will be injected automatically at run time. These parameters include:\n\n| Parameter    | Description                                                                                                                                                        |\n| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **previous** | Access the state associated with the previous `checkpoint` for the given thread. See [short-term-memory](#short-term-memory).                                      |\n| **store**    | An instance of [BaseStore][langgraph.store.base.BaseStore]. Useful for [long-term memory](../how-tos/use-functional-api.md#long-term-memory).                      |\n| **writer**   | Use to access the StreamWriter when working with Async Python < 3.11. See [streaming with functional API for details](../how-tos/use-functional-api.md#streaming). |\n| **config**   | For accessing run time configuration. See [RunnableConfig](https://python.langchain.com/docs/concepts/runnables/#runnableconfig) for information.                  |\n\n!!! important\n\nDeclare the parameters with the appropriate name and type annotation.\n\n??? example \"Requesting Injectable Parameters\"\n\n```python\n    from langchain_core.runnables import RunnableConfig\n    from langgraph.func import entrypoint\n    from langgraph.store.base import BaseStore\n    from langgraph.store.memory import InMemoryStore\n\nin_memory_store = InMemoryStore(...)  # An instance of InMemoryStore for long-term memory\n\n@entrypoint(\n        checkpointer=checkpointer,  # Specify the checkpointer\n        store=in_memory_store  # Specify the store\n    )\n    def my_workflow(\n        some_input: dict,  # The input (e.g., passed via `invoke`)\n        *,\n        previous: Any = None, # For short-term memory\n        store: BaseStore,  # For long-term memory\n        writer: StreamWriter,  # For streaming custom data\n        config: RunnableConfig  # For accessing the configuration passed to the entrypoint\n    ) -> ...:\n    ```\n\n### Executing\n\nUsing the [`@entrypoint`](#entrypoint) yields a [`Pregel`](https://langchain-ai.github.io/langgraph/reference/pregel/#langgraph.pregel.Pregel.stream) object that can be executed using the `invoke`, `ainvoke`, `stream`, and `astream` methods.\n\n=== \"Invoke\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n    my_workflow.invoke(some_input, config)  # Wait for the result synchronously\n    ```\n\n=== \"Async Invoke\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n    await my_workflow.ainvoke(some_input, config)  # Await result asynchronously\n    ```\n\n=== \"Stream\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nfor chunk in my_workflow.stream(some_input, config):\n        print(chunk)\n    ```\n\n=== \"Async Stream\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nasync for chunk in my_workflow.astream(some_input, config):\n        print(chunk)\n    ```\n\n### Resuming\n\nResuming an execution after an [interrupt](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Interrupt) can be done by passing a **resume** value to the [Command](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Command) primitive.\n\n=== \"Invoke\"", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "```python\n    from langgraph.types import Command\n\nconfig = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nmy_workflow.invoke(Command(resume=some_resume_value), config)\n    ```\n\n=== \"Async Invoke\"\n\n```python\n    from langgraph.types import Command\n\nconfig = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nawait my_workflow.ainvoke(Command(resume=some_resume_value), config)\n    ```\n\n=== \"Stream\"\n\n```python\n    from langgraph.types import Command\n\nconfig = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nfor chunk in my_workflow.stream(Command(resume=some_resume_value), config):\n        print(chunk)\n    ```\n\n=== \"Async Stream\"\n\n```python\n    from langgraph.types import Command\n\nconfig = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nasync for chunk in my_workflow.astream(Command(resume=some_resume_value), config):\n        print(chunk)\n    ```\n\n**Resuming after an error**\n\nTo resume after an error, run the `entrypoint` with a `None` and the same **thread id** (config).\n\nThis assumes that the underlying **error** has been resolved and execution can proceed successfully.\n\n=== \"Invoke\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nmy_workflow.invoke(None, config)\n    ```\n\n=== \"Async Invoke\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nawait my_workflow.ainvoke(None, config)\n    ```\n\n=== \"Stream\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nfor chunk in my_workflow.stream(None, config):\n        print(chunk)\n    ```\n\n=== \"Async Stream\"\n\n```python\n    config = {\n        \"configurable\": {\n            \"thread_id\": \"some_thread_id\"\n        }\n    }\n\nasync for chunk in my_workflow.astream(None, config):\n        print(chunk)\n    ```\n\n### Short-term memory\n\nWhen an `entrypoint` is defined with a `checkpointer`, it stores information between successive invocations on the same **thread id** in [checkpoints](persistence.md#checkpoints).\n\nThis allows accessing the state from the previous invocation using the `previous` parameter.\n\nBy default, the `previous` parameter is the return value of the previous invocation.\n\n```python\n@entrypoint(checkpointer=checkpointer)\ndef my_workflow(number: int, *, previous: Any = None) -> int:\n    previous = previous or 0\n    return number + previous\n\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"some_thread_id\"\n    }\n}\n\nmy_workflow.invoke(1, config)  # 1 (previous was None)\nmy_workflow.invoke(2, config)  # 3 (previous was 1 from the previous invocation)\n```\n\n#### `entrypoint.final`\n\n[`entrypoint.final`](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.entrypoint.final) is a special primitive that can be returned from an entrypoint and allows **decoupling** the value that is **saved in the checkpoint** from the **return value of the entrypoint**.\n\nThe first value is the return value of the entrypoint, and the second value is the value that will be saved in the checkpoint. The type annotation is `entrypoint.final[return_type, save_type]`.\n\n```python\n@entrypoint(checkpointer=checkpointer)\ndef my_workflow(number: int, *, previous: Any = None) -> entrypoint.final[int, int]:\n    previous = previous or 0\n    # This will return the previous value to the caller, saving\n    # 2 * number to the checkpoint, which will be used in the next invocation\n    # for the `previous` parameter.\n    return entrypoint.final(value=previous, save=2 * number)\n\nconfig = {\n    \"configurable\": {\n        \"thread_id\": \"1\"\n    }\n}\n\nmy_workflow.invoke(3, config)  # 0 (previous was None)\nmy_workflow.invoke(1, config)  # 6 (previous was 3 * 2 from the previous invocation)\n```\n\n## Task\n\nA **task** represents a discrete unit of work, such as an API call or data processing step. It has two key characteristics:\n\n- **Asynchronous Execution**: Tasks are designed to be executed asynchronously, allowing multiple operations to run concurrently without blocking.\n- **Checkpointing**: Task results are saved to a checkpoint, enabling resumption of the workflow from the last saved state. (See [persistence](persistence.md) for more details).\n\n### Definition\n\nTasks are defined using the `@task` decorator, which wraps a regular Python function.\n\n```python\nfrom langgraph.func import task\n\n@task()\ndef slow_computation(input_value):\n    # Simulate a long-running operation\n    ...\n    return result\n```\n\n!!! important \"Serialization\"\n\nThe **outputs** of tasks must be JSON-serializable to support checkpointing.\n\n### Execution\n\n**Tasks** can only be called from within an **entrypoint**, another **task**, or a [state graph node](./low_level.md#nodes).\n\nTasks _cannot_ be called directly from the main application code.\n\nWhen you call a **task**, it returns _immediately_ with a future object. A future is a placeholder for a result that will be available later.\n\nTo obtain the result of a **task**, you can either wait for it synchronously (using `result()`) or await it asynchronously (using `await`).\n\n=== \"Synchronous Invocation\"\n\n```python\n    @entrypoint(checkpointer=checkpointer)\n    def my_workflow(some_input: int) -> int:\n        future = slow_computation(some_input)\n        return future.result()  # Wait for the result synchronously\n    ```\n\n=== \"Asynchronous Invocation\"\n\n```python\n    @entrypoint(checkpointer=checkpointer)\n    async def my_workflow(some_input: int) -> int:\n        return await slow_computation(some_input)  # Await result asynchronously\n    ```\n\n## When to use a task\n\n**Tasks** are useful in the following scenarios:\n\n- **Checkpointing**: When you need to save the result of a long-running operation to a checkpoint, so you don't need to recompute it when resuming the workflow.\n- **Human-in-the-loop**: If you're building a workflow that requires human intervention, you MUST use **tasks** to encapsulate any randomness (e.g., API calls) to ensure that the workflow can be resumed correctly. See the [determinism](#determinism) section for more details.\n- **Parallel Execution**: For I/O-bound tasks, **tasks** enable parallel execution, allowing multiple operations to run concurrently without blocking (e.g., calling multiple APIs).\n- **Observability**: Wrapping operations in **tasks** provides a way to track the progress of the workflow and monitor the execution of individual operations using [LangSmith](https://docs.smith.langchain.com/).\n- **Retryable Work**: When work needs to be retried to handle failures or inconsistencies, **tasks** provide a way to encapsulate and manage the retry logic.\n\n## Serialization\n\nThere are two key aspects to serialization in LangGraph:\n\n1. `entrypoint` inputs and outputs must be JSON-serializable.\n2. `task` outputs must be JSON-serializable.\n\nThese requirements are necessary for enabling checkpointing and workflow resumption. Use python primitives like dictionaries, lists, strings, numbers, and booleans to ensure that your inputs and outputs are serializable.\n\nSerialization ensures that workflow state, such as task results and intermediate values, can be reliably saved and restored. This is critical for enabling human-in-the-loop interactions, fault tolerance, and parallel execution.\n\nProviding non-serializable inputs or outputs will result in a runtime error when a workflow is configured with a checkpointer.\n\n## Determinism\n\nTo utilize features like **human-in-the-loop**, any randomness should be encapsulated inside of **tasks**. This guarantees that when execution is halted (e.g., for human in the loop) and then resumed, it will follow the same _sequence of steps_, even if **task** results are non-deterministic.\n\nLangGraph achieves this behavior by persisting **task** and [**subgraph**](./subgraphs.md) results as they execute. A well-designed workflow ensures that resuming execution follows the _same sequence of steps_, allowing previously computed results to be retrieved correctly without having to re-execute them. This is particularly useful for long-running **tasks** or **tasks** with non-deterministic results, as it avoids repeating previously done work and allows resuming from essentially the same.\n\nWhile different runs of a workflow can produce different results, resuming a **specific** run should always follow the same sequence of recorded steps. This allows LangGraph to efficiently look up **task** and **subgraph** results that were executed prior to the graph being interrupted and avoid recomputing them.\n\n## Idempotency\n\nIdempotency ensures that running the same operation multiple times produces the same result. This helps prevent duplicate API calls and redundant processing if a step is rerun due to a failure. Always place API calls inside **tasks** functions for checkpointing, and design them to be idempotent in case of re-execution. Re-execution can occur if a **task** starts, but does not complete successfully. Then, if the workflow is resumed, the **task** will run again. Use idempotency keys or verify existing results to avoid duplication.\n\n## Common Pitfalls\n\n### Handling side effects\n\nEncapsulate side effects (e.g., writing to a file, sending an email) in tasks to ensure they are not executed multiple times when resuming a workflow.\n\n=== \"Incorrect\"\n\nIn this example, a side effect (writing to a file) is directly included in the workflow, so it will be executed a second time when resuming the workflow.\n\n```python hl_lines=\"5 6\"\n    @entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        # This code will be executed a second time when resuming the workflow.\n        # Which is likely not what you want.\n        with open(\"output.txt\", \"w\") as f:\n            f.write(\"Side effect executed\")\n        value = interrupt(\"question\")\n        return value\n    ```\n\n=== \"Correct\"\n\nIn this example, the side effect is encapsulated in a task, ensuring consistent execution upon resumption.\n\n```python hl_lines=\"3 4\"\n    from langgraph.func import task\n\n@task\n    def write_to_file():\n        with open(\"output.txt\", \"w\") as f:\n            f.write(\"Side effect executed\")\n\n@entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        # The side effect is now encapsulated in a task.\n        write_to_file().result()\n        value = interrupt(\"question\")\n        return value\n    ```\n\n### Non-deterministic control flow\n\nOperations that might give different results each time (like getting current time or random numbers) should be encapsulated in tasks to ensure that on resume, the same result is returned.\n\n- In a task: Get random number (5) → interrupt → resume → (returns 5 again) → ...\n- Not in a task: Get random number (5) → interrupt → resume → get new random number (7) → ...\n\nThis is especially important when using **human-in-the-loop** workflows with multiple interrupts calls. LangGraph keeps a list of resume values for each task/entrypoint. When an interrupt is encountered, it's matched with the corresponding resume value. This matching is strictly **index-based**, so the order of the resume values should match the order of the interrupts.\n\nIf order of execution is not maintained when resuming, one `interrupt` call may be matched with the wrong `resume` value, leading to incorrect results.\n\nPlease read the section on [determinism](#determinism) for more details.\n\n=== \"Incorrect\"\n\nIn this example, the workflow uses the current time to determine which task to execute. This is non-deterministic because the result of the workflow depends on the time at which it is executed.\n\n```python hl_lines=\"6\"\n    from langgraph.func import entrypoint\n\n@entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        t0 = inputs[\"t0\"]\n        t1 = time.time()\n\ndelta_t = t1 - t0\n\nif delta_t > 1:\n            result = slow_task(1).result()\n            value = interrupt(\"question\")\n        else:\n            result = slow_task(2).result()\n            value = interrupt(\"question\")\n\nreturn {\n            \"result\": result,\n            \"value\": value\n        }\n    ```\n\n=== \"Correct\"\n\nIn this example, the workflow uses the input `t0` to determine which task to execute. This is deterministic because the result of the workflow depends only on the input.\n\n```python hl_lines=\"5 6 12\"\n    import time\n\nfrom langgraph.func import task\n\n@task\n    def get_time() -> float:\n        return time.time()\n\n@entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        t0 = inputs[\"t0\"]\n        t1 = get_time().result()\n\ndelta_t = t1 - t0\n\nif delta_t > 1:\n            result = slow_task(1).result()\n            value = interrupt(\"question\")\n        else:\n            result = slow_task(2).result()\n            value = interrupt(\"question\")\n\nreturn {\n            \"result\": result,\n            \"value\": value\n        }\n    ```\n\n---\nconcepts/deployment_options.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Deployment Options\n\n## Free deployment\n\n[Local](../tutorials/langgraph-platform/local-server.md): Deploy for local testing and development.\n\n## Production deployment\n\nThere are 4 main options for deploying with the [LangGraph Platform](langgraph_platform.md):\n\n1. [Cloud SaaS](#cloud-saas)\n\n1. [Self-Hosted Data Plane](#self-hosted-data-plane)\n\n1. [Self-Hosted Control Plane](#self-hosted-control-plane)\n\n1. [Standalone Container](#standalone-container)\n\nA quick comparison:\n\n|                      | **Cloud SaaS** | **Self-Hosted Data Plane** | **Self-Hosted Control Plane** | **Standalone Container** |\n|----------------------|----------------|----------------------------|-------------------------------|--------------------------|\n| **[Control plane UI/API](../concepts/langgraph_control_plane.md)** | Yes | Yes | Yes | No |\n| **CI/CD** | Managed internally by platform | Managed externally by you | Managed externally by you | Managed externally by you |\n| **Data/compute residency** | LangChain's cloud | Your cloud | Your cloud | Your cloud |\n| **LangSmith compatibility** | Trace to LangSmith SaaS | Trace to LangSmith SaaS | Trace to Self-Hosted LangSmith | Optional tracing |\n| **[Pricing](https://www.langchain.com/pricing-langgraph-platform)** | Plus | Enterprise | Enterprise | Enterprise |\n\n## Cloud SaaS\n\nThe [Cloud SaaS](./langgraph_cloud.md) deployment option is a fully managed model for deployment where we manage the [control plane](./langgraph_control_plane.md) and [data plane](./langgraph_data_plane.md) in our cloud. This option provides a simple way to deploy and manage your LangGraph Servers.\n\nConnect your GitHub repositories to the platform and deploy your LangGraph Servers from the [control plane UI](./langgraph_control_plane.md#control-plane-ui). The build process (i.e. CI/CD) is managed internally by the platform.\n\nFor more information, please see:\n\n* [Cloud SaaS Conceptual Guide](./langgraph_cloud.md)\n* [How to deploy to Cloud SaaS](../cloud/deployment/cloud.md)\n\n## Self-Hosted Data Plane\n\n!!! info \"Important\"\n    The Self-Hosted Data Plane deployment option requires an [Enterprise](../concepts/plans.md) plan.\n\nThe [Self-Hosted Data Plane](./langgraph_self_hosted_data_plane.md) deployment option is a \"hybrid\" model for deployment where we manage the [control plane](./langgraph_control_plane.md) in our cloud and you manage the [data plane](./langgraph_data_plane.md) in your cloud. This option provides a way to securely manage your data plane infrastructure, while offloading control plane management to us.\n\nBuild a Docker image using the [LangGraph CLI](./langgraph_cli.md) and deploy your LangGraph Server from the [control plane UI](./langgraph_control_plane.md#control-plane-ui).\n\nSupported Compute Platforms: [Kubernetes](https://kubernetes.io/), [Amazon ECS](https://aws.amazon.com/ecs/) (coming soon!)\n\nFor more information, please see:\n\n* [Self-Hosted Data Plane Conceptual Guide](./langgraph_self_hosted_data_plane.md)\n* [How to deploy the Self-Hosted Data Plane](../cloud/deployment/self_hosted_data_plane.md)\n\n## Self-Hosted Control Plane\n\n!!! info \"Important\"\n    The Self-Hosted Control Plane deployment option requires an [Enterprise](../concepts/plans.md) plan.\n\nThe [Self-Hosted Control Plane](./langgraph_self_hosted_control_plane.md) deployment option is a fully self-hosted model for deployment where you manage the [control plane](./langgraph_control_plane.md) and [data plane](./langgraph_data_plane.md) in your cloud. This option gives you full control and responsibility of the control plane and data plane infrastructure.\n\nBuild a Docker image using the [LangGraph CLI](./langgraph_cli.md) and deploy your LangGraph Server from the [control plane UI](./langgraph_control_plane.md#control-plane-ui).\n\nSupported Compute Platforms: [Kubernetes](https://kubernetes.io/)\n\nFor more information, please see:\n\n* [Self-Hosted Control Plane Conceptual Guide](./langgraph_self_hosted_control_plane.md)\n* [How to deploy the Self-Hosted Control Plane](../cloud/deployment/self_hosted_control_plane.md)\n\n## Standalone Container\n\nThe [Standalone Container](./langgraph_standalone_container.md) deployment option is the least restrictive model for deployment. Deploy standalone instances of a LangGraph Server in your cloud, using any of the [available](./plans.md) license options.\n\nBuild a Docker image using the [LangGraph CLI](./langgraph_cli.md) and deploy your LangGraph Server using the container deployment tooling of your choice. Images can be deployed to any compute platform.\n\nFor more information, please see:\n\n* [Standalone Container Conceptual Guide](./langgraph_standalone_container.md)\n* [How to deploy a Standalone Container](../cloud/deployment/standalone_container.md)\n\n## Related\n\nFor more information, please see:\n\n* [LangGraph Platform plans](./plans.md)\n* [LangGraph Platform pricing](https://www.langchain.com/langgraph-platform-pricing)\n\n---\nconcepts/sdk.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph SDK\n\nLangGraph Platform provides a python SDK for interacting with [LangGraph Server](./langgraph_server.md).\n\n!!! tip \"Python SDK reference\"\n\nFor detailed information about the Python SDK, see [Python SDK reference docs](../cloud/reference/sdk/python_sdk_ref.md).\n\n## Installation\n\nYou can install the LangGraph SDK using the following command:\n\n```bash\npip install langgraph-sdk\n```\n\n## Python sync vs. async\n\nThe Python SDK provides both synchronous (`get_sync_client`) and asynchronous (`get_client`) clients for interacting with LangGraph Server:\n\n=== \"Sync\"\n\n```python\n    from langgraph_sdk import get_sync_client\n\nclient = get_sync_client(url=..., api_key=...)\n    client.assistants.search()\n    ```\n\n=== \"Async\"\n\n```python\n    from langgraph_sdk import get_client\n\nclient = get_client(url=..., api_key=...)\n    await client.assistants.search()\n    ```\n\n## Learn more\n\n- [Python SDK Reference](../cloud/reference/sdk/python_sdk_ref.md)\n- [LangGraph CLI API Reference](../cloud/reference/cli.md)\n\n---\nconcepts/langgraph_server.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Server\n\n**LangGraph Server** offers an API for creating and managing agent-based applications. It is built on the concept of [assistants](assistants.md), which are agents configured for specific tasks, and includes built-in [persistence](persistence.md#memory-store) and a **task queue**. This versatile API supports a wide range of agentic application use cases, from background processing to real-time interactions.\n\nUse LangGraph Server to create and manage [assistants](assistants.md), [threads](./persistence.md#threads), [runs](./assistants.md#execution), [cron jobs](../cloud/concepts/cron_jobs.md), [webhooks](../cloud/concepts/webhooks.md), and more.\n\n!!! tip \"API reference\"\n  \n    For detailed information on the API endpoints and data models, see [LangGraph Platform API reference docs](../cloud/reference/api/api_ref.html).\n\n## Application structure\n\nTo deploy a LangGraph Server application, you need to specify the graph(s) you want to deploy, as well as any relevant configuration settings, such as dependencies and environment variables.\n\nRead the [application structure](./application_structure.md) guide to learn how to structure your LangGraph application for deployment.\n\n## Parts of a deployment\n\nWhen you deploy LangGraph Server, you are deploying one or more [graphs](#graphs), a database for [persistence](persistence.md), and a task queue.\n\n### Graphs\n\nWhen you deploy a graph with LangGraph Server, you are deploying a \"blueprint\" for an [Assistant](assistants.md).\n\nAn [Assistant](assistants.md) is a graph paired with specific configuration settings. You can create multiple assistants per graph, each with unique settings to accommodate different use cases\nthat can be served by the same graph.\n\nUpon deployment, LangGraph Server will automatically create a default assistant for each graph using the graph's default configuration settings.\n\n!!! note\n\nWe often think of a graph as implementing an [agent](agentic_concepts.md), but a graph does not necessarily need to implement an agent. For example, a graph could implement a simple\n    chatbot that only supports back-and-forth conversation, without the ability to influence any application control flow. In reality, as applications get more complex, a graph will often implement a more complex flow that may use [multiple agents](./multi_agent.md) working in tandem.\n\n### Persistence and task queue\n\nLangGraph Server leverages a database for [persistence](persistence.md) and a task queue.\n\nCurrently, only [Postgres](https://www.postgresql.org/) is supported as a database for LangGraph Server and [Redis](https://redis.io/) as the task queue.\n\nIf you're deploying using [LangGraph Platform](./langgraph_cloud.md), these components are managed for you. If you're deploying LangGraph Server on your own infrastructure, you'll need to set up and manage these components yourself.\n\nPlease review the [deployment options](./deployment_options.md) guide for more information on how these components are set up and managed.\n\n## Learn more\n\n* LangGraph [Application Structure](./application_structure.md) guide explains how to structure your LangGraph application for deployment.\n* The [LangGraph Platform API Reference](../cloud/reference/api/api_ref.html) provides detailed information on the API endpoints and data models.\n\n---\nconcepts/langgraph_platform.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Platform\n\nDevelop, deploy, scale, and manage agents with **LangGraph Platform** — the purpose-built platform for long-running, agentic workflows.\n\n!!! tip \"Get started with LangGraph Platform\"\n\nCheck out the [LangGraph Platform quickstart](../tutorials/langgraph-platform/local-server.md) for instructions on how to use LangGraph Platform to run a LangGraph application locally.\n\n## Why use LangGraph Platform?\n\n<div align=\"center\"><iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pfAQxBS5z88?si=XGS6Chydn6lhSO1S\" title=\"What is LangGraph Platform?\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe></div>\n\nLangGraph Platform makes it easy to get your agent running in production —  whether it’s built with LangGraph or another framework — so you can focus on your app logic, not infrastructure. Deploy with one click to get a live endpoint, and use our robust APIs and built-in task queues to handle production scale.\n\n- **[Streaming Support](../cloud/how-tos/streaming.md)**: As agents grow more sophisticated, they often benefit from streaming both token outputs and intermediate states back to the user. Without this, users are left waiting for potentially long operations with no feedback. LangGraph Server provides multiple streaming modes optimized for various application needs.\n\n- **[Background Runs](../cloud/how-tos/background_run.md)**: For agents that take longer to process (e.g., hours), maintaining an open connection can be impractical. The LangGraph Server supports launching agent runs in the background and provides both polling endpoints and webhooks to monitor run status effectively.\n \n- **Support for long runs**: Regular server setups often encounter timeouts or disruptions when handling requests that take a long time to complete. LangGraph Server’s API provides robust support for these tasks by sending regular heartbeat signals, preventing unexpected connection closures during prolonged processes.\n\n- **Handling Burstiness**: Certain applications, especially those with real-time user interaction, may experience \"bursty\" request loads where numerous requests hit the server simultaneously. LangGraph Server includes a task queue, ensuring requests are handled consistently without loss, even under heavy loads.\n\n- **[Double-texting](../cloud/how-tos/interrupt_concurrent.md)**: In user-driven applications, it’s common for users to send multiple messages rapidly. This “double texting” can disrupt agent flows if not handled properly. LangGraph Server offers built-in strategies to address and manage such interactions.\n\n- **[Checkpointers and memory management](persistence.md#checkpoints)**: For agents needing persistence (e.g., conversation memory), deploying a robust storage solution can be complex. LangGraph Platform includes optimized [checkpointers](persistence.md#checkpoints) and a [memory store](persistence.md#memory-store), managing state across sessions without the need for custom solutions.\n\n- **[Human-in-the-loop support](../cloud/how-tos/human_in_the_loop_breakpoint.md)**: In many applications, users require a way to intervene in agent processes. LangGraph Server provides specialized endpoints for human-in-the-loop scenarios, simplifying the integration of manual oversight into agent workflows.\n\n- **[LangGraph Studio](./langgraph_studio.md)**: Enables visualization, interaction, and debugging of agentic systems that implement the LangGraph Server API protocol. Studio also integrates with LangSmith to enable tracing, evaluation, and prompt engineering.\n\n- **[Deployment](./deployment_options.md)**: There are four ways to deploy on LangGraph Platform: [Cloud SaaS](../concepts/langgraph_cloud.md), [Self-Hosted Data Plane](../concepts/langgraph_self_hosted_data_plane.md), [Self-Hosted Control Plane](../concepts/langgraph_self_hosted_control_plane.md), and [Standalone Container](../concepts/langgraph_standalone_container.md).\n\n---\nconcepts/tracing.md\n---\n\n# Tracing\n\nTraces are a series of steps that your application takes to go from input to output. Each of these individual steps is represented by a run. You can use [LangSmith](https://smith.langchain.com/) to visualize these execution steps. To use it, [enable tracing for your application](../how-tos/enable-tracing.md). This enables you to do the following:\n\n- [Debug a locally running application](../cloud/how-tos/clone_traces_studio.md).\n- [Evaluate the application performance](../agents/evals.md).\n- [Monitor the application](https://docs.smith.langchain.com/observability/how_to_guides/dashboards).\n\nTo get started, sign up for a free account at [LangSmith](https://smith.langchain.com/).\n\n## Learn more\n\n- [Graph runs in LangSmith](../how-tos/run-id-langsmith.md)\n- [LangSmith Observability quickstart](https://docs.smith.langchain.com/observability)\n- [Trace with LangGraph](https://docs.smith.langchain.com/observability/how_to_guides/trace_with_langgraph)\n- [Tracing conceptual guide](https://docs.smith.langchain.com/observability/concepts#traces)\n\n---\nconcepts/memory.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Memory", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "[Memory](../how-tos/memory/add-memory.md) is a system that remembers information about previous interactions. For AI agents, memory is crucial because it lets them remember previous interactions, learn from feedback, and adapt to user preferences. As agents tackle more complex tasks with numerous user interactions, this capability becomes essential for both efficiency and user satisfaction.\n\nThis conceptual guide covers two types of memory, based on their recall scope:\n\n- [Short-term memory](#short-term-memory), or [thread](persistence.md#threads)-scoped memory, tracks the ongoing conversation by maintaining message history within a session. LangGraph manages short-term memory as a part of your agent's [state](low_level.md#state). State is persisted to a database using a [checkpointer](persistence.md#checkpoints) so the thread can be resumed at any time. Short-term memory updates when the graph is invoked or a step is completed, and the State is read at the start of each step.\n\n- [Long-term memory](#long-term-memory) stores user-specific or application-level data across sessions and is shared _across_ conversational threads. It can be recalled _at any time_ and _in any thread_. Memories are scoped to any custom namespace, not just within a single thread ID. LangGraph provides [stores](persistence.md#memory-store) ([reference doc](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.BaseStore)) to let you save and recall long-term memories.\n\n![](img/memory/short-vs-long.png)\n\n## Short-term memory\n\n[Short-term memory](../how-tos/memory/add-memory.md#add-short-term-memory) lets your application remember previous interactions within a single [thread](persistence.md#threads) or conversation. A [thread](persistence.md#threads) organizes multiple interactions in a session, similar to the way email groups messages in a single conversation.\n\nLangGraph manages short-term memory as part of the agent's state, persisted via thread-scoped checkpoints. This state can normally include the conversation history along with other stateful data, such as uploaded files, retrieved documents, or generated artifacts. By storing these in the graph's state, the bot can access the full context for a given conversation while maintaining separation between different threads.\n\n### Manage short-term memory\n\nConversation history is the most common form of short-term memory, and long conversations pose a challenge to today's LLMs. A full history may not fit inside an LLM's context window, resulting in an irrecoverable error. Even if your LLM supports the full context length, most LLMs still perform poorly over long contexts. They get \"distracted\" by stale or off-topic content, all while suffering from slower response times and higher costs.\n\nChat models accept context using messages, which include developer provided instructions (a system message) and user inputs (human messages). In chat applications, messages alternate between human inputs and model responses, resulting in a list of messages that grows longer over time. Because context windows are limited and token-rich message lists can be costly, many applications can benefit from using techniques to manually remove or forget stale information.\n\n![](img/memory/filter.png)\n\nFor more information on common techniques for managing messages, see the [Add and manage memory](../how-tos/memory/add-memory.md#manage-short-term-memory) guide.\n\n## Long-term memory\n\n[Long-term memory](../how-tos/memory/add-memory.md#add-long-term-memory) in LangGraph allows systems to retain information across different conversations or sessions. Unlike short-term memory, which is **thread-scoped**, long-term memory is saved within custom \"namespaces.\"\n\nLong-term memory is a complex challenge without a one-size-fits-all solution. However, the following questions provide a framework to help you navigate the different techniques:\n\n- [What is the type of memory?](#memory-types) Humans use memories to remember facts ([semantic memory](#semantic-memory)), experiences ([episodic memory](#episodic-memory)), and rules ([procedural memory](#procedural-memory)). AI agents can use memory in the same ways. For example, AI agents can use memory to remember specific facts about a user to accomplish a task.\n\n- [When do you want to update memories?](#writing-memories) Memory can be updated as part of an agent's application logic (e.g., \"on the hot path\"). In this case, the agent typically decides to remember facts before responding to a user. Alternatively, memory can be updated as a background task (logic that runs in the background / asynchronously and generates memories). We explain the tradeoffs between these approaches in the [section below](#writing-memories).\n\n### Memory types\n\nDifferent applications require various types of memory. Although the analogy isn't perfect, examining [human memory types](https://www.psychologytoday.com/us/basics/memory/types-of-memory?ref=blog.langchain.dev) can be insightful. Some research (e.g., the [CoALA paper](https://arxiv.org/pdf/2309.02427)) have even mapped these human memory types to those used in AI agents.\n\n| Memory Type | What is Stored | Human Example | Agent Example |\n|-------------|----------------|---------------|---------------|\n| [Semantic](#semantic-memory) | Facts | Things I learned in school | Facts about a user |\n| [Episodic](#episodic-memory) | Experiences | Things I did | Past agent actions |\n| [Procedural](#procedural-memory) | Instructions | Instincts or motor skills | Agent system prompt |\n\n#### Semantic memory\n\n[Semantic memory](https://en.wikipedia.org/wiki/Semantic_memory), both in humans and AI agents, involves the retention of specific facts and concepts. In humans, it can include information learned in school and the understanding of concepts and their relationships. For AI agents, semantic memory is often used to personalize applications by remembering facts or concepts from past interactions.\n\n!!! note\n\nSemantic memory is different from \"semantic search,\" which is a technique for finding similar content using \"meaning\" (usually as embeddings). Semantic memory is a term from psychology, referring to storing facts and knowledge, while semantic search is a method for retrieving information based on meaning rather than exact matches.\n\n##### Profile\n\nSemantic memories can be managed in different ways. For example, memories can be a single, continuously updated \"profile\" of well-scoped and specific information about a user, organization, or other entity (including the agent itself). A profile is generally just a JSON document with various key-value pairs you've selected to represent your domain.\n\nWhen remembering a profile, you will want to make sure that you are **updating** the profile each time. As a result, you will want to pass in the previous profile and [ask the model to generate a new profile](https://github.com/langchain-ai/memory-template) (or some [JSON patch](https://github.com/hinthornw/trustcall) to apply to the old profile). This can be become error-prone as the profile gets larger, and may benefit from splitting a profile into multiple documents or **strict** decoding when generating documents to ensure the memory schemas remains valid.\n\n![](img/memory/update-profile.png)\n\n##### Collection\n\nAlternatively, memories can be a collection of documents that are continuously updated and extended over time. Each individual memory can be more narrowly scoped and easier to generate, which means that you're less likely to **lose** information over time. It's easier for an LLM to generate _new_ objects for new information than reconcile new information with an existing profile. As a result, a document collection tends to lead to [higher recall downstream](https://en.wikipedia.org/wiki/Precision_and_recall).\n\nHowever, this shifts some complexity memory updating. The model must now _delete_ or _update_ existing items in the list, which can be tricky. In addition, some models may default to over-inserting and others may default to over-updating. See the [Trustcall](https://github.com/hinthornw/trustcall) package for one way to manage this and consider evaluation (e.g., with a tool like [LangSmith](https://docs.smith.langchain.com/tutorials/Developers/evaluation)) to help you tune the behavior.\n\nWorking with document collections also shifts complexity to memory **search** over the list. The `Store` currently supports both [semantic search](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.SearchOp.query) and [filtering by content](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.SearchOp.filter).\n\nFinally, using a collection of memories can make it challenging to provide comprehensive context to the model. While individual memories may follow a specific schema, this structure might not capture the full context or relationships between memories. As a result, when using these memories to generate responses, the model may lack important contextual information that would be more readily available in a unified profile approach.\n\n![](img/memory/update-list.png)\n\nRegardless of memory management approach, the central point is that the agent will use the semantic memories to [ground its responses](https://python.langchain.com/docs/concepts/rag/), which often leads to more personalized and relevant interactions.\n\n#### Episodic memory\n\n[Episodic memory](https://en.wikipedia.org/wiki/Episodic_memory), in both humans and AI agents, involves recalling past events or actions. The [CoALA paper](https://arxiv.org/pdf/2309.02427) frames this well: facts can be written to semantic memory, whereas *experiences* can be written to episodic memory. For AI agents, episodic memory is often used to help an agent remember how to accomplish a task.\n\nIn practice, episodic memories are often implemented through [few-shot example prompting](https://python.langchain.com/docs/concepts/few_shot_prompting/), where agents learn from past sequences to perform tasks correctly. Sometimes it's easier to \"show\" than \"tell\" and LLMs learn well from examples. Few-shot learning lets you [\"program\"](https://x.com/karpathy/status/1627366413840322562) your LLM by updating the prompt with input-output examples to illustrate the intended behavior. While various [best-practices](https://python.langchain.com/docs/concepts/#1-generating-examples) can be used to generate few-shot examples, often the challenge lies in selecting the most relevant examples based on user input.\n\nNote that the memory [store](persistence.md#memory-store) is just one way to store data as few-shot examples. If you want to have more developer involvement, or tie few-shots more closely to your evaluation harness, you can also use a [LangSmith Dataset](https://docs.smith.langchain.com/evaluation/how_to_guides/datasets/index_datasets_for_dynamic_few_shot_example_selection) to store your data. Then dynamic few-shot example selectors can be used out-of-the box to achieve this same goal. LangSmith will index the dataset for you and enable retrieval of few shot examples that are most relevant to the user input based upon keyword similarity ([using a BM25-like algorithm](https://docs.smith.langchain.com/how_to_guides/datasets/index_datasets_for_dynamic_few_shot_example_selection) for keyword based similarity).\n\nSee this how-to [video](https://www.youtube.com/watch?v=37VaU7e7t5o) for example usage of dynamic few-shot example selection in LangSmith. Also, see this [blog post](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/) showcasing few-shot prompting to improve tool calling performance and this [blog post](https://blog.langchain.dev/aligning-llm-as-a-judge-with-human-preferences/) using few-shot example to align an LLMs to human preferences.\n\n#### Procedural memory\n\n[Procedural memory](https://en.wikipedia.org/wiki/Procedural_memory), in both humans and AI agents, involves remembering the rules used to perform tasks. In humans, procedural memory is like the internalized knowledge of how to perform tasks, such as riding a bike via basic motor skills and balance. Episodic memory, on the other hand, involves recalling specific experiences, such as the first time you successfully rode a bike without training wheels or a memorable bike ride through a scenic route. For AI agents, procedural memory is a combination of model weights, agent code, and agent's prompt that collectively determine the agent's functionality.\n\nIn practice, it is fairly uncommon for agents to modify their model weights or rewrite their code. However, it is more common for agents to modify their own prompts.\n\nOne effective approach to refining an agent's instructions is through [\"Reflection\"](https://blog.langchain.dev/reflection-agents/) or meta-prompting. This involves prompting the agent with its current instructions (e.g., the system prompt) along with recent conversations or explicit user feedback. The agent then refines its own instructions based on this input. This method is particularly useful for tasks where instructions are challenging to specify upfront, as it allows the agent to learn and adapt from its interactions.\n\nFor example, we built a [Tweet generator](https://www.youtube.com/watch?v=Vn8A3BxfplE) using external feedback and prompt re-writing to produce high-quality paper summaries for Twitter. In this case, the specific summarization prompt was difficult to specify *a priori*, but it was fairly easy for a user to critique the generated Tweets and provide feedback on how to improve the summarization process.\n\nThe below pseudo-code shows how you might implement this with the LangGraph memory [store](persistence.md#memory-store), using the store to save a prompt, the `update_instructions` node to get the current prompt (as well as feedback from the conversation with the user captured in `state[\"messages\"]`), update the prompt, and save the new prompt back to the store. Then, the `call_model` get the updated prompt from the store and uses it to generate a response.\n\n```python\n# Node that *uses* the instructions\ndef call_model(state: State, store: BaseStore):\n    namespace = (\"agent_instructions\", )\n    instructions = store.get(namespace, key=\"agent_a\")[0]\n    # Application logic\n    prompt = prompt_template.format(instructions=instructions.value[\"instructions\"])\n    ...\n\n# Node that updates instructions\ndef update_instructions(state: State, store: BaseStore):\n    namespace = (\"instructions\",)\n    current_instructions = store.search(namespace)[0]\n    # Memory logic\n    prompt = prompt_template.format(instructions=current_instructions.value[\"instructions\"], conversation=state[\"messages\"])\n    output = llm.invoke(prompt)\n    new_instructions = output['new_instructions']\n    store.put((\"agent_instructions\",), \"agent_a\", {\"instructions\": new_instructions})\n    ...\n```\n\n![](img/memory/update-instructions.png)\n\n### Writing memories\n\nThere are two primary methods for agents to write memories: [\"in the hot path\"](#in-the-hot-path) and [\"in the background\"](#in-the-background).\n\n![](img/memory/hot_path_vs_background.png)\n\n#### In the hot path\n\nCreating memories during runtime offers both advantages and challenges. On the positive side, this approach allows for real-time updates, making new memories immediately available for use in subsequent interactions. It also enables transparency, as users can be notified when memories are created and stored.\n\nHowever, this method also presents challenges. It may increase complexity if the agent requires a new tool to decide what to commit to memory. In addition, the process of reasoning about what to save to memory can impact agent latency. Finally, the agent must multitask between memory creation and its other responsibilities, potentially affecting the quantity and quality of memories created.\n\nAs an example, ChatGPT uses a [save_memories](https://openai.com/index/memory-and-new-controls-for-chatgpt/) tool to upsert memories as content strings, deciding whether and how to use this tool with each user message. See our [memory-agent](https://github.com/langchain-ai/memory-agent) template as an reference implementation.\n\n#### In the background\n\nCreating memories as a separate background task offers several advantages. It eliminates latency in the primary application, separates application logic from memory management, and allows for more focused task completion by the agent. This approach also provides flexibility in timing memory creation to avoid redundant work.\n\nHowever, this method has its own challenges. Determining the frequency of memory writing becomes crucial, as infrequent updates may leave other threads without new context. Deciding when to trigger memory formation is also important. Common strategies include scheduling after a set time period (with rescheduling if new events occur), using a cron schedule, or allowing manual triggers by users or the application logic.\n\nSee our [memory-service](https://github.com/langchain-ai/memory-template) template as an reference implementation.\n\n### Memory storage\n\nLangGraph stores long-term memories as JSON documents in a [store](persistence.md#memory-store). Each memory is organized under a custom `namespace` (similar to a folder) and a distinct `key` (like a file name). Namespaces often include user or org IDs or other labels that makes it easier to organize information. This structure enables hierarchical organization of memories. Cross-namespace searching is then supported through content filters.\n\n```python\nfrom langgraph.store.memory import InMemoryStore\n\ndef embed(texts: list[str]) -> list[list[float]]:\n    # Replace with an actual embedding function or LangChain embeddings object\n    return [[1.0, 2.0] * len(texts)]\n\n# InMemoryStore saves data to an in-memory dictionary. Use a DB-backed store in production use.\nstore = InMemoryStore(index={\"embed\": embed, \"dims\": 2})\nuser_id = \"my-user\"\napplication_context = \"chitchat\"\nnamespace = (user_id, application_context)\nstore.put(\n    namespace,\n    \"a-memory\",\n    {\n        \"rules\": [\n            \"User likes short, direct language\",\n            \"User only speaks English & python\",\n        ],\n        \"my-key\": \"my-value\",\n    },\n)\n# get the \"memory\" by ID\nitem = store.get(namespace, \"a-memory\")\n# search for \"memories\" within this namespace, filtering on content equivalence, sorted by vector similarity\nitems = store.search(\n    namespace, filter={\"my-key\": \"my-value\"}, query=\"language preferences\"\n)\n```\n\nFor more information about the memory store, see the [Persistence](persistence.md#memory-store) guide.\n\n---\nconcepts/agentic_concepts.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Agent architectures\n\nMany LLM applications implement a particular control flow of steps before and / or after LLM calls. As an example, [RAG](https://github.com/langchain-ai/rag-from-scratch) performs retrieval of documents relevant to a user question, and passes those documents to an LLM in order to ground the model's response in the provided document context.\n\nInstead of hard-coding a fixed control flow, we sometimes want LLM systems that can pick their own control flow to solve more complex problems! This is one definition of an [agent](https://blog.langchain.dev/what-is-an-agent/): *an agent is a system that uses an LLM to decide the control flow of an application.* There are many ways that an LLM can control application:\n\n- An LLM can route between two potential paths\n- An LLM can decide which of many tools to call\n- An LLM can decide whether the generated answer is sufficient or more work is needed\n\nAs a result, there are many different types of [agent architectures](https://blog.langchain.dev/what-is-a-cognitive-architecture/), which give an LLM varying levels of control.\n\n![Agent Types](img/agent_types.png)\n\n## Router\n\nA router allows an LLM to select a single step from a specified set of options. This is an agent architecture that exhibits a relatively limited level of control because the LLM usually focuses on making a single decision and produces a specific output from a limited set of pre-defined options. Routers typically employ a few different concepts to achieve this.\n\n### Structured Output\n\nStructured outputs with LLMs work by providing a specific format or schema that the LLM should follow in its response. This is similar to tool calling, but more general. While tool calling typically involves selecting and using predefined functions, structured outputs can be used for any type of formatted response. Common methods to achieve structured outputs include:\n\n1. Prompt engineering: Instructing the LLM to respond in a specific format via the system prompt.\n2. Output parsers: Using post-processing to extract structured data from LLM responses.\n3. Tool calling: Leveraging built-in tool calling capabilities of some LLMs to generate structured outputs.\n\nStructured outputs are crucial for routing as they ensure the LLM's decision can be reliably interpreted and acted upon by the system. Learn more about [structured outputs in this how-to guide](https://python.langchain.com/docs/how_to/structured_output/).\n\n## Tool-calling agent\n\nWhile a router allows an LLM to make a single decision, more complex agent architectures expand the LLM's control in two key ways:\n\n1. Multi-step decision making: The LLM can make a series of decisions, one after another, instead of just one.\n2. Tool access: The LLM can choose from and use a variety of tools to accomplish tasks.\n\n[ReAct](https://arxiv.org/abs/2210.03629) is a popular general purpose agent architecture that combines these expansions, integrating three core concepts.\n\n1. [Tool calling](#tool-calling): Allowing the LLM to select and use various tools as needed.\n2. [Memory](#memory): Enabling the agent to retain and use information from previous steps.\n3. [Planning](#planning): Empowering the LLM to create and follow multi-step plans to achieve goals.\n\nThis architecture allows for more complex and flexible agent behaviors, going beyond simple routing to enable dynamic problem-solving with multiple steps. Unlike the original [paper](https://arxiv.org/abs/2210.03629), today's agents rely on LLMs' [tool calling](#tool-calling) capabilities and operate on a list of [messages](./low_level.md#why-use-messages).\n\nIn LangGraph, you can use the prebuilt [agent](../agents/agents.md#2-create-an-agent) to get started with tool-calling agents.\n\n### Tool calling\n\nTools are useful whenever you want an agent to interact with external systems. External systems (e.g., APIs) often require a particular input schema or payload, rather than natural language. When we bind an API, for example, as a tool, we give the model awareness of the required input schema. The model will choose to call a tool based upon the natural language input from the user and it will return an output that adheres to the tool's required schema.\n\n[Many LLM providers support tool calling](https://python.langchain.com/docs/integrations/chat/) and [tool calling interface](https://blog.langchain.dev/improving-core-tool-interfaces-and-docs-in-langchain/) in LangChain is simple: you can simply pass any Python `function` into `ChatModel.bind_tools(function)`.\n\n![Tools](img/tool_call.png)\n\n### Memory\n\n[Memory](../how-tos/memory/add-memory.md) is crucial for agents, enabling them to retain and utilize information across multiple steps of problem-solving. It operates on different scales:\n\n1. [Short-term memory](../how-tos/memory/add-memory.md#add-short-term-memory): Allows the agent to access information acquired during earlier steps in a sequence.\n2. [Long-term memory](../how-tos/memory/add-memory.md#add-long-term-memory): Enables the agent to recall information from previous interactions, such as past messages in a conversation.\n\nLangGraph provides full control over memory implementation:\n\n- [`State`](./low_level.md#state): User-defined schema specifying the exact structure of memory to retain.\n- [`Checkpointer`](./persistence.md#checkpoints): Mechanism to store state at every step across different interactions within a session.\n- [`Store`](./persistence.md#memory-store): Mechanism to store user-specific or application-level data across sessions.\n\nThis flexible approach allows you to tailor the memory system to your specific agent architecture needs. Effective memory management enhances an agent's ability to maintain context, learn from past experiences, and make more informed decisions over time. For a practical guide on adding and managing memory, see [Memory](../how-tos/memory/add-memory.md).\n\n### Planning\n\nIn a tool-calling [agent](../agents/overview.md#what-is-an-agent), an LLM is called repeatedly in a while-loop. At each step the agent decides which tools to call, and what the inputs to those tools should be. Those tools are then executed, and the outputs are fed back into the LLM as observations. The while-loop terminates when the agent decides it has enough information to solve the user request and it is not worth calling any more tools.\n\n## Custom agent architectures\n\nWhile routers and tool-calling agents (like ReAct) are common, [customizing agent architectures](https://blog.langchain.dev/why-you-should-outsource-your-agentic-infrastructure-but-own-your-cognitive-architecture/) often leads to better performance for specific tasks. LangGraph offers several powerful features for building tailored agent systems:\n\n### Human-in-the-loop\n\nHuman involvement can significantly enhance agent reliability, especially for sensitive tasks. This can involve:\n\n- Approving specific actions\n- Providing feedback to update the agent's state\n- Offering guidance in complex decision-making processes\n\nHuman-in-the-loop patterns are crucial when full automation isn't feasible or desirable. Learn more in our [human-in-the-loop guide](./human_in_the_loop.md).\n\n### Parallelization\n\nParallel processing is vital for efficient multi-agent systems and complex tasks. LangGraph supports parallelization through its [Send](./low_level.md#send) API, enabling:\n\n- Concurrent processing of multiple states\n- Implementation of map-reduce-like operations\n- Efficient handling of independent subtasks\n\nFor practical implementation, see our [map-reduce tutorial](../how-tos/graph-api.md#map-reduce-and-the-send-api)\n\n### Subgraphs\n\n[Subgraphs](./subgraphs.md) are essential for managing complex agent architectures, particularly in [multi-agent systems](./multi_agent.md). They allow:\n\n- Isolated state management for individual agents\n- Hierarchical organization of agent teams\n- Controlled communication between agents and the main system\n\nSubgraphs communicate with the parent graph through overlapping keys in the state schema. This enables flexible, modular agent design. For implementation details, refer to our [subgraph how-to guide](../how-tos/subgraph.md).\n\n### Reflection\n\nReflection mechanisms can significantly improve agent reliability by:\n\n1. Evaluating task completion and correctness\n2. Providing feedback for iterative improvement\n3. Enabling self-correction and learning\n\nWhile often LLM-based, reflection can also use deterministic methods. For instance, in coding tasks, compilation errors can serve as feedback. This approach is demonstrated in [this video using LangGraph for self-corrective code generation](https://www.youtube.com/watch?v=MvNdgmM7uyc).\n\nBy leveraging these features, LangGraph enables the creation of sophisticated, task-specific agent architectures that can handle complex workflows, collaborate effectively, and continuously improve their performance.\n\n---\nconcepts/auth.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Authentication & Access Control\n\nLangGraph Platform provides a flexible authentication and authorization system that can integrate with most authentication schemes.\n\n## Core Concepts\n\n### Authentication vs Authorization\n\nWhile often used interchangeably, these terms represent distinct security concepts:", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "- [**Authentication**](#authentication) (\"AuthN\") verifies _who_ you are. This runs as middleware for every request.\n- [**Authorization**](#authorization) (\"AuthZ\") determines _what you can do_. This validates the user's privileges and roles on a per-resource basis.\n\nIn LangGraph Platform, authentication is handled by your [`@auth.authenticate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.authenticate) handler, and authorization is handled by your [`@auth.on`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.on) handlers.\n\n## Default Security Models\n\nLangGraph Platform provides different security defaults:\n\n### LangGraph Platform\n\n- Uses LangSmith API keys by default\n- Requires valid API key in `x-api-key` header\n- Can be customized with your auth handler\n\n!!! note \"Custom auth\"\n\nCustom auth **is supported** for all plans in LangGraph Platform.\n\n### Self-Hosted\n\n- No default authentication\n- Complete flexibility to implement your security model\n- You control all aspects of authentication and authorization\n\n## System Architecture\n\nA typical authentication setup involves three main components:\n\n1. **Authentication Provider** (Identity Provider/IdP)\n\n- A dedicated service that manages user identities and credentials\n   - Handles user registration, login, password resets, etc.\n   - Issues tokens (JWT, session tokens, etc.) after successful authentication\n   - Examples: Auth0, Supabase Auth, Okta, or your own auth server\n\n2. **LangGraph Backend** (Resource Server)\n\n- Your LangGraph application that contains business logic and protected resources\n   - Validates tokens with the auth provider\n   - Enforces access control based on user identity and permissions\n   - Doesn't store user credentials directly\n\n3. **Client Application** (Frontend)\n\n- Web app, mobile app, or API client\n   - Collects time-sensitive user credentials and sends to auth provider\n   - Receives tokens from auth provider\n   - Includes these tokens in requests to LangGraph backend\n\nHere's how these components typically interact:\n\n```mermaid\nsequenceDiagram\n    participant Client as Client App\n    participant Auth as Auth Provider\n    participant LG as LangGraph Backend\n\nClient->>Auth: 1. Login (username/password)\n    Auth-->>Client: 2. Return token\n    Client->>LG: 3. Request with token\n    Note over LG: 4. Validate token (@auth.authenticate)\n    LG-->>Auth:  5. Fetch user info\n    Auth-->>LG: 6. Confirm validity\n    Note over LG: 7. Apply access control (@auth.on.*)\n    LG-->>Client: 8. Return resources\n```\n\nYour [`@auth.authenticate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.authenticate) handler in LangGraph handles steps 4-6, while your [`@auth.on`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.on) handlers implement step 7.\n\n## Authentication\n\nAuthentication in LangGraph runs as middleware on every request. Your [`@auth.authenticate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.authenticate) handler receives request information and should:\n\n1. Validate the credentials\n2. Return [user info](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.MinimalUserDict) containing the user's identity and user information if valid\n3. Raise an [HTTPException](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.exceptions.HTTPException) or AssertionError if invalid\n\n```python\nfrom langgraph_sdk import Auth\n\nauth = Auth()\n\n@auth.authenticate\nasync def authenticate(headers: dict) -> Auth.types.MinimalUserDict:\n    # Validate credentials (e.g., API key, JWT token)\n    api_key = headers.get(\"x-api-key\")\n    if not api_key or not is_valid_key(api_key):\n        raise Auth.exceptions.HTTPException(\n            status_code=401,\n            detail=\"Invalid API key\"\n        )\n\n# Return user info - only identity and is_authenticated are required\n    # Add any additional fields you need for authorization\n    return {\n        \"identity\": \"user-123\",        # Required: unique user identifier\n        \"is_authenticated\": True,      # Optional: assumed True by default\n        \"permissions\": [\"read\", \"write\"] # Optional: for permission-based auth\n        # You can add more custom fields if you want to implement other auth patterns\n        \"role\": \"admin\",\n        \"org_id\": \"org-456\"\n\n}\n```\n\nThe returned user information is available:\n\n- To your authorization handlers via [`ctx.user`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AuthContext)\n- In your application via `config[\"configuration\"][\"langgraph_auth_user\"]`\n\n??? tip \"Supported Parameters\"\n\nThe [`@auth.authenticate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.authenticate) handler can accept any of the following parameters by name:\n\n* request (Request): The raw ASGI request object\n    * body (dict): The parsed request body\n    * path (str): The request path, e.g., \"/threads/abcd-1234-abcd-1234/runs/abcd-1234-abcd-1234/stream\"\n    * method (str): The HTTP method, e.g., \"GET\"\n    * path_params (dict[str, str]): URL path parameters, e.g., {\"thread_id\": \"abcd-1234-abcd-1234\", \"run_id\": \"abcd-1234-abcd-1234\"}\n    * query_params (dict[str, str]): URL query parameters, e.g., {\"stream\": \"true\"}\n    * headers (dict[bytes, bytes]): Request headers\n    * authorization (str | None): The Authorization header value (e.g., \"Bearer <token>\")\n\nIn many of our tutorials, we will just show the \"authorization\" parameter to be concise, but you can opt to accept more information as needed\n    to implement your custom authentication scheme.\n\n### Agent authentication\n\nCustom authentication permits delegated access. The values you return in `@auth.authenticate` are added to the run context, giving agents user-scoped credentials lets them access resources on the user’s behalf.\n\n```mermaid\nsequenceDiagram\n  %% Actors\n  participant ClientApp as Client\n  participant AuthProv  as Auth Provider\n  participant LangGraph as LangGraph Backend\n  participant SecretStore as Secret Store\n  participant ExternalService as External Service\n\n%% Platform login / AuthN\n  ClientApp  ->> AuthProv: 1. Login (username / password)\n  AuthProv   -->> ClientApp: 2. Return token\n  ClientApp  ->> LangGraph: 3. Request with token\n\nNote over LangGraph: 4. Validate token (@auth.authenticate)\n  LangGraph  -->> AuthProv: 5. Fetch user info\n  AuthProv   -->> LangGraph: 6. Confirm validity\n\n%% Fetch user tokens from secret store\n  LangGraph  ->> SecretStore: 6a. Fetch user tokens\n  SecretStore -->> LangGraph: 6b. Return tokens\n\nNote over LangGraph: 7. Apply access control (@auth.on.*)\n\n%% External Service round-trip\n  LangGraph  ->> ExternalService: 8. Call external service (with header)\n  Note over ExternalService: 9. External service validates header and executes action\n  ExternalService  -->> LangGraph: 10. Service response\n\n%% Return to caller\n  LangGraph  -->> ClientApp: 11. Return resources\n```\n\nAfter authentication, the platform creates a special configuration object that is passed to your graph and all nodes via the configurable context.\nThis object contains information about the current user, including any custom fields you return from your [`@auth.authenticate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.authenticate) handler.\n\nTo enable an agent to act on behalf of the user, use [custom authentication middleware](../how-tos/auth/custom_auth.md). This will allow the agent to interact with external systems like MCP servers, external databases, and even other agents on behalf of the user.\n\nFor more information, see the [Use custom auth](../how-tos/auth/custom_auth.md#enable-agent-authentication) guide.\n\n### Agent authentication with MCP\n\nFor information on how to authenticate an agent to an MCP server, see the [MCP conceptual guide](../concepts/mcp.md).\n\n## Authorization\n\nAfter authentication, LangGraph calls your authorization handlers to control access to specific resources (e.g., threads, assistants, crons). These handlers can:\n\n1. Add metadata to be saved during resource creation by mutating the metadata. See the [supported actions table](#supported-actions) for the list of types the value can take for each action.\n2. Filter resources by metadata during search/list or read operations by returning a [filter](#filter-operations).\n3. Raise an HTTP exception if access is denied.\n\nIf you want to just implement simple user-scoped access control, you can use a single authorization handler for all resources and actions. If you want to have different control depending on the resource and action, you can use [resource-specific handlers](#resource-specific-handlers). See the [Supported Resources](#supported-resources) section for a full list of the resources that support access control.\n\nYour [`@auth.on`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.Auth.on) handlers control access by mutating the `value[\"metadata\"]` dictionary directly and returning a [filter dictionary](#filter-operations).\n\n```python\n@auth.on\nasync def add_owner(\n    ctx: Auth.types.AuthContext,\n    value: dict  # The payload being sent to this access method\n) -> dict:  # Returns a filter dict that restricts access to resources\n    \"\"\"Authorize all access to threads, runs, crons, and assistants.\n\nThis handler does two things:\n        - Adds a value to resource metadata (to persist with the resource so it can be filtered later)\n        - Returns a filter (to restrict access to existing resources)\n\nArgs:\n        ctx: Authentication context containing user info, permissions, the path, and\n        value: The request payload sent to the endpoint. For creation\n              operations, this contains the resource parameters. For read\n              operations, this contains the resource being accessed.\n\nReturns:\n        A filter dictionary that LangGraph uses to restrict access to resources.\n        See [Filter Operations](#filter-operations) for supported operators.\n    \"\"\"\n    # Create filter to restrict access to just this user's resources\n    filters = {\"owner\": ctx.user.identity}\n\n# Get or create the metadata dictionary in the payload\n    # This is where we store persistent info about the resource\n    metadata = value.setdefault(\"metadata\", {})\n\n# Add owner to metadata - if this is a create or update operation,\n    # this information will be saved with the resource\n    # So we can filter by it later in read operations\n    metadata.update(filters)\n\n# Return filters to restrict access\n    # These filters are applied to ALL operations (create, read, update, search, etc.)\n    # to ensure users can only access their own resources\n    return filters\n```\n\n### Resource-Specific Handlers {#resource-specific-handlers}\n\nYou can register handlers for specific resources and actions by chaining the resource and action names together with the authorization decorator.\nWhen a request is made, the most specific handler that matches that resource and action is called. Below is an example of how to register handlers for specific resources and actions. For the following setup:\n\n1. Authenticated users are able to create threads, read threads, and create runs on threads\n2. Only users with the \"assistants:create\" permission are allowed to create new assistants\n3. All other endpoints (e.g., e.g., delete assistant, crons, store) are disabled for all users.\n\n!!! tip \"Supported Handlers\"\n\nFor a full list of supported resources and actions, see the [Supported Resources](#supported-resources) section below.\n\n```python\n# Generic / global handler catches calls that aren't handled by more specific handlers\n@auth.on\nasync def reject_unhandled_requests(ctx: Auth.types.AuthContext, value: Any) -> False:\n    print(f\"Request to {ctx.path} by {ctx.user.identity}\")\n    raise Auth.exceptions.HTTPException(\n        status_code=403,\n        detail=\"Forbidden\"\n    )\n\n# Matches the \"thread\" resource and all actions - create, read, update, delete, search\n# Since this is **more specific** than the generic @auth.on handler, it will take precedence\n# over the generic handler for all actions on the \"threads\" resource\n@auth.on.threads\nasync def on_thread_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create.value\n):\n    if \"write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"User lacks the required permissions.\"\n        )\n    # Setting metadata on the thread being created\n    # will ensure that the resource contains an \"owner\" field\n    # Then any time a user tries to access this thread or runs within the thread,\n    # we can filter by owner\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n# Thread creation. This will match only on thread create actions\n# Since this is **more specific** than both the generic @auth.on handler and the @auth.on.threads handler,\n# it will take precedence for any \"create\" actions on the \"threads\" resources\n@auth.on.threads.create\nasync def on_thread_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create.value\n):\n    # Setting metadata on the thread being created\n    # will ensure that the resource contains an \"owner\" field\n    # Then any time a user tries to access this thread or runs within the thread,\n    # we can filter by owner\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n# Reading a thread. Since this is also more specific than the generic @auth.on handler, and the @auth.on.threads handler,\n# it will take precedence for any \"read\" actions on the \"threads\" resource\n@auth.on.threads.read\nasync def on_thread_read(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.read.value\n):\n    # Since we are reading (and not creating) a thread,\n    # we don't need to set metadata. We just need to\n    # return a filter to ensure users can only see their own threads\n    return {\"owner\": ctx.user.identity}\n\n# Run creation, streaming, updates, etc.\n# This takes precedenceover the generic @auth.on handler and the @auth.on.threads handler\n@auth.on.threads.create_run\nasync def on_run_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create_run.value\n):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    # Inherit thread's access control\n    return {\"owner\": ctx.user.identity}\n\n# Assistant creation\n@auth.on.assistants.create\nasync def on_assistant_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.assistants.create.value\n):\n    if \"assistants:create\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"User lacks the required permissions.\"\n        )\n```\n\nNotice that we are mixing global and resource-specific handlers in the above example. Since each request is handled by the most specific handler, a request to create a `thread` would match the `on_thread_create` handler but NOT the `reject_unhandled_requests` handler. A request to `update` a thread, however would be handled by the global handler, since we don't have a more specific handler for that resource and action.\n\n### Filter Operations {#filter-operations}\n\nAuthorization handlers can return different types of values:\n\n- `None` and `True` mean \"authorize access to all underling resources\"\n- `False` means \"deny access to all underling resources (raises a 403 exception)\"\n- A metadata filter dictionary will restrict access to resources\n\nA filter dictionary is a dictionary with keys that match the resource metadata. It supports three operators:\n\n- The default value is a shorthand for exact match, or \"$eq\", below. For example, `{\"owner\": user_id}` will include only resources with metadata containing `{\"owner\": user_id}`\n- `$eq`: Exact match (e.g., `{\"owner\": {\"$eq\": user_id}}`) - this is equivalent to the shorthand above, `{\"owner\": user_id}`\n- `$contains`: List membership (e.g., `{\"allowed_users\": {\"$contains\": user_id}}`) The value here must be an element of the list. The metadata in the stored resource must be a list/container type.\n\nA dictionary with multiple keys is treated using a logical `AND` filter. For example, `{\"owner\": org_id, \"allowed_users\": {\"$contains\": user_id}}` will only match resources with metadata whose \"owner\" is `org_id` and whose \"allowed_users\" list contains `user_id`.\nSee the reference [here](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.FilterType) for more information.\n\n## Common Access Patterns\n\nHere are some typical authorization patterns:\n\n### Single-Owner Resources\n\nThis common pattern lets you scope all threads, assistants, crons, and runs to a single user. It's useful for common single-user use cases like regular chatbot-style apps.\n\n```python\n@auth.on\nasync def owner_only(ctx: Auth.types.AuthContext, value: dict):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n```\n\n### Permission-based Access\n\nThis pattern lets you control access based on **permissions**. It's useful if you want certain roles to have broader or more restricted access to resources.\n\n```python\n# In your auth handler:\n@auth.authenticate\nasync def authenticate(headers: dict) -> Auth.types.MinimalUserDict:\n    ...\n    return {\n        \"identity\": \"user-123\",\n        \"is_authenticated\": True,\n        \"permissions\": [\"threads:write\", \"threads:read\"]  # Define permissions in auth\n    }\n\ndef _default(ctx: Auth.types.AuthContext, value: dict):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n@auth.on.threads.create\nasync def create_thread(ctx: Auth.types.AuthContext, value: dict):\n    if \"threads:write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"Unauthorized\"\n        )\n    return _default(ctx, value)\n\n@auth.on.threads.read\nasync def rbac_create(ctx: Auth.types.AuthContext, value: dict):\n    if \"threads:read\" not in ctx.permissions and \"threads:write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"Unauthorized\"\n        )\n    return _default(ctx, value)\n```\n\n## Supported Resources\n\nLangGraph provides three levels of authorization handlers, from most general to most specific:\n\n1. **Global Handler** (`@auth.on`): Matches all resources and actions\n2. **Resource Handler** (e.g., `@auth.on.threads`, `@auth.on.assistants`, `@auth.on.crons`): Matches all actions for a specific resource\n3. **Action Handler** (e.g., `@auth.on.threads.create`, `@auth.on.threads.read`): Matches a specific action on a specific resource\n\nThe most specific matching handler will be used. For example, `@auth.on.threads.create` takes precedence over `@auth.on.threads` for thread creation.\nIf a more specific handler is registered, the more general handler will not be called for that resource and action.\n\n???+ tip \"Type Safety\"\nEach handler has type hints available for its `value` parameter. For example:\n\n```python\n    @auth.on.threads.create\n    async def on_thread_create(\n        ctx: Auth.types.AuthContext,\n        value: Auth.types.on.threads.create.value  # Specific type for thread creation\n    ):\n        ...\n\n@auth.on.threads\n    async def on_threads(\n        ctx: Auth.types.AuthContext,\n        value: Auth.types.on.threads.value  # Union type of all thread actions\n    ):\n        ...\n\n@auth.on\n    async def on_all(\n        ctx: Auth.types.AuthContext,\n        value: dict  # Union type of all possible actions\n    ):\n        ...\n    ```\n\nMore specific handlers provide better type hints since they handle fewer action types.\n\n#### Supported actions and types {#supported-actions}\n\nHere are all the supported action handlers:\n\n| Resource | Handler | Description | Value Type |\n|----------|---------|-------------|------------|\n| **Threads** | `@auth.on.threads.create` | Thread creation | [`ThreadsCreate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.ThreadsCreate) |\n| | `@auth.on.threads.read` | Thread retrieval | [`ThreadsRead`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.ThreadsRead) |\n| | `@auth.on.threads.update` | Thread updates | [`ThreadsUpdate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.ThreadsUpdate) |\n| | `@auth.on.threads.delete` | Thread deletion | [`ThreadsDelete`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.ThreadsDelete) |\n| | `@auth.on.threads.search` | Listing threads | [`ThreadsSearch`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.ThreadsSearch) |\n| | `@auth.on.threads.create_run` | Creating or updating a run | [`RunsCreate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.RunsCreate) |\n| **Assistants** | `@auth.on.assistants.create` | Assistant creation | [`AssistantsCreate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AssistantsCreate) |\n| | `@auth.on.assistants.read` | Assistant retrieval | [`AssistantsRead`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AssistantsRead) |\n| | `@auth.on.assistants.update` | Assistant updates | [`AssistantsUpdate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AssistantsUpdate) |\n| | `@auth.on.assistants.delete` | Assistant deletion | [`AssistantsDelete`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AssistantsDelete) |\n| | `@auth.on.assistants.search` | Listing assistants | [`AssistantsSearch`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.AssistantsSearch) |\n| **Crons** | `@auth.on.crons.create` | Cron job creation | [`CronsCreate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.CronsCreate) |\n| | `@auth.on.crons.read` | Cron job retrieval | [`CronsRead`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.CronsRead) |\n| | `@auth.on.crons.update` | Cron job updates | [`CronsUpdate`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.CronsUpdate) |\n| | `@auth.on.crons.delete` | Cron job deletion | [`CronsDelete`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.CronsDelete) |\n| | `@auth.on.crons.search` | Listing cron jobs | [`CronsSearch`](../cloud/reference/sdk/python_sdk_ref.md#langgraph_sdk.auth.types.CronsSearch) |\n\n???+ note \"About Runs\"\n\nRuns are scoped to their parent thread for access control. This means permissions are typically inherited from the thread, reflecting the conversational nature of the data model. All run operations (reading, listing) except creation are controlled by the thread's handlers.\n\nThere is a specific `create_run` handler for creating new runs because it had more arguments that you can view in the handler.\n\n## Next Steps\n\nFor implementation details:\n\n- Check out the introductory tutorial on [setting up authentication](../tutorials/auth/getting_started.md)\n- See the how-to guide on implementing a [custom auth handlers](../how-tos/auth/custom_auth.md)\n\n---\nconcepts/faq.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# FAQ\n\nCommon questions and their answers!\n\n## Do I need to use LangChain to use LangGraph? What’s the difference?\n\nNo. LangGraph is an orchestration framework for complex agentic systems and is more low-level and controllable than LangChain agents. LangChain provides a standard interface to interact with models and other components, useful for straight-forward chains and retrieval flows.\n\n## How is LangGraph different from other agent frameworks?\n\nOther agentic frameworks can work for simple, generic tasks but fall short for complex tasks. LangGraph provides a more expressive framework to handle your unique tasks without restricting you to a single black-box cognitive architecture.\n\n## Does LangGraph impact the performance of my app?\n\nLangGraph will not add any overhead to your code and is specifically designed with streaming workflows in mind.\n\n## Is LangGraph open source? Is it free?\n\nYes. LangGraph is an MIT-licensed open-source library and is free to use.\n\n## How are LangGraph and LangGraph Platform different?\n\nLangGraph is a stateful, orchestration framework that brings added control to agent workflows. LangGraph Platform is a service for deploying and scaling LangGraph applications, with an opinionated API for building agent UXs, plus an integrated developer studio.\n\n| Features            | LangGraph (open source)                                   | LangGraph Platform                                                                                     |\n| ------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\n| Description         | Stateful orchestration framework for agentic applications | Scalable infrastructure for deploying LangGraph applications                                           |\n| SDKs                | Python and JavaScript                                     | Python and JavaScript                                                                                  |\n| HTTP APIs           | None                                                      | Yes - useful for retrieving & updating state or long-term memory, or creating a configurable assistant |\n| Streaming           | Basic                                                     | Dedicated mode for token-by-token messages                                                             |\n| Checkpointer        | Community contributed                                     | Supported out-of-the-box                                                                               |\n| Persistence Layer   | Self-managed                                              | Managed Postgres with efficient storage                                                                |\n| Deployment          | Self-managed                                              | • Cloud SaaS <br> • Free self-hosted <br> • Enterprise (paid self-hosted)                              |\n| Scalability         | Self-managed                                              | Auto-scaling of task queues and servers                                                                |\n| Fault-tolerance     | Self-managed                                              | Automated retries                                                                                      |\n| Concurrency Control | Simple threading                                          | Supports double-texting                                                                                |\n| Scheduling          | None                                                      | Cron scheduling                                                                                        |\n| Monitoring          | None                                                      | Integrated with LangSmith for observability                                                            |\n| IDE integration     | LangGraph Studio                                          | LangGraph Studio                                                                                       |\n\n## Is LangGraph Platform open source?\n\nNo. LangGraph Platform is proprietary software.\n\nThere is a free, self-hosted version of LangGraph Platform with access to basic features. The Cloud SaaS deployment option and the Self-Hosted deployment options are paid services. [Contact our sales team](https://www.langchain.com/contact-sales) to learn more.\n\nFor more information, see our [LangGraph Platform pricing page](https://www.langchain.com/pricing-langgraph-platform).\n\n## Does LangGraph work with LLMs that don't support tool calling?", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "Yes! You can use LangGraph with any LLMs. The main reason we use LLMs that support tool calling is that this is often the most convenient way to have the LLM make its decision about what to do. If your LLM does not support tool calling, you can still use it - you just need to write a bit of logic to convert the raw LLM string response to a decision about what to do.\n\n## Does LangGraph work with OSS LLMs?\n\nYes! LangGraph is totally ambivalent to what LLMs are used under the hood. The main reason we use closed LLMs in most of the tutorials is that they seamlessly support tool calling, while OSS LLMs often don't. But tool calling is not necessary (see [this section](#does-langgraph-work-with-llms-that-dont-support-tool-calling)) so you can totally use LangGraph with OSS LLMs.\n\n## Can I use LangGraph Studio without logging in to LangSmith\n\nYes! You can use the [development version of LangGraph Server](../tutorials/langgraph-platform/local-server.md) to run the backend locally.\nThis will connect to the studio frontend hosted as part of LangSmith.\nIf you set an environment variable of `LANGSMITH_TRACING=false`, then no traces will be sent to LangSmith.\n\n## What does \"nodes executed\" mean for LangGraph Platform usage?\n\n**Nodes Executed** is the aggregate number of nodes in a LangGraph application that are called and completed successfully during an invocation of the application. If a node in the graph is not called during execution or ends in an error state, these nodes will not be counted. If a node is called and completes successfully multiple times, each occurrence will be counted.\n\n---\nconcepts/mcp.md\n---\n\n# MCP\n\n[Model Context Protocol (MCP)](https://modelcontextprotocol.io/introduction) is an open protocol that standardizes how applications provide tools and context to language models. LangGraph agents can use tools defined on MCP servers through the `langchain-mcp-adapters` library.\n\n![MCP](../agents/assets/mcp.png)\n\nInstall the `langchain-mcp-adapters` library to use MCP tools in LangGraph:\n\n```bash\npip install langchain-mcp-adapters\n```\n\n---\nconcepts/multi_agent.md\n---\n\n# Multi-agent systems\n\nAn [agent](./agentic_concepts.md#agent-architectures) is _a system that uses an LLM to decide the control flow of an application_. As you develop these systems, they might grow more complex over time, making them harder to manage and scale. For example, you might run into the following problems:\n\n- agent has too many tools at its disposal and makes poor decisions about which tool to call next\n- context grows too complex for a single agent to keep track of\n- there is a need for multiple specialization areas in the system (e.g. planner, researcher, math expert, etc.)\n\nTo tackle these, you might consider breaking your application into multiple smaller, independent agents and composing them into a **multi-agent system**. These independent agents can be as simple as a prompt and an LLM call, or as complex as a [ReAct](./agentic_concepts.md#tool-calling-agent) agent (and more!).\n\nThe primary benefits of using multi-agent systems are:\n\n- **Modularity**: Separate agents make it easier to develop, test, and maintain agentic systems.\n- **Specialization**: You can create expert agents focused on specific domains, which helps with the overall system performance.\n- **Control**: You can explicitly control how agents communicate (as opposed to relying on function calling).\n\n## Multi-agent architectures\n\n![](./img/multi_agent/architectures.png)\n\nThere are several ways to connect agents in a multi-agent system:\n\n- **Network**: each agent can communicate with [every other agent](../tutorials/multi_agent/multi-agent-collaboration.ipynb/). Any agent can decide which other agent to call next.\n- **Supervisor**: each agent communicates with a single [supervisor](../tutorials/multi_agent/agent_supervisor.md/) agent. Supervisor agent makes decisions on which agent should be called next.\n- **Supervisor (tool-calling)**: this is a special case of supervisor architecture. Individual agents can be represented as tools. In this case, a supervisor agent uses a tool-calling LLM to decide which of the agent tools to call, as well as the arguments to pass to those agents.\n- **Hierarchical**: you can define a multi-agent system with [a supervisor of supervisors](../tutorials/multi_agent/hierarchical_agent_teams.ipynb/). This is a generalization of the supervisor architecture and allows for more complex control flows.\n- **Custom multi-agent workflow**: each agent communicates with only a subset of agents. Parts of the flow are deterministic, and only some agents can decide which other agents to call next.\n\n### Handoffs\n\nIn multi-agent architectures, agents can be represented as graph nodes. Each agent node executes its step(s) and decides whether to finish execution or route to another agent, including potentially routing to itself (e.g., running in a loop). A common pattern in multi-agent interactions is **handoffs**, where one agent _hands off_ control to another. Handoffs allow you to specify:\n\n- **destination**: target agent to navigate to (e.g., name of the node to go to)\n- **payload**: [information to pass to that agent](#communication-and-state-management) (e.g., state update)\n\nTo implement handoffs in LangGraph, agent nodes can return [`Command`](./low_level.md#command) object that allows you to combine both control flow and state updates:\n\n```python\ndef agent(state) -> Command[Literal[\"agent\", \"another_agent\"]]:\n    # the condition for routing/halting can be anything, e.g. LLM tool call / structured output, etc.\n    goto = get_next_agent(...)  # 'agent' / 'another_agent'\n    return Command(\n        # Specify which agent to call next\n        goto=goto,\n        # Update the graph state\n        update={\"my_state_key\": \"my_state_value\"}\n    )\n```\n\nIn a more complex scenario where each agent node is itself a graph (i.e., a [subgraph](./subgraphs.md)), a node in one of the agent subgraphs might want to navigate to a different agent. For example, if you have two agents, `alice` and `bob` (subgraph nodes in a parent graph), and `alice` needs to navigate to `bob`, you can set `graph=Command.PARENT` in the `Command` object:\n\n```python\ndef some_node_inside_alice(state):\n    return Command(\n        goto=\"bob\",\n        update={\"my_state_key\": \"my_state_value\"},\n        # specify which graph to navigate to (defaults to the current graph)\n        graph=Command.PARENT,\n    )\n```\n\n!!! note\n\nIf you need to support visualization for subgraphs communicating using `Command(graph=Command.PARENT)` you would need to wrap them in a node function with `Command` annotation:\n    Instead of this:\n\n```python\n    builder.add_node(alice)\n    ```\n\nyou would need to do this:\n\n```python\n    def call_alice(state) -> Command[Literal[\"bob\"]]:\n        return alice.invoke(state)\n\nbuilder.add_node(\"alice\", call_alice)\n    ```\n\n#### Handoffs as tools\n\nOne of the most common agent types is a [tool-calling agent](../agents/overview.md). For those types of agents, a common pattern is wrapping a handoff in a tool call:\n\n```python\nfrom langchain_core.tools import tool\n\n@tool\ndef transfer_to_bob():\n    \"\"\"Transfer to bob.\"\"\"\n    return Command(\n        # name of the agent (node) to go to\n        goto=\"bob\",\n        # data to send to the agent\n        update={\"my_state_key\": \"my_state_value\"},\n        # indicate to LangGraph that we need to navigate to\n        # agent node in a parent graph\n        graph=Command.PARENT,\n    )\n```\n\nThis is a special case of updating the graph state from tools where, in addition to the state update, the control flow is included as well.\n\n!!! important\n\nIf you want to use tools that return `Command`, you can use the prebuilt [`create_react_agent`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.chat_agent_executor.create_react_agent) / [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/agents/#langgraph.prebuilt.tool_node.ToolNode) components, or else implement your own logic:\n\n```python\n      def call_tools(state):\n          ...\n          commands = [tools_by_name[tool_call[\"name\"]].invoke(tool_call) for tool_call in tool_calls]\n          return commands\n      ```\n\nLet's now take a closer look at the different multi-agent architectures.\n\n### Network\n\nIn this architecture, agents are defined as graph nodes. Each agent can communicate with every other agent (many-to-many connections) and can decide which agent to call next. This architecture is good for problems that do not have a clear hierarchy of agents or a specific sequence in which agents should be called.\n\n```python\nfrom typing import Literal\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.types import Command\nfrom langgraph.graph import StateGraph, MessagesState, START, END\n\nmodel = ChatOpenAI()\n\ndef agent_1(state: MessagesState) -> Command[Literal[\"agent_2\", \"agent_3\", END]]:\n    # you can pass relevant parts of the state to the LLM (e.g., state[\"messages\"])\n    # to determine which agent to call next. a common pattern is to call the model\n    # with a structured output (e.g. force it to return an output with a \"next_agent\" field)\n    response = model.invoke(...)\n    # route to one of the agents or exit based on the LLM's decision\n    # if the LLM returns \"__end__\", the graph will finish execution\n    return Command(\n        goto=response[\"next_agent\"],\n        update={\"messages\": [response[\"content\"]]},\n    )\n\ndef agent_2(state: MessagesState) -> Command[Literal[\"agent_1\", \"agent_3\", END]]:\n    response = model.invoke(...)\n    return Command(\n        goto=response[\"next_agent\"],\n        update={\"messages\": [response[\"content\"]]},\n    )\n\ndef agent_3(state: MessagesState) -> Command[Literal[\"agent_1\", \"agent_2\", END]]:\n    ...\n    return Command(\n        goto=response[\"next_agent\"],\n        update={\"messages\": [response[\"content\"]]},\n    )\n\nbuilder = StateGraph(MessagesState)\nbuilder.add_node(agent_1)\nbuilder.add_node(agent_2)\nbuilder.add_node(agent_3)\n\nbuilder.add_edge(START, \"agent_1\")\nnetwork = builder.compile()\n```\n\n### Supervisor\n\nIn this architecture, we define agents as nodes and add a supervisor node (LLM) that decides which agent nodes should be called next. We use [`Command`](./low_level.md#command) to route execution to the appropriate agent node based on supervisor's decision. This architecture also lends itself well to running multiple agents in parallel or using [map-reduce](../how-tos/graph-api.md#map-reduce-and-the-send-api) pattern.\n\n```python\nfrom typing import Literal\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.types import Command\nfrom langgraph.graph import StateGraph, MessagesState, START, END\n\nmodel = ChatOpenAI()\n\ndef supervisor(state: MessagesState) -> Command[Literal[\"agent_1\", \"agent_2\", END]]:\n    # you can pass relevant parts of the state to the LLM (e.g., state[\"messages\"])\n    # to determine which agent to call next. a common pattern is to call the model\n    # with a structured output (e.g. force it to return an output with a \"next_agent\" field)\n    response = model.invoke(...)\n    # route to one of the agents or exit based on the supervisor's decision\n    # if the supervisor returns \"__end__\", the graph will finish execution\n    return Command(goto=response[\"next_agent\"])\n\ndef agent_1(state: MessagesState) -> Command[Literal[\"supervisor\"]]:\n    # you can pass relevant parts of the state to the LLM (e.g., state[\"messages\"])\n    # and add any additional logic (different models, custom prompts, structured output, etc.)\n    response = model.invoke(...)\n    return Command(\n        goto=\"supervisor\",\n        update={\"messages\": [response]},\n    )\n\ndef agent_2(state: MessagesState) -> Command[Literal[\"supervisor\"]]:\n    response = model.invoke(...)\n    return Command(\n        goto=\"supervisor\",\n        update={\"messages\": [response]},\n    )\n\nbuilder = StateGraph(MessagesState)\nbuilder.add_node(supervisor)\nbuilder.add_node(agent_1)\nbuilder.add_node(agent_2)\n\nbuilder.add_edge(START, \"supervisor\")\n\nsupervisor = builder.compile()\n```\n\nCheck out this [tutorial](../tutorials/multi_agent/agent_supervisor.md) for an example of supervisor multi-agent architecture.\n\n### Supervisor (tool-calling)\n\nIn this variant of the [supervisor](#supervisor) architecture, we define a supervisor [agent](./agentic_concepts.md#agent-architectures) which is responsible for calling sub-agents. The sub-agents are exposed to the supervisor as tools, and the supervisor agent decides which tool to call next. The supervisor agent follows a [standard implementation](./agentic_concepts.md#tool-calling-agent) as an LLM running in a while loop calling tools until it decides to stop.\n\n```python\nfrom typing import Annotated\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.prebuilt import InjectedState, create_react_agent\n\nmodel = ChatOpenAI()\n\n# this is the agent function that will be called as tool\n# notice that you can pass the state to the tool via InjectedState annotation\ndef agent_1(state: Annotated[dict, InjectedState]):\n    # you can pass relevant parts of the state to the LLM (e.g., state[\"messages\"])\n    # and add any additional logic (different models, custom prompts, structured output, etc.)\n    response = model.invoke(...)\n    # return the LLM response as a string (expected tool response format)\n    # this will be automatically turned to ToolMessage\n    # by the prebuilt create_react_agent (supervisor)\n    return response.content\n\ndef agent_2(state: Annotated[dict, InjectedState]):\n    response = model.invoke(...)\n    return response.content\n\ntools = [agent_1, agent_2]\n# the simplest way to build a supervisor w/ tool-calling is to use prebuilt ReAct agent graph\n# that consists of a tool-calling LLM node (i.e. supervisor) and a tool-executing node\nsupervisor = create_react_agent(model, tools)\n```\n\n### Hierarchical\n\nAs you add more agents to your system, it might become too hard for the supervisor to manage all of them. The supervisor might start making poor decisions about which agent to call next, or the context might become too complex for a single supervisor to keep track of. In other words, you end up with the same problems that motivated the multi-agent architecture in the first place.\n\nTo address this, you can design your system _hierarchically_. For example, you can create separate, specialized teams of agents managed by individual supervisors, and a top-level supervisor to manage the teams.\n\n```python\nfrom typing import Literal\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.graph import StateGraph, MessagesState, START, END\nfrom langgraph.types import Command\nmodel = ChatOpenAI()\n\n# define team 1 (same as the single supervisor example above)\n\ndef team_1_supervisor(state: MessagesState) -> Command[Literal[\"team_1_agent_1\", \"team_1_agent_2\", END]]:\n    response = model.invoke(...)\n    return Command(goto=response[\"next_agent\"])\n\ndef team_1_agent_1(state: MessagesState) -> Command[Literal[\"team_1_supervisor\"]]:\n    response = model.invoke(...)\n    return Command(goto=\"team_1_supervisor\", update={\"messages\": [response]})\n\ndef team_1_agent_2(state: MessagesState) -> Command[Literal[\"team_1_supervisor\"]]:\n    response = model.invoke(...)\n    return Command(goto=\"team_1_supervisor\", update={\"messages\": [response]})\n\nteam_1_builder = StateGraph(Team1State)\nteam_1_builder.add_node(team_1_supervisor)\nteam_1_builder.add_node(team_1_agent_1)\nteam_1_builder.add_node(team_1_agent_2)\nteam_1_builder.add_edge(START, \"team_1_supervisor\")\nteam_1_graph = team_1_builder.compile()\n\n# define team 2 (same as the single supervisor example above)\nclass Team2State(MessagesState):\n    next: Literal[\"team_2_agent_1\", \"team_2_agent_2\", \"__end__\"]\n\ndef team_2_supervisor(state: Team2State):\n    ...\n\ndef team_2_agent_1(state: Team2State):\n    ...\n\ndef team_2_agent_2(state: Team2State):\n    ...\n\nteam_2_builder = StateGraph(Team2State)\n...\nteam_2_graph = team_2_builder.compile()\n\n# define top-level supervisor\n\nbuilder = StateGraph(MessagesState)\ndef top_level_supervisor(state: MessagesState) -> Command[Literal[\"team_1_graph\", \"team_2_graph\", END]]:\n    # you can pass relevant parts of the state to the LLM (e.g., state[\"messages\"])\n    # to determine which team to call next. a common pattern is to call the model\n    # with a structured output (e.g. force it to return an output with a \"next_team\" field)\n    response = model.invoke(...)\n    # route to one of the teams or exit based on the supervisor's decision\n    # if the supervisor returns \"__end__\", the graph will finish execution\n    return Command(goto=response[\"next_team\"])\n\nbuilder = StateGraph(MessagesState)\nbuilder.add_node(top_level_supervisor)\nbuilder.add_node(\"team_1_graph\", team_1_graph)\nbuilder.add_node(\"team_2_graph\", team_2_graph)\nbuilder.add_edge(START, \"top_level_supervisor\")\nbuilder.add_edge(\"team_1_graph\", \"top_level_supervisor\")\nbuilder.add_edge(\"team_2_graph\", \"top_level_supervisor\")\ngraph = builder.compile()\n```\n\n### Custom multi-agent workflow\n\nIn this architecture we add individual agents as graph nodes and define the order in which agents are called ahead of time, in a custom workflow. In LangGraph the workflow can be defined in two ways:\n\n- **Explicit control flow (normal edges)**: LangGraph allows you to explicitly define the control flow of your application (i.e. the sequence of how agents communicate) explicitly, via [normal graph edges](./low_level.md#normal-edges). This is the most deterministic variant of this architecture above — we always know which agent will be called next ahead of time.\n\n- **Dynamic control flow (Command)**: in LangGraph you can allow LLMs to decide parts of your application control flow. This can be achieved by using [`Command`](./low_level.md#command). A special case of this is a [supervisor tool-calling](#supervisor-tool-calling) architecture. In that case, the tool-calling LLM powering the supervisor agent will make decisions about the order in which the tools (agents) are being called.\n\n```python\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.graph import StateGraph, MessagesState, START\n\nmodel = ChatOpenAI()\n\ndef agent_1(state: MessagesState):\n    response = model.invoke(...)\n    return {\"messages\": [response]}\n\ndef agent_2(state: MessagesState):\n    response = model.invoke(...)\n    return {\"messages\": [response]}\n\nbuilder = StateGraph(MessagesState)\nbuilder.add_node(agent_1)\nbuilder.add_node(agent_2)\n# define the flow explicitly\nbuilder.add_edge(START, \"agent_1\")\nbuilder.add_edge(\"agent_1\", \"agent_2\")\n```\n\n## Communication and state management\n\nThe most important thing when building multi-agent systems is figuring out how the agents communicate.\n\nA common, generic way for agents to communicate is via a list of messages. This opens up the following questions:\n\n- Do agents communicate [**via handoffs or via tool calls**](#handoffs-vs-tool-calls)?\n- What messages are [**passed from one agent to the next**](#message-passing-between-agents)?\n- How are [**handoffs represented in the list of messages**](#representing-handoffs-in-message-history)?\n- How do you [**manage state for subagents**](#state-management-for-subagents)?\n\nAdditionally, if you are dealing with more complex agents or wish to keep individual agent state separate from the multi-agent system state, you may need to use [**different state schemas**](#using-different-state-schemas).\n\n### Handoffs vs tool calls\n\nWhat is the \"payload\" that is being passed around between agents? In most of the architectures discussed above, the agents communicate via [handoffs](#handoffs) and pass the [graph state](./low_level.md#state) as part of the handoff payload. Specifically, agents pass around lists of messages as part of the graph state. In the case of the [supervisor with tool-calling](#supervisor-tool-calling), the payloads are tool call arguments.\n\n![](./img/multi_agent/request.png)\n\n### Message passing between agents\n\nThe most common way for agents to communicate is via a shared state channel, typically a list of messages. This assumes that there is always at least a single channel (key) in the state that is shared by the agents (e.g., `messages`). When communicating via a shared message list, there is an additional consideration: should the agents [share the full history](#sharing-full-thought-process) of their thought process or only [the final result](#sharing-only-final-results)?\n\n![](./img/multi_agent/response.png)\n\n#### Sharing full thought process\n\nAgents can **share the full history** of their thought process (i.e., \"scratchpad\") with all other agents. This \"scratchpad\" would typically look like a [list of messages](./low_level.md#why-use-messages). The benefit of sharing the full thought process is that it might help other agents make better decisions and improve reasoning ability for the system as a whole. The downside is that as the number of agents and their complexity grows, the \"scratchpad\" will grow quickly and might require additional strategies for [memory management](../how-tos/memory/add-memory.md).\n\n#### Sharing only final results\n\nAgents can have their own private \"scratchpad\" and only **share the final result** with the rest of the agents. This approach might work better for systems with many agents or agents that are more complex. In this case, you would need to define agents with [different state schemas](#using-different-state-schemas).\n\nFor agents called as tools, the supervisor determines the inputs based on the tool schema. Additionally, LangGraph allows [passing state](../how-tos/tool-calling.md#short-term-memory) to individual tools at runtime, so subordinate agents can access parent state, if needed.\n\n#### Indicating agent name in messages\n\nIt can be helpful to indicate which agent a particular AI message is from, especially for long message histories. Some LLM providers (like OpenAI) support adding a `name` parameter to messages — you can use that to attach the agent name to the message. If that is not supported, you can consider manually injecting the agent name into the message content, e.g., `<agent>alice</agent><message>message from alice</message>`.\n\n### Representing handoffs in message history\n\nHandoffs are typically done via the LLM calling a dedicated [handoff tool](#handoffs-as-tools). This is represented as an [AI message](https://python.langchain.com/docs/concepts/messages/#aimessage) with tool calls that is passed to the next agent (LLM). Most LLM providers don't support receiving AI messages with tool calls **without** corresponding tool messages.\n\nYou therefore have two options:\n\n1. Add an extra [tool message](https://python.langchain.com/docs/concepts/messages/#toolmessage) to the message list, e.g., \"Successfully transferred to agent X\"\n2. Remove the AI message with the tool calls\n\nIn practice, we see that most developers opt for option (1).\n\n### State management for subagents\n\nA common practice is to have multiple agents communicating on a shared message list, but only [adding their final messages to the list](#sharing-only-final-results). This means that any intermediate messages (e.g., tool calls) are not saved in this list.\n\nWhat if you **do** want to save these messages so that if this particular subagent is invoked in the future you can pass those back in?\n\nThere are two high-level approaches to achieve that:\n\n1. Store these messages in the shared message list, but filter the list before passing it to the subagent LLM. For example, you can choose to filter out all tool calls from **other** agents.\n2. Store a separate message list for each agent (e.g., `alice_messages`) in the subagent's graph state. This would be their \"view\" of what the message history looks like.\n\n### Using different state schemas\n\nAn agent might need to have a different state schema from the rest of the agents. For example, a search agent might only need to keep track of queries and retrieved documents. There are two ways to achieve this in LangGraph:\n\n- Define [subgraph](./subgraphs.md) agents with a separate state schema. If there are no shared state keys (channels) between the subgraph and the parent graph, it's important to [add input / output transformations](../how-tos/subgraph.md#different-state-schemas) so that the parent graph knows how to communicate with the subgraphs.\n- Define agent node functions with a [private input state schema](../how-tos/graph-api.md#pass-private-state-between-nodes) that is distinct from the overall graph state schema. This allows passing information that is only needed for executing that particular agent.\n\n---\nconcepts/scalability_and_resilience.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Scalability & Resilience\n\nLangGraph Platform is designed to scale horizontally with your workload. Each instance of the service is stateless, and keeps no resources in memory. The service is designed to gracefully handle new instances being added or removed, including hard shutdown cases.\n\n## Server scalability\n\nAs you add more instances to a service, they will share the HTTP load as long as an appropriate load balancer mechanism is placed in front of them. In most deployment modalities we configure a load balancer for the service automatically. In the “self-hosted without control plane” modality it’s your responsibility to add a load balancer. Since the instances are stateless any load balancing strategy will work, no session stickiness is needed, or recommended. Any instance of the server can communicate with any queue instance (through Redis PubSub), meaning that requests to cancel or stream an in-progress run can be handled by any arbitrary instance.\n\n## Queue scalability\n\nAs you add more instances to a service, they will increase run throughput linearly, as each instance is configured to handle a set number of concurrent runs (by default 10). Each attempt for each run will be handled by a single instance, with exactly-once semantics enforced through Postgres’s MVCC model (refer to section below for crash resilience details). Attempts that fail due to transient database errors are retried up to 3 times. We do not make use of long-lived transactions or locks, this enables us to make more efficient use of Postgres resources.\n\n## Resilience\n\nWhile a run is being handled by a queue instance, a periodic heartbeat timestamp will be recorded in Redis by that queue worker.\n\nWhen a graceful shutdown request is received (SIGINT) an instance enters shutdown mode, which\n\n- stops accepting new HTTP requests\n- gives any in-progress runs a limited number of seconds to finish (if not finished it will be put back in the queue)\n- stops the instance from picking up more runs from the queue\n\nIf a hard shutdown occurs due to a server crash or an infrastructure failure, any runs that were in progress will be picked up by an internal sweeper task that looks for in-progress runs that have breached their heartbeat window. The sweeper runs every 2 minutes and will put the runs back in the queue for another instance to pick them up.\n\n## Postgres resilience\n\nFor deployment modalities where we manage the Postgres database, we have periodic backups and continuously replicated standby replicas for automatic failover. This Postgres configuration is available in the [Cloud SaaS deployment option](../concepts/langgraph_cloud.md) for [`Production` deployment types](../concepts/langgraph_control_plane.md#deployment-types) only.\n\nAll communication with Postgres implements retries for retry-able errors. If Postgres is momentarily unavailable, such as during a database restart, most/all traffic should continue to succeed. Prolonged failure of Postgres will render the LangGraph Server unavailable.\n\n## Redis resilience\n\nAll data that requires durable storage is stored in Postgres, not Redis. Redis is used only for ephemeral metadata, and communication between instances. Therefore we place no durability requirements on Redis.", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "All communication with Redis implements retries for retry-able errors. If Redis is momentarily unavailable, such as during a database restart, most/all traffic should continue to succeed. Prolonged failure of Redis will render the LangGraph Server unavailable.\n\n---\nconcepts/low_level.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Graph API concepts\n\n## Graphs\n\nAt its core, LangGraph models agent workflows as graphs. You define the behavior of your agents using three key components:\n\n1. [`State`](#state): A shared data structure that represents the current snapshot of your application. It can be any data type, but is typically defined using a shared state schema.\n\n2. [`Nodes`](#nodes): Functions that encode the logic of your agents. They receive the current state as input, perform some computation or side-effect, and return an updated state.\n\n3. [`Edges`](#edges): Functions that determine which `Node` to execute next based on the current state. They can be conditional branches or fixed transitions.\n\nBy composing `Nodes` and `Edges`, you can create complex, looping workflows that evolve the state over time. The real power, though, comes from how LangGraph manages that state. To emphasize: `Nodes` and `Edges` are nothing more than functions - they can contain an LLM or just good ol' code.\n\nIn short: _nodes do the work, edges tell what to do next_.\n\nLangGraph's underlying graph algorithm uses [message passing](https://en.wikipedia.org/wiki/Message_passing) to define a general program. When a Node completes its operation, it sends messages along one or more edges to other node(s). These recipient nodes then execute their functions, pass the resulting messages to the next set of nodes, and the process continues. Inspired by Google's [Pregel](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/) system, the program proceeds in discrete \"super-steps.\"\n\nA super-step can be considered a single iteration over the graph nodes. Nodes that run in parallel are part of the same super-step, while nodes that run sequentially belong to separate super-steps. At the start of graph execution, all nodes begin in an `inactive` state. A node becomes `active` when it receives a new message (state) on any of its incoming edges (or \"channels\"). The active node then runs its function and responds with updates. At the end of each super-step, nodes with no incoming messages vote to `halt` by marking themselves as `inactive`. The graph execution terminates when all nodes are `inactive` and no messages are in transit.\n\n### StateGraph\n\nThe `StateGraph` class is the main graph class to use. This is parameterized by a user defined `State` object.\n\n### Compiling your graph\n\nTo build your graph, you first define the [state](#state), you then add [nodes](#nodes) and [edges](#edges), and then you compile it. What exactly is compiling your graph and why is it needed?\n\nCompiling is a pretty simple step. It provides a few basic checks on the structure of your graph (no orphaned nodes, etc). It is also where you can specify runtime args like [checkpointers](./persistence.md) and breakpoints. You compile your graph by just calling the `.compile` method:\n\n```python\ngraph = graph_builder.compile(...)\n```\n\nYou **MUST** compile your graph before you can use it.\n\n## State\n\nThe first thing you do when you define a graph is define the `State` of the graph. The `State` consists of the [schema of the graph](#schema) as well as [`reducer` functions](#reducers) which specify how to apply updates to the state. The schema of the `State` will be the input schema to all `Nodes` and `Edges` in the graph, and can be either a `TypedDict` or a `Pydantic` model. All `Nodes` will emit updates to the `State` which are then applied using the specified `reducer` function.\n\n### Schema\n\nThe main documented way to specify the schema of a graph is by using a [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict). If you want to provide default values in your state, use a [`dataclass`](https://docs.python.org/3/library/dataclasses.html). We also support using a Pydantic [BaseModel](../how-tos/graph-api.md#use-pydantic-models-for-graph-state) as your graph state if you want recursive data validation (though note that pydantic is less performant than a `TypedDict` or `dataclass`).\n\nBy default, the graph will have the same input and output schemas. If you want to change this, you can also specify explicit input and output schemas directly. This is useful when you have a lot of keys, and some are explicitly for input and others for output. See the [guide here](../how-tos/graph-api.md#define-input-and-output-schemas) for how to use.\n\n#### Multiple schemas\n\nTypically, all graph nodes communicate with a single schema. This means that they will read and write to the same state channels. But, there are cases where we want more control over this:\n\n- Internal nodes can pass information that is not required in the graph's input / output.\n- We may also want to use different input / output schemas for the graph. The output might, for example, only contain a single relevant output key.\n\nIt is possible to have nodes write to private state channels inside the graph for internal node communication. We can simply define a private schema, `PrivateState`.\n\nIt is also possible to define explicit input and output schemas for a graph. In these cases, we define an \"internal\" schema that contains _all_ keys relevant to graph operations. But, we also define `input` and `output` schemas that are sub-sets of the \"internal\" schema to constrain the input and output of the graph. See [this guide](../how-tos/graph-api.md#define-input-and-output-schemas) for more detail.\n\nLet's look at an example:\n\n```python\nclass InputState(TypedDict):\n    user_input: str\n\nclass OutputState(TypedDict):\n    graph_output: str\n\nclass OverallState(TypedDict):\n    foo: str\n    user_input: str\n    graph_output: str\n\nclass PrivateState(TypedDict):\n    bar: str\n\ndef node_1(state: InputState) -> OverallState:\n    # Write to OverallState\n    return {\"foo\": state[\"user_input\"] + \" name\"}\n\ndef node_2(state: OverallState) -> PrivateState:\n    # Read from OverallState, write to PrivateState\n    return {\"bar\": state[\"foo\"] + \" is\"}\n\ndef node_3(state: PrivateState) -> OutputState:\n    # Read from PrivateState, write to OutputState\n    return {\"graph_output\": state[\"bar\"] + \" Lance\"}\n\nbuilder = StateGraph(OverallState,input_schema=InputState,output_schema=OutputState)\nbuilder.add_node(\"node_1\", node_1)\nbuilder.add_node(\"node_2\", node_2)\nbuilder.add_node(\"node_3\", node_3)\nbuilder.add_edge(START, \"node_1\")\nbuilder.add_edge(\"node_1\", \"node_2\")\nbuilder.add_edge(\"node_2\", \"node_3\")\nbuilder.add_edge(\"node_3\", END)\n\ngraph = builder.compile()\ngraph.invoke({\"user_input\":\"My\"})\n# {'graph_output': 'My name is Lance'}\n```\n\nThere are two subtle and important points to note here:\n\n1. We pass `state: InputState` as the input schema to `node_1`. But, we write out to `foo`, a channel in `OverallState`. How can we write out to a state channel that is not included in the input schema? This is because a node _can write to any state channel in the graph state._ The graph state is the union of the state channels defined at initialization, which includes `OverallState` and the filters `InputState` and `OutputState`.\n\n2. We initialize the graph with `StateGraph(OverallState,input_schema=InputState,output_schema=OutputState)`. So, how can we write to `PrivateState` in `node_2`? How does the graph gain access to this schema if it was not passed in the `StateGraph` initialization? We can do this because _nodes can also declare additional state channels_ as long as the state schema definition exists. In this case, the `PrivateState` schema is defined, so we can add `bar` as a new state channel in the graph and write to it.\n\n### Reducers\n\nReducers are key to understanding how updates from nodes are applied to the `State`. Each key in the `State` has its own independent reducer function. If no reducer function is explicitly specified then it is assumed that all updates to that key should override it. There are a few different types of reducers, starting with the default type of reducer:\n\n#### Default Reducer\n\nThese two examples show how to use the default reducer:\n\n**Example A:**\n\n```python\nfrom typing_extensions import TypedDict\n\nclass State(TypedDict):\n    foo: int\n    bar: list[str]\n```\n\nIn this example, no reducer functions are specified for any key. Let's assume the input to the graph is:\n\n`{\"foo\": 1, \"bar\": [\"hi\"]}`. Let's then assume the first `Node` returns `{\"foo\": 2}`. This is treated as an update to the state. Notice that the `Node` does not need to return the whole `State` schema - just an update. After applying this update, the `State` would then be `{\"foo\": 2, \"bar\": [\"hi\"]}`. If the second node returns `{\"bar\": [\"bye\"]}` then the `State` would then be `{\"foo\": 2, \"bar\": [\"bye\"]}`\n\n**Example B:**\n\n```python\nfrom typing import Annotated\nfrom typing_extensions import TypedDict\nfrom operator import add\n\nclass State(TypedDict):\n    foo: int\n    bar: Annotated[list[str], add]\n```\n\nIn this example, we've used the `Annotated` type to specify a reducer function (`operator.add`) for the second key (`bar`). Note that the first key remains unchanged. Let's assume the input to the graph is `{\"foo\": 1, \"bar\": [\"hi\"]}`. Let's then assume the first `Node` returns `{\"foo\": 2}`. This is treated as an update to the state. Notice that the `Node` does not need to return the whole `State` schema - just an update. After applying this update, the `State` would then be `{\"foo\": 2, \"bar\": [\"hi\"]}`. If the second node returns `{\"bar\": [\"bye\"]}` then the `State` would then be `{\"foo\": 2, \"bar\": [\"hi\", \"bye\"]}`. Notice here that the `bar` key is updated by adding the two lists together.\n\n### Working with Messages in Graph State\n\n#### Why use messages?\n\nMost modern LLM providers have a chat model interface that accepts a list of messages as input. LangChain's [`ChatModel`](https://python.langchain.com/docs/concepts/#chat-models) in particular accepts a list of `Message` objects as inputs. These messages come in a variety of forms such as `HumanMessage` (user input) or `AIMessage` (LLM response). To read more about what message objects are, please refer to [this](https://python.langchain.com/docs/concepts/#messages) conceptual guide.\n\n#### Using Messages in your Graph\n\nIn many cases, it is helpful to store prior conversation history as a list of messages in your graph state. To do so, we can add a key (channel) to the graph state that stores a list of `Message` objects and annotate it with a reducer function (see `messages` key in the example below). The reducer function is vital to telling the graph how to update the list of `Message` objects in the state with each state update (for example, when a node sends an update). If you don't specify a reducer, every state update will overwrite the list of messages with the most recently provided value. If you wanted to simply append messages to the existing list, you could use `operator.add` as a reducer.\n\nHowever, you might also want to manually update messages in your graph state (e.g. human-in-the-loop). If you were to use `operator.add`, the manual state updates you send to the graph would be appended to the existing list of messages, instead of updating existing messages. To avoid that, you need a reducer that can keep track of message IDs and overwrite existing messages, if updated. To achieve this, you can use the prebuilt `add_messages` function. For brand new messages, it will simply append to existing list, but it will also handle the updates for existing messages correctly.\n\n#### Serialization\n\nIn addition to keeping track of message IDs, the `add_messages` function will also try to deserialize messages into LangChain `Message` objects whenever a state update is received on the `messages` channel. See more information on LangChain serialization/deserialization [here](https://python.langchain.com/docs/how_to/serialization/). This allows sending graph inputs / state updates in the following format:\n\n```python\n# this is supported\n{\"messages\": [HumanMessage(content=\"message\")]}\n\n# and this is also supported\n{\"messages\": [{\"type\": \"human\", \"content\": \"message\"}]}\n```\n\nSince the state updates are always deserialized into LangChain `Messages` when using `add_messages`, you should use dot notation to access message attributes, like `state[\"messages\"][-1].content`. Below is an example of a graph that uses `add_messages` as its reducer function.\n\n```python\nfrom langchain_core.messages import AnyMessage\nfrom langgraph.graph.message import add_messages\nfrom typing import Annotated\nfrom typing_extensions import TypedDict\n\nclass GraphState(TypedDict):\n    messages: Annotated[list[AnyMessage], add_messages]\n```\n\n#### MessagesState\n\nSince having a list of messages in your state is so common, there exists a prebuilt state called `MessagesState` which makes it easy to use messages. `MessagesState` is defined with a single `messages` key which is a list of `AnyMessage` objects and uses the `add_messages` reducer. Typically, there is more state to track than just messages, so we see people subclass this state and add more fields, like:\n\n```python\nfrom langgraph.graph import MessagesState\n\nclass State(MessagesState):\n    documents: list[str]\n```\n\n## Nodes\n\nIn LangGraph, nodes are Python functions (either synchronous or asynchronous) that accept the following arguments:\n\n1. `state`: The [state](#state) of the graph\n2. `config`: A `RunnableConfig` object that contains configuration information like `thread_id` and tracing information like `tags`\n3. `runtime`: A `Runtime` object that contains [runtime `context`](#runtime-context) and other information like `store` and `stream_writer`\n\nSimilar to `NetworkX`, you add these nodes to a graph using the [add_node](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph.add_node) method:\n\n```python\nfrom dataclasses import dataclass\nfrom typing_extensions import TypedDict\n\nfrom langchain_core.runnables import RunnableConfig\nfrom langgraph.graph import StateGraph\nfrom langgraph.runtime import Runtime\n\nclass State(TypedDict):\n    input: str\n    results: str\n\n@dataclass\nclass Context:\n    user_id: str\n\nbuilder = StateGraph(State)\n\ndef plain_node(state: State):\n    return state\n\ndef node_with_runtime(state: State, runtime: Runtime[Context]):\n    print(\"In node: \", runtime.context.user_id)\n    return {\"results\": f\"Hello, {state['input']}!\"}\n\ndef node_with_config(state: State, config: RunnableConfig):\n    print(\"In node with thread_id: \", config[\"configurable\"][\"thread_id\"])\n    return {\"results\": f\"Hello, {state['input']}!\"}\n\nbuilder.add_node(\"plain_node\", plain_node)\nbuilder.add_node(\"node_with_runtime\", node_with_runtime)\nbuilder.add_node(\"node_with_config\", node_with_config)\n...\n```\n\nBehind the scenes, functions are converted to [RunnableLambda](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableLambda.html)s, which add batch and async support to your function, along with native tracing and debugging.\n\nIf you add a node to a graph without specifying a name, it will be given a default name equivalent to the function name.\n\n```python\nbuilder.add_node(my_node)\n# You can then create edges to/from this node by referencing it as `\"my_node\"`\n```\n\n### `START` Node\n\nThe `START` Node is a special node that represents the node that sends user input to the graph. The main purpose for referencing this node is to determine which nodes should be called first.\n\n```python\nfrom langgraph.graph import START\n\ngraph.add_edge(START, \"node_a\")\n```\n\n### `END` Node\n\nThe `END` Node is a special node that represents a terminal node. This node is referenced when you want to denote which edges have no actions after they are done.\n\n```python\nfrom langgraph.graph import END\n\ngraph.add_edge(\"node_a\", END)\n```\n\n### Node Caching\n\nLangGraph supports caching of tasks/nodes based on the input to the node. To use caching:\n\n- Specify a cache when compiling a graph (or specifying an entrypoint)\n- Specify a cache policy for nodes. Each cache policy supports:\n  - `key_func` used to generate a cache key based on the input to a node, which defaults to a `hash` of the input with pickle.\n  - `ttl`, the time to live for the cache in seconds. If not specified, the cache will never expire.\n\nFor example:\n\n```python\nimport time\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph\nfrom langgraph.cache.memory import InMemoryCache\nfrom langgraph.types import CachePolicy\n\nclass State(TypedDict):\n    x: int\n    result: int\n\nbuilder = StateGraph(State)\n\ndef expensive_node(state: State) -> dict[str, int]:\n    # expensive computation\n    time.sleep(2)\n    return {\"result\": state[\"x\"] * 2}\n\nbuilder.add_node(\"expensive_node\", expensive_node, cache_policy=CachePolicy(ttl=3))\nbuilder.set_entry_point(\"expensive_node\")\nbuilder.set_finish_point(\"expensive_node\")\n\ngraph = builder.compile(cache=InMemoryCache())\n\nprint(graph.invoke({\"x\": 5}, stream_mode='updates'))  # (1)!\n[{'expensive_node': {'result': 10}}]\nprint(graph.invoke({\"x\": 5}, stream_mode='updates'))  # (2)!\n[{'expensive_node': {'result': 10}, '__metadata__': {'cached': True}}]\n```\n\n1. First run takes two seconds to run (due to mocked expensive computation).\n2. Second run utilizes cache and returns quickly.\n\n## Edges\n\nEdges define how the logic is routed and how the graph decides to stop. This is a big part of how your agents work and how different nodes communicate with each other. There are a few key types of edges:\n\n- Normal Edges: Go directly from one node to the next.\n- Conditional Edges: Call a function to determine which node(s) to go to next.\n- Entry Point: Which node to call first when user input arrives.\n- Conditional Entry Point: Call a function to determine which node(s) to call first when user input arrives.\n\nA node can have MULTIPLE outgoing edges. If a node has multiple out-going edges, **all** of those destination nodes will be executed in parallel as a part of the next superstep.\n\n### Normal Edges\n\nIf you **always** want to go from node A to node B, you can use the [add_edge](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph.add_edge) method directly.\n\n```python\ngraph.add_edge(\"node_a\", \"node_b\")\n```\n\n### Conditional Edges\n\nIf you want to **optionally** route to 1 or more edges (or optionally terminate), you can use the [add_conditional_edges](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph.add_conditional_edges) method. This method accepts the name of a node and a \"routing function\" to call after that node is executed:\n\n```python\ngraph.add_conditional_edges(\"node_a\", routing_function)\n```\n\nSimilar to nodes, the `routing_function` accepts the current `state` of the graph and returns a value.\n\nBy default, the return value `routing_function` is used as the name of the node (or list of nodes) to send the state to next. All those nodes will be run in parallel as a part of the next superstep.\n\nYou can optionally provide a dictionary that maps the `routing_function`'s output to the name of the next node.\n\n```python\ngraph.add_conditional_edges(\"node_a\", routing_function, {True: \"node_b\", False: \"node_c\"})\n```\n\n!!! tip\n\nUse [`Command`](#command) instead of conditional edges if you want to combine state updates and routing in a single function.\n\n### Entry Point\n\nThe entry point is the first node(s) that are run when the graph starts. You can use the [`add_edge`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph.add_edge) method from the virtual [`START`](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.START) node to the first node to execute to specify where to enter the graph.\n\n```python\nfrom langgraph.graph import START\n\ngraph.add_edge(START, \"node_a\")\n```\n\n### Conditional Entry Point\n\nA conditional entry point lets you start at different nodes depending on custom logic. You can use [`add_conditional_edges`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph.add_conditional_edges) from the virtual [`START`](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.START) node to accomplish this.\n\n```python\nfrom langgraph.graph import START\n\ngraph.add_conditional_edges(START, routing_function)\n```\n\nYou can optionally provide a dictionary that maps the `routing_function`'s output to the name of the next node.\n\n```python\ngraph.add_conditional_edges(START, routing_function, {True: \"node_b\", False: \"node_c\"})\n```\n\n## `Send`\n\nBy default, `Nodes` and `Edges` are defined ahead of time and operate on the same shared state. However, there can be cases where the exact edges are not known ahead of time and/or you may want different versions of `State` to exist at the same time. A common example of this is with [map-reduce](https://langchain-ai.github.io/langgraph/how-tos/map-reduce/) design patterns. In this design pattern, a first node may generate a list of objects, and you may want to apply some other node to all those objects. The number of objects may be unknown ahead of time (meaning the number of edges may not be known) and the input `State` to the downstream `Node` should be different (one for each generated object).\n\nTo support this design pattern, LangGraph supports returning [`Send`](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Send) objects from conditional edges. `Send` takes two arguments: first is the name of the node, and second is the state to pass to that node.\n\n```python\ndef continue_to_jokes(state: OverallState):\n    return [Send(\"generate_joke\", {\"subject\": s}) for s in state['subjects']]\n\ngraph.add_conditional_edges(\"node_a\", continue_to_jokes)\n```\n\n## `Command`\n\nIt can be useful to combine control flow (edges) and state updates (nodes). For example, you might want to BOTH perform state updates AND decide which node to go to next in the SAME node. LangGraph provides a way to do so by returning a [`Command`](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Command) object from node functions:\n\n```python\ndef my_node(state: State) -> Command[Literal[\"my_other_node\"]]:\n    return Command(\n        # state update\n        update={\"foo\": \"bar\"},\n        # control flow\n        goto=\"my_other_node\"\n    )\n```\n\nWith `Command` you can also achieve dynamic control flow behavior (identical to [conditional edges](#conditional-edges)):\n\n```python\ndef my_node(state: State) -> Command[Literal[\"my_other_node\"]]:\n    if state[\"foo\"] == \"bar\":\n        return Command(update={\"foo\": \"baz\"}, goto=\"my_other_node\")\n```\n\n!!! important\n\nWhen returning `Command` in your node functions, you must add return type annotations with the list of node names the node is routing to, e.g. `Command[Literal[\"my_other_node\"]]`. This is necessary for the graph rendering and tells LangGraph that `my_node` can navigate to `my_other_node`.\n\nCheck out this [how-to guide](../how-tos/graph-api.md#combine-control-flow-and-state-updates-with-command) for an end-to-end example of how to use `Command`.\n\n### When should I use Command instead of conditional edges?\n\n- Use `Command` when you need to **both** update the graph state **and** route to a different node. For example, when implementing [multi-agent handoffs](./multi_agent.md#handoffs) where it's important to route to a different agent and pass some information to that agent.\n- Use [conditional edges](#conditional-edges) to route between nodes conditionally without updating the state.\n\n### Navigating to a node in a parent graph\n\nIf you are using [subgraphs](./subgraphs.md), you might want to navigate from a node within a subgraph to a different subgraph (i.e. a different node in the parent graph). To do so, you can specify `graph=Command.PARENT` in `Command`:\n\n```python\ndef my_node(state: State) -> Command[Literal[\"other_subgraph\"]]:\n    return Command(\n        update={\"foo\": \"bar\"},\n        goto=\"other_subgraph\",  # where `other_subgraph` is a node in the parent graph\n        graph=Command.PARENT\n    )\n```\n\n!!! note\n\nSetting `graph` to `Command.PARENT` will navigate to the closest parent graph.\n\n!!! important \"State updates with `Command.PARENT`\"\n\nWhen you send updates from a subgraph node to a parent graph node for a key that's shared by both parent and subgraph [state schemas](#schema), you **must** define a [reducer](#reducers) for the key you're updating in the parent graph state. See this [example](../how-tos/graph-api.md#navigate-to-a-node-in-a-parent-graph).\n\nThis is particularly useful when implementing [multi-agent handoffs](./multi_agent.md#handoffs).\n\nCheck out [this guide](../how-tos/graph-api.md#navigate-to-a-node-in-a-parent-graph) for detail.\n\n### Using inside tools\n\nA common use case is updating graph state from inside a tool. For example, in a customer support application you might want to look up customer information based on their account number or ID in the beginning of the conversation.\n\nRefer to [this guide](../how-tos/graph-api.md#use-inside-tools) for detail.\n\n### Human-in-the-loop\n\n`Command` is an important part of human-in-the-loop workflows: when using `interrupt()` to collect user input, `Command` is then used to supply the input and resume execution via `Command(resume=\"User input\")`. Check out [this conceptual guide](./human_in_the_loop.md) for more information.\n\n## Graph Migrations\n\nLangGraph can easily handle migrations of graph definitions (nodes, edges, and state) even when using a checkpointer to track state.\n\n- For threads at the end of the graph (i.e. not interrupted) you can change the entire topology of the graph (i.e. all nodes and edges, remove, add, rename, etc)\n- For threads currently interrupted, we support all topology changes other than renaming / removing nodes (as that thread could now be about to enter a node that no longer exists) -- if this is a blocker please reach out and we can prioritize a solution.\n- For modifying state, we have full backwards and forwards compatibility for adding and removing keys\n- State keys that are renamed lose their saved state in existing threads\n- State keys whose types change in incompatible ways could currently cause issues in threads with state from before the change -- if this is a blocker please reach out and we can prioritize a solution.\n\n## Runtime Context\n\nWhen creating a graph, you can specify a `context_schema` for runtime context passed to nodes. This is useful for passing\ninformation to nodes that is not part of the graph state. For example, you might want to pass dependencies such as model name or a database connection.\n\n```python\n@dataclass\nclass ContextSchema:\n    llm_provider: str = \"openai\"\n\ngraph = StateGraph(State, context_schema=ContextSchema)\n```\n\nYou can then pass this context into the graph using the `context` parameter of the `invoke` method.\n\n```python\ngraph.invoke(inputs, context={\"llm_provider\": \"anthropic\"})\n```\n\nYou can then access and use this context inside a node or conditional edge:\n\n```python\nfrom langgraph.runtime import Runtime\n\ndef node_a(state: State, runtime: Runtime[ContextSchema]):\n    llm = get_llm(runtime.context.llm_provider)\n    ...\n```\n\nSee [this guide](../how-tos/graph-api.md#add-runtime-configuration) for a full breakdown on configuration.\n:::\n\n### Recursion Limit", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "The recursion limit sets the maximum number of [super-steps](#graphs) the graph can execute during a single execution. Once the limit is reached, LangGraph will raise `GraphRecursionError`. By default this value is set to 25 steps. The recursion limit can be set on any graph at runtime, and is passed to `.invoke`/`.stream` via the config dictionary. Importantly, `recursion_limit` is a standalone `config` key and should not be passed inside the `configurable` key as all other user-defined configuration. See the example below:\n\n```python\ngraph.invoke(inputs, config={\"recursion_limit\": 5}, context={\"llm\": \"anthropic\"})\n```\n\nRead [this how-to](https://langchain-ai.github.io/langgraph/how-tos/recursion-limit/) to learn more about how the recursion limit works.\n\n## Visualization\n\nIt's often nice to be able to visualize graphs, especially as they get more complex. LangGraph comes with several built-in ways to visualize graphs. See [this how-to guide](../how-tos/graph-api.md#visualize-your-graph) for more info.\n\n---\nconcepts/langgraph_control_plane.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Control Plane\n\nThe term \"control plane\" is used broadly to refer to the control plane UI where users create and update [LangGraph Servers](./langgraph_server.md) (deployments) and the control plane APIs that support the UI experience.\n\nWhen a user makes an update through the control plane UI, the update is stored in the control plane state. The [LangGraph Data Plane](./langgraph_data_plane.md) \"listener\" application polls for these updates by calling the control plane APIs.\n\n## Control Plane UI\n\nFrom the control plane UI, you can:\n\n- View a list of outstanding deployments.\n- View details of an individual deployment.\n- Create a new deployment.\n- Update a deployment.\n- Update environment variables for a deployment.\n- View build and server logs of a deployment.\n- View deployment metrics such as CPU and memory usage.\n- Delete a deployment.\n\nThe Control Plane UI is embedded in [LangSmith](https://docs.smith.langchain.com/langgraph_cloud).\n\n## Control Plane API\n\nThis section describes the data model of the control plane API. The API is used to create, update, and delete deployments. See the [control plane API reference](../cloud/reference/api/api_ref_control_plane.md) for more details.\n\n### Deployment\n\nA deployment is an instance of a LangGraph Server. A single deployment can have many revisions.\n\n### Revision\n\nA revision is an iteration of a deployment. When a new deployment is created, an initial revision is automatically created. To deploy code changes or update secrets for a deployment, a new revision must be created.\n\n## Control Plane Features\n\nThis section describes various features of the control plane.\n\n### Deployment Types\n\nFor simplicity, the control plane offers two deployment types with different resource allocations: `Development` and `Production`.\n\n| **Deployment Type** | **CPU/Memory**  | **Scaling**       | **Database**                                                                     |\n| ------------------- | --------------- | ----------------- | -------------------------------------------------------------------------------- |\n| Development         | 1 CPU, 1 GB RAM | Up to 1 replica   | 10 GB disk, no backups                                                           |\n| Production          | 2 CPU, 2 GB RAM | Up to 10 replicas | Autoscaling disk, automatic backups, highly available (multi-zone configuration) |\n\nCPU and memory resources are per replica.\n\n!!! warning \"Immutable Deployment Type\"\n\nOnce a deployment is created, the deployment type cannot be changed.\n\n!!! info \"Self-Hosted Deployment\"\nResources for [Self-Hosted Data Plane](../concepts/langgraph_self_hosted_data_plane.md) and [Self-Hosted Control Plane](../concepts/langgraph_self_hosted_control_plane.md) deployments can be fully customized. Deployment types are only applicable for [Cloud SaaS](../concepts/langgraph_cloud.md) deployments.\n\n#### Production\n\n`Production` type deployments are suitable for \"production\" workloads. For example, select `Production` for customer-facing applications in the critical path.\n\nResources for `Production` type deployments can be manually increased on a case-by-case basis depending on use case and capacity constraints. Contact support@langchain.dev to request an increase in resources.\n\n#### Development\n\n`Development` type deployments are suitable development and testing. For example, select `Development` for internal testing environments. `Development` type deployments are not suitable for \"production\" workloads.\n\n!!! danger \"Preemptible Compute Infrastructure\"\n`Development` type deployments (API server, queue server, and database) are provisioned on preemptible compute infrastructure. This means the compute infrastructure **may be terminated at any time without notice**. This may result in intermittent...\n\n- Redis connection timeouts/errors\n    - Postgres connection timeouts/errors\n    - Failed or retrying background runs\n\nThis behavior is expected. Preemptible compute infrastructure **significantly reduces the cost to provision a `Development` type deployment**. By design, LangGraph Server is fault-tolerant. The implementation will automatically attempt to recover from Redis/Postgres connection errors and retry failed background runs.\n\n`Production` type deployments are provisioned on durable compute infrastructure, not preemptible compute infrastructure.\n\nDatabase disk size for `Development` type deployments can be manually increased on a case-by-case basis depending on use case and capacity constraints. For most use cases, [TTLs](../how-tos/ttl/configure_ttl.md) should be configured to manage disk usage. Contact support@langchain.dev to request an increase in resources.\n\n### Database Provisioning\n\nThe control plane and [LangGraph Data Plane](./langgraph_data_plane.md) \"listener\" application coordinate to automatically create a Postgres database for each deployment. The database serves as the [persistence layer](../concepts/persistence.md) for the deployment.\n\nWhen implementing a LangGraph application, a [checkpointer](../concepts/persistence.md#checkpointer-libraries) does not need to be configured by the developer. Instead, a checkpointer is automatically configured for the graph. Any checkpointer configured for a graph will be replaced by the one that is automatically configured.\n\nThere is no direct access to the database. All access to the database occurs through the [LangGraph Server](../concepts/langgraph_server.md).\n\nThe database is never deleted until the deployment itself is deleted.\n\n!!! info\nA custom Postgres instance can be configured for [Self-Hosted Data Plane](../concepts/langgraph_self_hosted_data_plane.md) and [Self-Hosted Control Plane](../concepts/langgraph_self_hosted_control_plane.md) deployments.\n\n### Asynchronous Deployment\n\nInfrastructure for deployments and revisions are provisioned and deployed asynchronously. They are not deployed immediately after submission. Currently, deployment can take up to several minutes.\n\n- When a new deployment is created, a new database is created for the deployment. Database creation is a one-time step. This step contributes to a longer deployment time for the initial revision of the deployment.\n- When a subsequent revision is created for a deployment, there is no database creation step. The deployment time for a subsequent revision is significantly faster compared to the deployment time of the initial revision.\n- The deployment process for each revision contains a build step, which can take up to a few minutes.\n\nThe control plane and [LangGraph Data Plane](./langgraph_data_plane.md) \"listener\" application coordinate to achieve asynchronous deployments.\n\n### Monitoring\n\nAfter a deployment is ready, the control plane monitors the deployment and records various metrics, such as:\n\n- CPU and memory usage of the deployment.\n- Number of container restarts.\n- Number of replicas (this will increase with [autoscaling](../concepts/langgraph_data_plane.md#autoscaling)).\n- [Postgres](../concepts/langgraph_data_plane.md#postgres) CPU, memory usage, and disk usage.\n- [LangGraph Server queue](../concepts/langgraph_server.md#persistence-and-task-queue) pending/active run count.\n- [LangGraph Server API](../concepts/langgraph_server.md) success response count, error response count, and latency.\n\nThese metrics are displayed as charts in the Control Plane UI.\n\n### LangSmith Integration\n\nA [LangSmith](https://docs.smith.langchain.com/) tracing project and LangSmith API key are automatically created for each deployment. The deployment uses the API key to automatically send traces to LangSmith.\n\n- The tracing project has the same name as the deployment.\n- The API key has the description `LangGraph Platform: <deployment_name>`.\n- The API key is never revealed and cannot be deleted manually.\n- When creating a deployment, the `LANGCHAIN_TRACING` and `LANGSMITH_API_KEY`/`LANGCHAIN_API_KEY` environment variables do not need to be specified; they are set automatically by the control plane.\n\nWhen a deployment is deleted, the traces and the tracing project are not deleted. However, the API will be deleted when the deployment is deleted.\n\n---\nconcepts/durable_execution.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Durable Execution\n\n**Durable execution** is a technique in which a process or workflow saves its progress at key points, allowing it to pause and later resume exactly where it left off. This is particularly useful in scenarios that require [human-in-the-loop](./human_in_the_loop.md), where users can inspect, validate, or modify the process before continuing, and in long-running tasks that might encounter interruptions or errors (e.g., calls to an LLM timing out). By preserving completed work, durable execution enables a process to resume without reprocessing previous steps -- even after a significant delay (e.g., a week later).\n\nLangGraph's built-in [persistence](./persistence.md) layer provides durable execution for workflows, ensuring that the state of each execution step is saved to a durable store. This capability guarantees that if a workflow is interrupted -- whether by a system failure or for [human-in-the-loop](./human_in_the_loop.md) interactions -- it can be resumed from its last recorded state.\n\n!!! tip\n\nIf you are using LangGraph with a checkpointer, you already have durable execution enabled. You can pause and resume workflows at any point, even after interruptions or failures.\n    To make the most of durable execution, ensure that your workflow is designed to be [deterministic](#determinism-and-consistent-replay) and [idempotent](#determinism-and-consistent-replay) and wrap any side effects or non-deterministic operations inside [tasks](./functional_api.md#task). You can use [tasks](./functional_api.md#task) from both the [StateGraph (Graph API)](./low_level.md) and the [Functional API](./functional_api.md).\n\n## Requirements\n\nTo leverage durable execution in LangGraph, you need to:\n\n1. Enable [persistence](./persistence.md) in your workflow by specifying a [checkpointer](./persistence.md#checkpointer-libraries) that will save workflow progress.\n2. Specify a [thread identifier](./persistence.md#threads) when executing a workflow. This will track the execution history for a particular instance of the workflow.\n\n3. Wrap any non-deterministic operations (e.g., random number generation) or operations with side effects (e.g., file writes, API calls) inside [tasks](https://langchain-ai.github.io/langgraph/reference/func/#langgraph.func.task) to ensure that when a workflow is resumed, these operations are not repeated for the particular run, and instead their results are retrieved from the persistence layer. For more information, see [Determinism and Consistent Replay](#determinism-and-consistent-replay).\n\n## Determinism and Consistent Replay\n\nWhen you resume a workflow run, the code does **NOT** resume from the **same line of code** where execution stopped; instead, it will identify an appropriate [starting point](#starting-points-for-resuming-workflows) from which to pick up where it left off. This means that the workflow will replay all steps from the [starting point](#starting-points-for-resuming-workflows) until it reaches the point where it was stopped.\n\nAs a result, when you are writing a workflow for durable execution, you must wrap any non-deterministic operations (e.g., random number generation) and any operations with side effects (e.g., file writes, API calls) inside [tasks](./functional_api.md#task) or [nodes](./low_level.md#nodes).\n\nTo ensure that your workflow is deterministic and can be consistently replayed, follow these guidelines:\n\n- **Avoid Repeating Work**: If a [node](./low_level.md#nodes) contains multiple operations with side effects (e.g., logging, file writes, or network calls), wrap each operation in a separate **task**. This ensures that when the workflow is resumed, the operations are not repeated, and their results are retrieved from the persistence layer.\n- **Encapsulate Non-Deterministic Operations:** Wrap any code that might yield non-deterministic results (e.g., random number generation) inside **tasks** or **nodes**. This ensures that, upon resumption, the workflow follows the exact recorded sequence of steps with the same outcomes.\n- **Use Idempotent Operations**: When possible ensure that side effects (e.g., API calls, file writes) are idempotent. This means that if an operation is retried after a failure in the workflow, it will have the same effect as the first time it was executed. This is particularly important for operations that result in data writes. In the event that a **task** starts but fails to complete successfully, the workflow's resumption will re-run the **task**, relying on recorded outcomes to maintain consistency. Use idempotency keys or verify existing results to avoid unintended duplication, ensuring a smooth and predictable workflow execution.\n\nFor some examples of pitfalls to avoid, see the [Common Pitfalls](./functional_api.md#common-pitfalls) section in the functional API, which shows\nhow to structure your code using **tasks** to avoid these issues. The same principles apply to the [StateGraph (Graph API)](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.StateGraph).\n\n## Durability modes\n\nLangGraph supports three durability modes that allow you to balance performance and data consistency based on your application's requirements. The durability modes, from least to most durable, are as follows:\n\n- [`\"exit\"`](#exit)\n- [`\"async\"`](#async)\n- [`\"sync\"`](#sync)\n\nA higher durability mode add more overhead to the workflow execution.\n\n!!! version-added \"Added in version 0.6.0\"\n\nUse the `durability` parameter instead of `checkpoint_during` (deprecated in v0.6.0) for persistence policy management:\n    \n    * `durability=\"async\"` replaces `checkpoint_during=True`\n    * `durability=\"exit\"` replaces `checkpoint_during=False`\n    \n    for persistence policy management, with the following mapping:\n\n* `checkpoint_during=True` -> `durability=\"async\"`\n    * `checkpoint_during=False` -> `durability=\"exit\"`\n\n### `\"exit\"`\n\nChanges are persisted only when graph execution completes (either successfully or with an error). This provides the best performance for long-running graphs but means intermediate state is not saved, so you cannot recover from mid-execution failures or interrupt the graph execution.\n\n### `\"async\"`\n\nChanges are persisted asynchronously while the next step executes. This provides good performance and durability, but there's a small risk that checkpoints might not be written if the process crashes during execution.\n\n### `\"sync\"`\n\nChanges are persisted synchronously before the next step starts. This ensures that every checkpoint is written before continuing execution, providing high durability at the cost of some performance overhead.\n\nYou can specify the durability mode when calling any graph execution method:\n\n```python\ngraph.stream(\n    {\"input\": \"test\"}, \n    durability=\"sync\"\n)\n```\n\n## Using tasks in nodes\n\nIf a [node](./low_level.md#nodes) contains multiple operations, you may find it easier to convert each operation into a **task** rather than refactor the operations into individual nodes.\n\n=== \"Original\"\n\n```python hl_lines=\"16\"\n    from typing import NotRequired\n    from typing_extensions import TypedDict\n    import uuid\n\nfrom langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.graph import StateGraph, START, END\n    import requests\n\n# Define a TypedDict to represent the state\n    class State(TypedDict):\n        url: str\n        result: NotRequired[str]\n\ndef call_api(state: State):\n        \"\"\"Example node that makes an API request.\"\"\"\n        result = requests.get(state['url']).text[:100]  # Side-effect\n        return {\n            \"result\": result\n        }\n\n# Create a StateGraph builder and add a node for the call_api function\n    builder = StateGraph(State)\n    builder.add_node(\"call_api\", call_api)\n\n# Connect the start and end nodes to the call_api node\n    builder.add_edge(START, \"call_api\")\n    builder.add_edge(\"call_api\", END)\n\n# Specify a checkpointer\n    checkpointer = InMemorySaver()\n\n# Compile the graph with the checkpointer\n    graph = builder.compile(checkpointer=checkpointer)\n\n# Define a config with a thread ID.\n    thread_id = uuid.uuid4()\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n\n# Invoke the graph\n    graph.invoke({\"url\": \"https://www.example.com\"}, config)\n    ```\n\n=== \"With task\"\n\n```python hl_lines=\"19 23\"\n    from typing import NotRequired\n    from typing_extensions import TypedDict\n    import uuid\n\nfrom langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.func import task\n    from langgraph.graph import StateGraph, START, END\n    import requests\n\n# Define a TypedDict to represent the state\n    class State(TypedDict):\n        urls: list[str]\n        result: NotRequired[list[str]]\n\n@task\n    def _make_request(url: str):\n        \"\"\"Make a request.\"\"\"\n        return requests.get(url).text[:100]\n\ndef call_api(state: State):\n        \"\"\"Example node that makes an API request.\"\"\"\n        requests = [_make_request(url) for url in state['urls']]\n        results = [request.result() for request in requests]\n        return {\n            \"results\": results\n        }\n\n# Create a StateGraph builder and add a node for the call_api function\n    builder = StateGraph(State)\n    builder.add_node(\"call_api\", call_api)\n\n# Connect the start and end nodes to the call_api node\n    builder.add_edge(START, \"call_api\")\n    builder.add_edge(\"call_api\", END)\n\n# Specify a checkpointer\n    checkpointer = InMemorySaver()\n\n# Compile the graph with the checkpointer\n    graph = builder.compile(checkpointer=checkpointer)\n\n# Define a config with a thread ID.\n    thread_id = uuid.uuid4()\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n\n# Invoke the graph\n    graph.invoke({\"urls\": [\"https://www.example.com\"]}, config)\n    ```\n\n## Resuming Workflows\n\nOnce you have enabled durable execution in your workflow, you can resume execution for the following scenarios:\n\n- **Pausing and Resuming Workflows:** Use the [interrupt](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Interrupt) function to pause a workflow at specific points and the [Command](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Command) primitive to resume it with updated state. See [**Human-in-the-Loop**](./human_in_the_loop.md) for more details.\n- **Recovering from Failures:** Automatically resume workflows from the last successful checkpoint after an exception (e.g., LLM provider outage). This involves executing the workflow with the same thread identifier by providing it with a `None` as the input value (see this [example](../how-tos/use-functional-api.md#resuming-after-an-error) with the functional API).\n\n## Starting Points for Resuming Workflows\n\n- If you're using a [StateGraph (Graph API)](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.StateGraph), the starting point is the beginning of the [**node**](./low_level.md#nodes) where execution stopped.\n- If you're making a subgraph call inside a node, the starting point will be the **parent** node that called the subgraph that was halted.\n  Inside the subgraph, the starting point will be the specific [**node**](./low_level.md#nodes) where execution stopped.\n- If you're using the Functional API, the starting point is the beginning of the [**entrypoint**](./functional_api.md#entrypoint) where execution stopped.\n\n---\nconcepts/langgraph_data_plane.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph Data Plane\n\nThe term \"data plane\" is used broadly to refer to [LangGraph Servers](./langgraph_server.md) (deployments), the corresponding infrastructure for each server, and the \"listener\" application that continuously polls for updates from the [LangGraph Control Plane](./langgraph_control_plane.md).\n\n## Server Infrastructure\n\nIn addition to the [LangGraph Server](./langgraph_server.md) itself, the following infrastructure components for each server are also included in the broad definition of \"data plane\":\n\n- Postgres\n- Redis\n- Secrets store\n- Autoscalers\n\n## \"Listener\" Application\n\nThe data plane \"listener\" application periodically calls [control plane APIs](../concepts/langgraph_control_plane.md#control-plane-api) to:\n\n- Determine if new deployments should be created.\n- Determine if existing deployments should be updated (i.e. new revisions).\n- Determine if existing deployments should be deleted.\n\nIn other words, the data plane \"listener\" reads the latest state of the control plane (desired state) and takes action to reconcile outstanding deployments (current state) to match the latest state.\n\n## Postgres\n\nPostgres is the persistence layer for all user, run, and long-term memory data in a LangGraph Server. This stores both checkpoints (see more info [here](./persistence.md)), server resources (threads, runs, assistants and crons), as well as items saved in the long-term memory store (see more info [here](./persistence.md#memory-store)).\n\n## Redis\n\nRedis is used in each LangGraph Server as a way for server and queue workers to communicate, and to store ephemeral metadata. No user or run data is stored in Redis.\n\n### Communication\n\nAll runs in a LangGraph Server are executed by a pool of background workers that are part of each deployment. In order to enable some features for those runs (such as cancellation and output streaming) we need a channel for two-way communication between the server and the worker handling a particular run. We use Redis to organize that communication.\n\n1. A Redis list is used as a mechanism to wake up a worker as soon as a new run is created. Only a sentinel value is stored in this list, no actual run information. The run information is then retrieved from Postgres by the worker.\n2. A combination of a Redis string and Redis PubSub channel is used for the server to communicate a run cancellation request to the appropriate worker.\n3. A Redis PubSub channel is used by the worker to broadcast streaming output from an agent while the run is being handled. Any open `/stream` request in the server will subscribe to that channel and forward any events to the response as they arrive. No events are stored in Redis at any time.\n\n### Ephemeral metadata\n\nRuns in a LangGraph Server may be retried for specific failures (currently only for transient Postgres errors encountered during the run). In order to limit the number of retries (currently limited to 3 attempts per run) we record the attempt number in a Redis string when it is picked up. This contains no run-specific info other than its ID, and expires after a short delay.\n\n## Data Plane Features\n\nThis section describes various features of the data plane.\n\n### Data Region\n\n!!! info \"Only for Cloud SaaS\"\n    Data regions are only applicable for [Cloud SaaS](../concepts/langgraph_cloud.md) deployments.\n\nDeployments can be created in 2 data regions: US and EU\n\nThe data region for a deployment is implied by the data region of the LangSmith organization where the deployment is created. Deployments and the underlying database for the deployments cannot be migrated between data regions.\n\n### Autoscaling\n\n[`Production` type](../concepts/langgraph_control_plane.md#deployment-types) deployments automatically scale up to 10 containers. Scaling is based on 3 metrics:\n\n1. CPU utilization\n1. Memory utilization\n1. Number of pending (in progress) [runs](./assistants.md#execution)\n\nFor CPU utilization, the autoscaler targets 75% utilization. This means the autoscaler will scale the number of containers up or down to ensure that CPU utilization is at or near 75%. For memory utilization, the autoscaler targets 75% utilization as well.\n\nFor number of pending runs, the autoscaler targets 10 pending runs. For example, if the current number of containers is 1, but the number of pending runs in 20, the autoscaler will scale up the deployment to 2 containers (20 pending runs / 2 containers = 10 pending runs per container).\n\nEach metric is computed independently and the autoscaler will determine the scaling action based on the metric that results in the largest number of containers.\n\nScale down actions are delayed for 30 minutes before any action is taken. In other words, if the autoscaler decides to scale down a deployment, it will first wait for 30 minutes before scaling down. After 30 minutes, the metrics are recomputed and the deployment will scale down if the recomputed metrics result in a lower number of containers than the current number. Otherwise, the deployment remains scaled up. This \"cool down\" period ensures that deployments do not scale up and down too frequently.\n\n### Static IP Addresses\n\n!!! info \"Only for Cloud SaaS\"\nStatic IP addresses are only available for [Cloud SaaS](../concepts/langgraph_cloud.md) deployments.\n\nAll traffic from deployments created after January 6th 2025 will come through a NAT gateway. This NAT gateway will have several static IP addresses depending on the data region. Refer to the table below for the list of static IP addresses:\n\n| US             | EU             |\n| -------------- | -------------- |\n| 35.197.29.146  | 34.13.192.67   |\n| 34.145.102.123 | 34.147.105.64  |\n| 34.169.45.153  | 34.90.22.166   |\n| 34.82.222.17   | 34.147.36.213  |\n| 35.227.171.135 | 34.32.137.113  |\n| 34.169.88.30   | 34.91.238.184  |\n| 34.19.93.202   | 35.204.101.241 |\n| 34.19.34.50    | 35.204.48.32   |\n\n### Custom Postgres\n\n!!! info\nCustom Postgres instances are only available for [Self-Hosted Data Plane](../concepts/langgraph_self_hosted_data_plane.md) and [Self-Hosted Control Plane](../concepts/langgraph_self_hosted_control_plane.md) deployments.\n\nA custom Postgres instance can be used instead of the [one automatically created by the control plane](./langgraph_control_plane.md#database-provisioning). Specify the [`POSTGRES_URI_CUSTOM`](../cloud/reference/env_var.md#postgres_uri_custom) environment variable to use a custom Postgres instance.\n\nMultiple deployments can share the same Postgres instance. For example, for `Deployment A`, `POSTGRES_URI_CUSTOM` can be set to `postgres://<user>:<password>@/<database_name_1>?host=<hostname_1>` and for `Deployment B`, `POSTGRES_URI_CUSTOM` can be set to `postgres://<user>:<password>@/<database_name_2>?host=<hostname_1>`. `<database_name_1>` and `database_name_2` are different databases within the same instance, but `<hostname_1>` is shared. **The same database cannot be used for separate deployments**.\n\n### Custom Redis\n\n!!! info\nCustom Redis instances are only available for [Self-Hosted Data Plane](../concepts/langgraph_self_hosted_control_plane.md) and [Self-Hosted Control Plane](../concepts/langgraph_self_hosted_control_plane.md) deployments.", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "A custom Redis instance can be used instead of the one automatically created by the control plane. Specify the [REDIS_URI_CUSTOM](../cloud/reference/env_var.md#redis_uri_custom) environment variable to use a custom Redis instance.\n\nMultiple deployments can share the same Redis instance. For example, for `Deployment A`, `REDIS_URI_CUSTOM` can be set to `redis://<hostname_1>:<port>/1` and for `Deployment B`, `REDIS_URI_CUSTOM` can be set to `redis://<hostname_1>:<port>/2`. `1` and `2` are different database numbers within the same instance, but `<hostname_1>` is shared. **The same database number cannot be used for separate deployments**.\n\n### LangSmith Tracing\n\nLangGraph Server is automatically configured to send traces to LangSmith. See the table below for details with respect to each deployment option.\n\n| Cloud SaaS                               | Self-Hosted Data Plane                                      | Self-Hosted Control Plane                                          | Standalone Container                                                                         |\n| ---------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- |\n| Required<br><br>Trace to LangSmith SaaS. | Optional<br><br>Disable tracing or trace to LangSmith SaaS. | Optional<br><br>Disable tracing or trace to Self-Hosted LangSmith. | Optional<br><br>Disable tracing, trace to LangSmith SaaS, or trace to Self-Hosted LangSmith. |\n\n### Telemetry\n\nLangGraph Server is automatically configured to report telemetry metadata for billing purposes. See the table below for details with respect to each deployment option.\n\n| Cloud SaaS                        | Self-Hosted Data Plane            | Self-Hosted Control Plane                                                                                                           | Standalone Container                                                                                                                |\n| --------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |\n| Telemetry sent to LangSmith SaaS. | Telemetry sent to LangSmith SaaS. | Self-reported usage (audit) for air-gapped license key.<br><br>Telemetry sent to LangSmith SaaS for LangGraph Platform License Key. | Self-reported usage (audit) for air-gapped license key.<br><br>Telemetry sent to LangSmith SaaS for LangGraph Platform License Key. |\n\n### Licensing\n\nLangGraph Server is automatically configured to perform license key validation. See the table below for details with respect to each deployment option.\n\n| Cloud SaaS                                          | Self-Hosted Data Plane                              | Self-Hosted Control Plane                                                                  | Standalone Container                                                                       |\n| --------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |\n| LangSmith API Key validated against LangSmith SaaS. | LangSmith API Key validated against LangSmith SaaS. | Air-gapped license key or LangGraph Platform License Key validated against LangSmith SaaS. | Air-gapped license key or LangGraph Platform License Key validated against LangSmith SaaS. |\n\n---\nconcepts/why-langgraph.md\n---\n\n# Overview\n\nLangGraph is built for developers who want to build powerful, adaptable AI agents. Developers choose LangGraph for:\n\n- **Reliability and controllability.** Steer agent actions with moderation checks and human-in-the-loop approvals. LangGraph persists context for long-running workflows, keeping your agents on course.\n- **Low-level and extensible.** Build custom agents with fully descriptive, low-level primitives free from rigid abstractions that limit customization. Design scalable multi-agent systems, with each agent serving a specific role tailored to your use case.\n- **First-class streaming support.** With token-by-token streaming and streaming of intermediate steps, LangGraph gives users clear visibility into agent reasoning and actions as they unfold in real time.\n\n## Learn LangGraph basics\n\nTo get acquainted with LangGraph's key concepts and features, complete the following LangGraph basics tutorials series:\n\n1. [Build a basic chatbot](../tutorials/get-started/1-build-basic-chatbot.md)\n2. [Add tools](../tutorials/get-started/2-add-tools.md)\n3. [Add memory](../tutorials/get-started/3-add-memory.md)\n4. [Add human-in-the-loop controls](../tutorials/get-started/4-human-in-the-loop.md)\n5. [Customize state](../tutorials/get-started/5-customize-state.md)\n6. [Time travel](../tutorials/get-started/6-time-travel.md)\n\nIn completing this series of tutorials, you will build a support chatbot in LangGraph that can:\n\n* ✅ **Answer common questions** by searching the web\n* ✅ **Maintain conversation state** across calls  \n* ✅ **Route complex queries** to a human for review  \n* ✅ **Use custom state** to control its behavior  \n* ✅ **Rewind and explore** alternative conversation paths\n\n---\nconcepts/langgraph_self_hosted_control_plane.md\n---\n\n# Self-Hosted Control Plane\n\nThere are two versions of the self-hosted deployment: [Self-Hosted Data Plane](./deployment_options.md#self-hosted-data-plane) and [Self-Hosted Control Plane](./deployment_options.md#self-hosted-control-plane).\n\n!!! info \"Important\"\n\nThe Self-Hosted Control Plane deployment option requires an [Enterprise](plans.md) plan.\n\n## Requirements\n\n- You use the [LangGraph CLI](./langgraph_cli.md) and/or [LangGraph Studio](./langgraph_studio.md) app to test graph locally.\n- You use `langgraph build` command to build image.\n- You have a Self-Hosted LangSmith instance deployed.\n- You are using Ingress for your LangSmith instance. All agents will be deployed as Kubernetes services behind this ingress.\n\n## Self-Hosted Control Plane\n\nThe [Self-Hosted Control Plane](./langgraph_self_hosted_control_plane.md) deployment option is a fully self-hosted model for deployment where you manage the [control plane](./langgraph_control_plane.md) and [data plane](./langgraph_data_plane.md) in your cloud. This option gives you full control and responsibility of the control plane and data plane infrastructure.\n\n|                                    | [Control plane](../concepts/langgraph_control_plane.md)                                                                                     | [Data plane](../concepts/langgraph_data_plane.md)                                                                                                   |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **What is it?**                    | <ul><li>Control plane UI for creating deployments and revisions</li><li>Control plane APIs for creating deployments and revisions</li></ul> | <ul><li>Data plane \"listener\" for reconciling deployments with control plane state</li><li>LangGraph Servers</li><li>Postgres, Redis, etc</li></ul> |\n| **Where is it hosted?**            | Your cloud                                                                                                                                  | Your cloud                                                                                                                                          |\n| **Who provisions and manages it?** | You                                                                                                                                         | You                                                                                                                                                 |\n\n### Architecture\n\n![Self-Hosted Control Plane Architecture](./img/self_hosted_control_plane_architecture.png)\n\n### Compute Platforms\n\n- **Kubernetes**: The Self-Hosted Control Plane deployment option supports deploying control plane and data plane infrastructure to any Kubernetes cluster.\n\n!!! tip\nIf you would like to enable this on your LangSmith instance, please follow the [Self-Hosted Control Plane deployment guide](../cloud/deployment/self_hosted_control_plane.md).\n\n---\nconcepts/langgraph_cli.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# LangGraph CLI\n\n**LangGraph CLI** is a multi-platform command-line tool for building and running the [LangGraph API server](./langgraph_server.md) locally. The resulting server includes all API endpoints for your graph's runs, threads, assistants, etc. as well as the other services required to run your agent, including a managed database for checkpointing and storage.\n\n## Installation\n\nThe LangGraph CLI can be installed via pip or [Homebrew](https://brew.sh/):\n\n=== \"pip\"\n\n```bash\n    pip install langgraph-cli\n    ```\n\n=== \"Homebrew\"\n\n```bash\n    brew install langgraph-cli\n    ```\n\n## Commands\n\nLangGraph CLI provides the following core functionality:\n\n| Command                                                        | Description                                                                                                                                                                                                                                                                            |\n| -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [`langgraph build`](../cloud/reference/cli.md#build)           | Builds a Docker image for the [LangGraph API server](./langgraph_server.md) that can be directly deployed.                                                                                                                                                                             |\n| [`langgraph dev`](../cloud/reference/cli.md#dev)               | Starts a lightweight development server that requires no Docker installation. This server is ideal for rapid development and testing.                                                                                                                                                  |\n| [`langgraph dockerfile`](../cloud/reference/cli.md#dockerfile) | Generates a [Dockerfile](https://docs.docker.com/reference/dockerfile/) that can be used to build images for and deploy instances of the [LangGraph API server](./langgraph_server.md). This is useful if you want to further customize the dockerfile or deploy in a more custom way. |\n| [`langgraph up`](../cloud/reference/cli.md#up)                 | Starts an instance of the [LangGraph API server](./langgraph_server.md) locally in a docker container. This requires the docker server to be running locally. It also requires a LangSmith API key for local development or a license key for production use.                          |\n\nFor more information, see the [LangGraph CLI Reference](../cloud/reference/cli.md).\n\n---\nconcepts/persistence.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Persistence\n\nLangGraph has a built-in persistence layer, implemented through checkpointers. When you compile a graph with a checkpointer, the checkpointer saves a `checkpoint` of the graph state at every super-step. Those checkpoints are saved to a `thread`, which can be accessed after graph execution. Because `threads` allow access to graph's state after execution, several powerful capabilities including human-in-the-loop, memory, time travel, and fault-tolerance are all possible. Below, we'll discuss each of these concepts in more detail.\n\n![Checkpoints](img/persistence/checkpoints.jpg)\n\n!!! info \"LangGraph API handles checkpointing automatically\"\n\nWhen using the LangGraph API, you don't need to implement or configure checkpointers manually. The API handles all persistence infrastructure for you behind the scenes.\n\n## Threads\n\nA thread is a unique ID or thread identifier assigned to each checkpoint saved by a checkpointer. It contains the accumulated state of a sequence of [runs](./assistants.md#execution). When a run is executed, the [state](../concepts/low_level.md#state) of the underlying graph of the assistant will be persisted to the thread.\n\nWhen invoking a graph with a checkpointer, you **must** specify a `thread_id` as part of the `configurable` portion of the config:\n\n```python\n{\"configurable\": {\"thread_id\": \"1\"}}\n```\n\nA thread's current and historical state can be retrieved. To persist state, a thread must be created prior to executing a run. The LangGraph Platform API provides several endpoints for creating and managing threads and thread state. See the [API reference](../cloud/reference/api/api_ref.html#tag/threads) for more details.\n\n## Checkpoints\n\nThe state of a thread at a particular point in time is called a checkpoint. Checkpoint is a snapshot of the graph state saved at each super-step and is represented by `StateSnapshot` object with the following key properties:\n\n- `config`: Config associated with this checkpoint.\n- `metadata`: Metadata associated with this checkpoint.\n- `values`: Values of the state channels at this point in time.\n- `next` A tuple of the node names to execute next in the graph.\n- `tasks`: A tuple of `PregelTask` objects that contain information about next tasks to be executed. If the step was previously attempted, it will include error information. If a graph was interrupted [dynamically](../how-tos/human_in_the_loop/add-human-in-the-loop.md#pause-using-interrupt) from within a node, tasks will contain additional data associated with interrupts.\n\nCheckpoints are persisted and can be used to restore the state of a thread at a later time.\n\nLet's see what checkpoints are saved when a simple graph is invoked as follows:\n\n```python\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import Annotated\nfrom typing_extensions import TypedDict\nfrom operator import add\n\nclass State(TypedDict):\n    foo: str\n    bar: Annotated[list[str], add]\n\ndef node_a(state: State):\n    return {\"foo\": \"a\", \"bar\": [\"a\"]}\n\ndef node_b(state: State):\n    return {\"foo\": \"b\", \"bar\": [\"b\"]}\n\nworkflow = StateGraph(State)\nworkflow.add_node(node_a)\nworkflow.add_node(node_b)\nworkflow.add_edge(START, \"node_a\")\nworkflow.add_edge(\"node_a\", \"node_b\")\nworkflow.add_edge(\"node_b\", END)\n\ncheckpointer = InMemorySaver()\ngraph = workflow.compile(checkpointer=checkpointer)\n\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\ngraph.invoke({\"foo\": \"\"}, config)\n```\n\nAfter we run the graph, we expect to see exactly 4 checkpoints:\n\n- empty checkpoint with `START` as the next node to be executed\n- checkpoint with the user input `{'foo': '', 'bar': []}` and `node_a` as the next node to be executed\n- checkpoint with the outputs of `node_a` `{'foo': 'a', 'bar': ['a']}` and `node_b` as the next node to be executed\n- checkpoint with the outputs of `node_b` `{'foo': 'b', 'bar': ['a', 'b']}` and no next nodes to be executed\n\nNote that we `bar` channel values contain outputs from both nodes as we have a reducer for `bar` channel.\n\n### Get state\n\nWhen interacting with the saved graph state, you **must** specify a [thread identifier](#threads). You can view the _latest_ state of the graph by calling `graph.get_state(config)`. This will return a `StateSnapshot` object that corresponds to the latest checkpoint associated with the thread ID provided in the config or a checkpoint associated with a checkpoint ID for the thread, if provided.\n\n```python\n# get the latest state snapshot\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\ngraph.get_state(config)\n\n# get a state snapshot for a specific checkpoint_id\nconfig = {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_id\": \"1ef663ba-28fe-6528-8002-5a559208592c\"}}\ngraph.get_state(config)\n```\n\nIn our example, the output of `get_state` will look like this:\n\n```\nStateSnapshot(\n    values={'foo': 'b', 'bar': ['a', 'b']},\n    next=(),\n    config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28fe-6528-8002-5a559208592c'}},\n    metadata={'source': 'loop', 'writes': {'node_b': {'foo': 'b', 'bar': ['b']}}, 'step': 2},\n    created_at='2024-08-29T19:19:38.821749+00:00',\n    parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f9-6ec4-8001-31981c2c39f8'}}, tasks=()\n)\n```\n\n### Get state history\n\nYou can get the full history of the graph execution for a given thread by calling `graph.get_state_history(config)`. This will return a list of `StateSnapshot` objects associated with the thread ID provided in the config. Importantly, the checkpoints will be ordered chronologically with the most recent checkpoint / `StateSnapshot` being the first in the list.\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\nlist(graph.get_state_history(config))\n```\n\nIn our example, the output of `get_state_history` will look like this:\n\n```\n[\n    StateSnapshot(\n        values={'foo': 'b', 'bar': ['a', 'b']},\n        next=(),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28fe-6528-8002-5a559208592c'}},\n        metadata={'source': 'loop', 'writes': {'node_b': {'foo': 'b', 'bar': ['b']}}, 'step': 2},\n        created_at='2024-08-29T19:19:38.821749+00:00',\n        parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f9-6ec4-8001-31981c2c39f8'}},\n        tasks=(),\n    ),\n    StateSnapshot(\n        values={'foo': 'a', 'bar': ['a']},\n        next=('node_b',),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f9-6ec4-8001-31981c2c39f8'}},\n        metadata={'source': 'loop', 'writes': {'node_a': {'foo': 'a', 'bar': ['a']}}, 'step': 1},\n        created_at='2024-08-29T19:19:38.819946+00:00',\n        parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f4-6b4a-8000-ca575a13d36a'}},\n        tasks=(PregelTask(id='6fb7314f-f114-5413-a1f3-d37dfe98ff44', name='node_b', error=None, interrupts=()),),\n    ),\n    StateSnapshot(\n        values={'foo': '', 'bar': []},\n        next=('node_a',),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f4-6b4a-8000-ca575a13d36a'}},\n        metadata={'source': 'loop', 'writes': None, 'step': 0},\n        created_at='2024-08-29T19:19:38.817813+00:00',\n        parent_config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f0-6c66-bfff-6723431e8481'}},\n        tasks=(PregelTask(id='f1b14528-5ee5-579c-949b-23ef9bfbed58', name='node_a', error=None, interrupts=()),),\n    ),\n    StateSnapshot(\n        values={'bar': []},\n        next=('__start__',),\n        config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef663ba-28f0-6c66-bfff-6723431e8481'}},\n        metadata={'source': 'input', 'writes': {'foo': ''}, 'step': -1},\n        created_at='2024-08-29T19:19:38.816205+00:00',\n        parent_config=None,\n        tasks=(PregelTask(id='6d27aa2e-d72b-5504-a36f-8620e54a76dd', name='__start__', error=None, interrupts=()),),\n    )\n]\n```\n\n![State](img/persistence/get_state.jpg)\n\n### Replay\n\nIt's also possible to play-back a prior graph execution. If we `invoke` a graph with a `thread_id` and a `checkpoint_id`, then we will _re-play_ the previously executed steps _before_ a checkpoint that corresponds to the `checkpoint_id`, and only execute the steps _after_ the checkpoint.\n\n- `thread_id` is the ID of a thread.\n- `checkpoint_id` is an identifier that refers to a specific checkpoint within a thread.\n\nYou must pass these when invoking the graph as part of the `configurable` portion of the config:\n\n```python\nconfig = {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_id\": \"0c62ca34-ac19-445d-bbb0-5b4984975b2a\"}}\ngraph.invoke(None, config=config)\n```\n\nImportantly, LangGraph knows whether a particular step has been executed previously. If it has, LangGraph simply _re-plays_ that particular step in the graph and does not re-execute the step, but only for the steps _before_ the provided `checkpoint_id`. All of the steps _after_ `checkpoint_id` will be executed (i.e., a new fork), even if they have been executed previously. See this [how to guide on time-travel to learn more about replaying](../how-tos/human_in_the_loop/time-travel.md).\n\n![Replay](img/persistence/re_play.png)\n\n### Update state\n\nIn addition to re-playing the graph from specific `checkpoints`, we can also _edit_ the graph state. We do this using `graph.update_state()`. This method accepts three different arguments:\n\n#### `config`\n\nThe config should contain `thread_id` specifying which thread to update. When only the `thread_id` is passed, we update (or fork) the current state. Optionally, if we include `checkpoint_id` field, then we fork that selected checkpoint.\n\n#### `values`\n\nThese are the values that will be used to update the state. Note that this update is treated exactly as any update from a node is treated. This means that these values will be passed to the [reducer](./low_level.md#reducers) functions, if they are defined for some of the channels in the graph state. This means that `update_state` does NOT automatically overwrite the channel values for every channel, but only for the channels without reducers. Let's walk through an example.\n\nLet's assume you have defined the state of your graph with the following schema (see full example above):\n\n```python\nfrom typing import Annotated\nfrom typing_extensions import TypedDict\nfrom operator import add\n\nclass State(TypedDict):\n    foo: int\n    bar: Annotated[list[str], add]\n```\n\nLet's now assume the current state of the graph is\n\n```\n{\"foo\": 1, \"bar\": [\"a\"]}\n```\n\nIf you update the state as below:\n\n```python\ngraph.update_state(config, {\"foo\": 2, \"bar\": [\"b\"]})\n```\n\nThen the new state of the graph will be:\n\n```\n{\"foo\": 2, \"bar\": [\"a\", \"b\"]}\n```\n\nThe `foo` key (channel) is completely changed (because there is no reducer specified for that channel, so `update_state` overwrites it). However, there is a reducer specified for the `bar` key, and so it appends `\"b\"` to the state of `bar`.\n\n#### `as_node`\n\nThe final thing you can optionally specify when calling `update_state` is `as_node`. If you provided it, the update will be applied as if it came from node `as_node`. If `as_node` is not provided, it will be set to the last node that updated the state, if not ambiguous. The reason this matters is that the next steps to execute depend on the last node to have given an update, so this can be used to control which node executes next. See this [how to guide on time-travel to learn more about forking state](../how-tos/human_in_the_loop/time-travel.md).\n\n![Update](img/persistence/checkpoints_full_story.jpg)\n\n## Memory Store\n\n![Model of shared state](img/persistence/shared_state.png)\n\nA [state schema](low_level.md#schema) specifies a set of keys that are populated as a graph is executed. As discussed above, state can be written by a checkpointer to a thread at each graph step, enabling state persistence.\n\nBut, what if we want to retain some information _across threads_? Consider the case of a chatbot where we want to retain specific information about the user across _all_ chat conversations (e.g., threads) with that user!\n\nWith checkpointers alone, we cannot share information across threads. This motivates the need for the [`Store`](../reference/store.md#langgraph.store.base.BaseStore) interface. As an illustration, we can define an `InMemoryStore` to store information about a user across threads. We simply compile our graph with a checkpointer, as before, and with our new `in_memory_store` variable.\n\n!!! info \"LangGraph API handles stores automatically\"\n\nWhen using the LangGraph API, you don't need to implement or configure stores manually. The API handles all storage infrastructure for you behind the scenes.\n\n### Basic Usage\n\nFirst, let's showcase this in isolation without using LangGraph.\n\n```python\nfrom langgraph.store.memory import InMemoryStore\nin_memory_store = InMemoryStore()\n```\n\nMemories are namespaced by a `tuple`, which in this specific example will be `(<user_id>, \"memories\")`. The namespace can be any length and represent anything, does not have to be user specific.\n\n```python\nuser_id = \"1\"\nnamespace_for_memory = (user_id, \"memories\")\n```\n\nWe use the `store.put` method to save memories to our namespace in the store. When we do this, we specify the namespace, as defined above, and a key-value pair for the memory: the key is simply a unique identifier for the memory (`memory_id`) and the value (a dictionary) is the memory itself.\n\n```python\nmemory_id = str(uuid.uuid4())\nmemory = {\"food_preference\" : \"I like pizza\"}\nin_memory_store.put(namespace_for_memory, memory_id, memory)\n```\n\nWe can read out memories in our namespace using the `store.search` method, which will return all memories for a given user as a list. The most recent memory is the last in the list.\n\n```python\nmemories = in_memory_store.search(namespace_for_memory)\nmemories[-1].dict()\n{'value': {'food_preference': 'I like pizza'},\n 'key': '07e0caf4-1631-47b7-b15f-65515d4c1843',\n 'namespace': ['1', 'memories'],\n 'created_at': '2024-10-02T17:22:31.590602+00:00',\n 'updated_at': '2024-10-02T17:22:31.590605+00:00'}\n```\n\nEach memory type is a Python class ([`Item`](https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.base.Item)) with certain attributes. We can access it as a dictionary by converting via `.dict` as above.\n\nThe attributes it has are:\n\n- `value`: The value (itself a dictionary) of this memory\n- `key`: A unique key for this memory in this namespace\n- `namespace`: A list of strings, the namespace of this memory type\n- `created_at`: Timestamp for when this memory was created\n- `updated_at`: Timestamp for when this memory was updated\n\n### Semantic Search\n\nBeyond simple retrieval, the store also supports semantic search, allowing you to find memories based on meaning rather than exact matches. To enable this, configure the store with an embedding model:\n\n```python\nfrom langchain.embeddings import init_embeddings\n\nstore = InMemoryStore(\n    index={\n        \"embed\": init_embeddings(\"openai:text-embedding-3-small\"),  # Embedding provider\n        \"dims\": 1536,                              # Embedding dimensions\n        \"fields\": [\"food_preference\", \"$\"]              # Fields to embed\n    }\n)\n```\n\nNow when searching, you can use natural language queries to find relevant memories:\n\n```python\n# Find memories about food preferences\n# (This can be done after putting memories into the store)\nmemories = store.search(\n    namespace_for_memory,\n    query=\"What does the user like to eat?\",\n    limit=3  # Return top 3 matches\n)\n```\n\nYou can control which parts of your memories get embedded by configuring the `fields` parameter or by specifying the `index` parameter when storing memories:", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "```python\n# Store with specific fields to embed\nstore.put(\n    namespace_for_memory,\n    str(uuid.uuid4()),\n    {\n        \"food_preference\": \"I love Italian cuisine\",\n        \"context\": \"Discussing dinner plans\"\n    },\n    index=[\"food_preference\"]  # Only embed \"food_preferences\" field\n)\n\n# Store without embedding (still retrievable, but not searchable)\nstore.put(\n    namespace_for_memory,\n    str(uuid.uuid4()),\n    {\"system_info\": \"Last updated: 2024-01-01\"},\n    index=False\n)\n```\n\n### Using in LangGraph\n\nWith this all in place, we use the `in_memory_store` in LangGraph. The `in_memory_store` works hand-in-hand with the checkpointer: the checkpointer saves state to threads, as discussed above, and the `in_memory_store` allows us to store arbitrary information for access _across_ threads. We compile the graph with both the checkpointer and the `in_memory_store` as follows.\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\n\n# We need this because we want to enable threads (conversations)\ncheckpointer = InMemorySaver()\n\n# ... Define the graph ...\n\n# Compile the graph with the checkpointer and store\ngraph = graph.compile(checkpointer=checkpointer, store=in_memory_store)\n```\n\nWe invoke the graph with a `thread_id`, as before, and also with a `user_id`, which we'll use to namespace our memories to this particular user as we showed above.\n\n```python\n# Invoke the graph\nuser_id = \"1\"\nconfig = {\"configurable\": {\"thread_id\": \"1\", \"user_id\": user_id}}\n\n# First let's just say hi to the AI\nfor update in graph.stream(\n    {\"messages\": [{\"role\": \"user\", \"content\": \"hi\"}]}, config, stream_mode=\"updates\"\n):\n    print(update)\n```\n\nWe can access the `in_memory_store` and the `user_id` in _any node_ by passing `store: BaseStore` and `config: RunnableConfig` as node arguments. Here's how we might use semantic search in a node to find relevant memories:\n\n```python\ndef update_memory(state: MessagesState, config: RunnableConfig, *, store: BaseStore):\n\n# Get the user id from the config\n    user_id = config[\"configurable\"][\"user_id\"]\n\n# Namespace the memory\n    namespace = (user_id, \"memories\")\n\n# ... Analyze conversation and create a new memory\n\n# Create a new memory ID\n    memory_id = str(uuid.uuid4())\n\n# We create a new memory\n    store.put(namespace, memory_id, {\"memory\": memory})\n\n```\n\nAs we showed above, we can also access the store in any node and use the `store.search` method to get memories. Recall the memories are returned as a list of objects that can be converted to a dictionary.\n\n```python\nmemories[-1].dict()\n{'value': {'food_preference': 'I like pizza'},\n 'key': '07e0caf4-1631-47b7-b15f-65515d4c1843',\n 'namespace': ['1', 'memories'],\n 'created_at': '2024-10-02T17:22:31.590602+00:00',\n 'updated_at': '2024-10-02T17:22:31.590605+00:00'}\n```\n\nWe can access the memories and use them in our model call.\n\n```python\ndef call_model(state: MessagesState, config: RunnableConfig, *, store: BaseStore):\n    # Get the user id from the config\n    user_id = config[\"configurable\"][\"user_id\"]\n\n# Namespace the memory\n    namespace = (user_id, \"memories\")\n\n# Search based on the most recent message\n    memories = store.search(\n        namespace,\n        query=state[\"messages\"][-1].content,\n        limit=3\n    )\n    info = \"\\n\".join([d.value[\"memory\"] for d in memories])\n\n# ... Use memories in the model call\n```\n\nIf we create a new thread, we can still access the same memories so long as the `user_id` is the same.\n\n```python\n# Invoke the graph\nconfig = {\"configurable\": {\"thread_id\": \"2\", \"user_id\": \"1\"}}\n\n# Let's say hi again\nfor update in graph.stream(\n    {\"messages\": [{\"role\": \"user\", \"content\": \"hi, tell me about my memories\"}]}, config, stream_mode=\"updates\"\n):\n    print(update)\n```\n\nWhen we use the LangGraph Platform, either locally (e.g., in LangGraph Studio) or with LangGraph Platform, the base store is available to use by default and does not need to be specified during graph compilation. To enable semantic search, however, you **do** need to configure the indexing settings in your `langgraph.json` file. For example:\n\n```json\n{\n    ...\n    \"store\": {\n        \"index\": {\n            \"embed\": \"openai:text-embeddings-3-small\",\n            \"dims\": 1536,\n            \"fields\": [\"$\"]\n        }\n    }\n}\n```\n\nSee the [deployment guide](../cloud/deployment/semantic_search.md) for more details and configuration options.\n\n## Checkpointer libraries\n\nUnder the hood, checkpointing is powered by checkpointer objects that conform to [BaseCheckpointSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.base.BaseCheckpointSaver) interface. LangGraph provides several checkpointer implementations, all implemented via standalone, installable libraries:\n\n- `langgraph-checkpoint`: The base interface for checkpointer savers ([BaseCheckpointSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.base.BaseCheckpointSaver)) and serialization/deserialization interface ([SerializerProtocol](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.base.SerializerProtocol)). Includes in-memory checkpointer implementation ([InMemorySaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.memory.InMemorySaver)) for experimentation. LangGraph comes with `langgraph-checkpoint` included.\n- `langgraph-checkpoint-sqlite`: An implementation of LangGraph checkpointer that uses SQLite database ([SqliteSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.sqlite.SqliteSaver) / [AsyncSqliteSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.sqlite.aio.AsyncSqliteSaver)). Ideal for experimentation and local workflows. Needs to be installed separately.\n- `langgraph-checkpoint-postgres`: An advanced checkpointer that uses Postgres database ([PostgresSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.postgres.PostgresSaver) / [AsyncPostgresSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.postgres.aio.AsyncPostgresSaver)), used in LangGraph Platform. Ideal for using in production. Needs to be installed separately.\n\n### Checkpointer interface\n\nEach checkpointer conforms to [BaseCheckpointSaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.base.BaseCheckpointSaver) interface and implements the following methods:\n\n- `.put` - Store a checkpoint with its configuration and metadata.\n- `.put_writes` - Store intermediate writes linked to a checkpoint (i.e. [pending writes](#pending-writes)).\n- `.get_tuple` - Fetch a checkpoint tuple using for a given configuration (`thread_id` and `checkpoint_id`). This is used to populate `StateSnapshot` in `graph.get_state()`.\n- `.list` - List checkpoints that match a given configuration and filter criteria. This is used to populate state history in `graph.get_state_history()`\n\nIf the checkpointer is used with asynchronous graph execution (i.e. executing the graph via `.ainvoke`, `.astream`, `.abatch`), asynchronous versions of the above methods will be used (`.aput`, `.aput_writes`, `.aget_tuple`, `.alist`).\n\n!!! note\n\nFor running your graph asynchronously, you can use `InMemorySaver`, or async versions of Sqlite/Postgres checkpointers -- `AsyncSqliteSaver` / `AsyncPostgresSaver` checkpointers.\n\n### Serializer\n\nWhen checkpointers save the graph state, they need to serialize the channel values in the state. This is done using serializer objects.\n\n`langgraph_checkpoint` defines [protocol](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.base.SerializerProtocol) for implementing serializers provides a default implementation ([JsonPlusSerializer](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.jsonplus.JsonPlusSerializer)) that handles a wide variety of types, including LangChain and LangGraph primitives, datetimes, enums and more.\n\n#### Serialization with `pickle`\n\nThe default serializer, [`JsonPlusSerializer`](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.jsonplus.JsonPlusSerializer), uses ormsgpack and JSON under the hood, which is not suitable for all types of objects.\n\nIf you want to fallback to pickle for objects not currently supported by our msgpack encoder (such as Pandas dataframes),\nyou can use the `pickle_fallback` argument of the `JsonPlusSerializer`:\n\n```python\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langgraph.checkpoint.serde.jsonplus import JsonPlusSerializer\n\n# ... Define the graph ...\ngraph.compile(\n    checkpointer=InMemorySaver(serde=JsonPlusSerializer(pickle_fallback=True))\n)\n```\n\n#### Encryption\n\nCheckpointers can optionally encrypt all persisted state. To enable this, pass an instance of [`EncryptedSerializer`](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.encrypted.EncryptedSerializer) to the `serde` argument of any `BaseCheckpointSaver` implementation. The easiest way to create an encrypted serializer is via [`from_pycryptodome_aes`](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.encrypted.EncryptedSerializer.from_pycryptodome_aes), which reads the AES key from the `LANGGRAPH_AES_KEY` environment variable (or accepts a `key` argument):\n\n```python\nimport sqlite3\n\nfrom langgraph.checkpoint.serde.encrypted import EncryptedSerializer\nfrom langgraph.checkpoint.sqlite import SqliteSaver\n\nserde = EncryptedSerializer.from_pycryptodome_aes()  # reads LANGGRAPH_AES_KEY\ncheckpointer = SqliteSaver(sqlite3.connect(\"checkpoint.db\"), serde=serde)\n```\n\n```python\nfrom langgraph.checkpoint.serde.encrypted import EncryptedSerializer\nfrom langgraph.checkpoint.postgres import PostgresSaver\n\nserde = EncryptedSerializer.from_pycryptodome_aes()\ncheckpointer = PostgresSaver.from_conn_string(\"postgresql://...\", serde=serde)\ncheckpointer.setup()\n```\n\nWhen running on LangGraph Platform, encryption is automatically enabled whenever `LANGGRAPH_AES_KEY` is present, so you only need to provide the environment variable. Other encryption schemes can be used by implementing [`CipherProtocol`](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.serde.base.CipherProtocol) and supplying it to `EncryptedSerializer`.\n\n## Capabilities\n\n### Human-in-the-loop\n\nFirst, checkpointers facilitate [human-in-the-loop workflows](agentic_concepts.md#human-in-the-loop) workflows by allowing humans to inspect, interrupt, and approve graph steps. Checkpointers are needed for these workflows as the human has to be able to view the state of a graph at any point in time, and the graph has to be to resume execution after the human has made any updates to the state. See [the how-to guides](../how-tos/human_in_the_loop/add-human-in-the-loop.md) for examples.\n\n### Memory\n\nSecond, checkpointers allow for [\"memory\"](../concepts/memory.md) between interactions. In the case of repeated human interactions (like conversations) any follow up messages can be sent to that thread, which will retain its memory of previous ones. See [Add memory](../how-tos/memory/add-memory.md) for information on how to add and manage conversation memory using checkpointers.\n\n### Time Travel\n\nThird, checkpointers allow for [\"time travel\"](time-travel.md), allowing users to replay prior graph executions to review and / or debug specific graph steps. In addition, checkpointers make it possible to fork the graph state at arbitrary checkpoints to explore alternative trajectories.\n\n### Fault-tolerance\n\nLastly, checkpointing also provides fault-tolerance and error recovery: if one or more nodes fail at a given superstep, you can restart your graph from the last successful step. Additionally, when a graph node fails mid-execution at a given superstep, LangGraph stores pending checkpoint writes from any other nodes that completed successfully at that superstep, so that whenever we resume graph execution from that superstep we don't re-run the successful nodes.\n\n#### Pending writes\n\nAdditionally, when a graph node fails mid-execution at a given superstep, LangGraph stores pending checkpoint writes from any other nodes that completed successfully at that superstep, so that whenever we resume graph execution from that superstep we don't re-run the successful nodes.\n\n---\nconcepts/application_structure.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Application Structure\n\n## Overview\n\nA LangGraph application consists of one or more graphs, a configuration file (`langgraph.json`), a file that specifies dependencies, and an optional `.env` file that specifies environment variables.\n\nThis guide shows a typical structure of an application and shows how the required information to deploy an application using the LangGraph Platform is specified.\n\n## Key Concepts\n\nTo deploy using the LangGraph Platform, the following information should be provided:\n\n1. A [LangGraph configuration file](#configuration-file-concepts) (`langgraph.json`) that specifies the dependencies, graphs, and environment variables to use for the application.\n2. The [graphs](#graphs) that implement the logic of the application.\n3. A file that specifies [dependencies](#dependencies) required to run the application.\n4. [Environment variables](#environment-variables) that are required for the application to run.\n\n## File Structure\n\nBelow are examples of directory structures for applications:\n\n=== \"Python (requirements.txt)\"\n\n```plaintext\n    my-app/\n    ├── my_agent # all project code lies within here\n    │   ├── utils # utilities for your graph\n    │   │   ├── __init__.py\n    │   │   ├── tools.py # tools for your graph\n    │   │   ├── nodes.py # node functions for your graph\n    │   │   └── state.py # state definition of your graph\n    │   ├── __init__.py\n    │   └── agent.py # code for constructing your graph\n    ├── .env # environment variables\n    ├── requirements.txt # package dependencies\n    └── langgraph.json # configuration file for LangGraph\n    ```\n\n=== \"Python (pyproject.toml)\"\n\n```plaintext\n    my-app/\n    ├── my_agent # all project code lies within here\n    │   ├── utils # utilities for your graph\n    │   │   ├── __init__.py\n    │   │   ├── tools.py # tools for your graph\n    │   │   ├── nodes.py # node functions for your graph\n    │   │   └── state.py # state definition of your graph\n    │   ├── __init__.py\n    │   └── agent.py # code for constructing your graph\n    ├── .env # environment variables\n    ├── langgraph.json  # configuration file for LangGraph\n    └── pyproject.toml # dependencies for your project\n    ```\n\n!!! note\n\nThe directory structure of a LangGraph application can vary depending on the programming language and the package manager used.\n\n## Configuration File {#configuration-file-concepts}\n\nThe `langgraph.json` file is a JSON file that specifies the dependencies, graphs, environment variables, and other settings required to deploy a LangGraph application.\n\nSee the [LangGraph configuration file reference](../cloud/reference/cli.md#configuration-file) for details on all supported keys in the JSON file.\n\n!!! tip\n\nThe [LangGraph CLI](./langgraph_cli.md) defaults to using the configuration file `langgraph.json` in the current directory.\n\n### Examples\n\n- The dependencies involve a custom local package and the `langchain_openai` package.\n- A single graph will be loaded from the file `./your_package/your_file.py` with the variable `variable`.\n- The environment variables are loaded from the `.env` file.\n\n```json\n{\n  \"dependencies\": [\"langchain_openai\", \"./your_package\"],\n  \"graphs\": {\n    \"my_agent\": \"./your_package/your_file.py:agent\"\n  },\n  \"env\": \"./.env\"\n}\n```\n\n## Dependencies\n\nA LangGraph application may depend on other Python packages.\n\nYou will generally need to specify the following information for dependencies to be set up correctly:\n\n1. A file in the directory that specifies the dependencies (e.g. `requirements.txt`, `pyproject.toml`, or `package.json`).\n\n2. A `dependencies` key in the [LangGraph configuration file](#configuration-file-concepts) that specifies the dependencies required to run the LangGraph application.\n3. Any additional binaries or system libraries can be specified using `dockerfile_lines` key in the [LangGraph configuration file](#configuration-file-concepts).\n\n## Graphs\n\nUse the `graphs` key in the [LangGraph configuration file](#configuration-file-concepts) to specify which graphs will be available in the deployed LangGraph application.\n\nYou can specify one or more graphs in the configuration file. Each graph is identified by a name (which should be unique) and a path for either: (1) the compiled graph or (2) a function that makes a graph is defined.\n\n## Environment Variables\n\nIf you're working with a deployed LangGraph application locally, you can configure environment variables in the `env` key of the [LangGraph configuration file](#configuration-file-concepts).\n\nFor a production deployment, you will typically want to configure the environment variables in the deployment environment.\n\n---\nconcepts/time-travel.md\n---\n\n---\nsearch:\n  boost: 2\n---\n\n# Time Travel ⏱️\n\nWhen working with non-deterministic systems that make model-based decisions (e.g., agents powered by LLMs), it can be useful to examine their decision-making process in detail:\n\n1. 🤔 **Understand reasoning**: Analyze the steps that led to a successful result.\n2. 🐞 **Debug mistakes**: Identify where and why errors occurred.\n3. 🔍 **Explore alternatives**: Test different paths to uncover better solutions.\n\nLangGraph provides [time travel functionality](../how-tos/human_in_the_loop/time-travel.md) to support these use cases. Specifically, you can resume execution from a prior checkpoint — either replaying the same state or modifying it to explore alternatives. In all cases, resuming past execution produces a new fork in the history.\n\n!!! tip\n\nFor information on how to use time travel, see [Use time travel](../how-tos/human_in_the_loop/time-travel.md) and [Time travel using Server API](../cloud/how-tos/human_in_the_loop_time_travel.md).", "metadata": {"file": "langgraph-llms-full.txt"}}
{"content": "- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/index/): This page provides an overview of the LangGraph project, including its logo and essential scripts for functionality within MkDocs. It also includes a reference to the README.md file for detailed information about the project. The content is designed to be user-friendly and visually appealing.\n- [LangGraph Quickstart Guide](https://langchain-ai.github.io/langgraph/agents/agents/): This quickstart guide provides step-by-step instructions for setting up and using LangGraph's prebuilt components to create agentic systems. It covers prerequisites, installation, agent creation, configuration of language models, and advanced features like memory and structured output. Ideal for developers looking to leverage LangGraph for building intelligent agents.\n- [Getting Started with LangGraph: Building AI Agents](https://langchain-ai.github.io/langgraph/concepts/why-langgraph/): This page provides an overview of LangGraph, a platform designed for developers to create adaptable AI agents. It highlights key features such as reliability, extensibility, and streaming support, and offers a series of tutorials to help users build a support chatbot with various capabilities. By following the tutorials, developers will learn to implement essential functionalities like conversation state management and human-in-the-loop controls.\n- [Building a Basic Chatbot with LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/1-build-basic-chatbot/): This tutorial guides you through the process of creating a basic chatbot using LangGraph. It covers prerequisites, installation of necessary packages, and step-by-step instructions to set up a state machine for the chatbot. By the end of the tutorial, you will have a functional chatbot that can engage in simple conversations.\n- [Integrating Web Search Tools into Your Chatbot](https://langchain-ai.github.io/langgraph/tutorials/get-started/2-add-tools/): This tutorial guides you through the process of enhancing your chatbot's capabilities by integrating a web search tool, specifically the Tavily Search Engine. It covers prerequisites, installation, configuration, and the implementation of the search tool within a LangGraph-based chatbot. By the end, you'll have a functional chatbot that can retrieve real-time information to answer user queries beyond its training data.\n- [Implementing Memory in Chatbots with LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/3-add-memory/): This page provides a comprehensive guide on how to add memory functionality to chatbots using LangGraph's persistent checkpointing feature. It details the steps to create a `MemorySaver` checkpointer, compile the graph, and interact with the chatbot to maintain context across multiple interactions. Additionally, it explains how to inspect the state of the chatbot and highlights the advantages of checkpointing over simple memory solutions.\n- [Implementing Human-in-the-Loop Controls in LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/4-human-in-the-loop/): This page provides a comprehensive guide on adding human-in-the-loop controls to LangGraph workflows, enabling agents to pause execution for human input. It details the use of the `interrupt` function to facilitate user feedback and outlines the steps to integrate a `human_assistance` tool into a chatbot. Additionally, the tutorial covers graph compilation, visualization, and resuming execution with human input.\n- [Customizing State in LangGraph for Enhanced Chatbot Functionality](https://langchain-ai.github.io/langgraph/tutorials/get-started/5-customize-state/): This tutorial guides you through the process of adding custom fields to the state in LangGraph, enabling complex behaviors in your chatbot without relying solely on message lists. You will learn how to implement human-in-the-loop controls to verify information before it is stored in the state. By the end of this tutorial, you will have a deeper understanding of state management and how to enhance your chatbot's capabilities.\n- [Implementing Time Travel in LangGraph Chatbots](https://langchain-ai.github.io/langgraph/tutorials/get-started/6-time-travel/): This page provides a comprehensive guide on utilizing the time travel functionality in LangGraph to enhance chatbot interactions. It covers how to rewind, add steps, and replay the state history of a chatbot, allowing users to explore different outcomes and fix mistakes. Additionally, it includes code snippets and practical examples to help developers implement these features effectively.\n- [LangGraph Deployment Options](https://langchain-ai.github.io/langgraph/tutorials/deployment/): This page outlines the various options available for deploying LangGraph applications, including local testing and different cloud-based solutions. It details free deployment methods such as Local, as well as production options like Cloud SaaS and self-hosted solutions. Each deployment method is linked to further documentation for in-depth guidance.\n- [Agent Development with LangGraph](https://langchain-ai.github.io/langgraph/agents/overview/): This page provides an overview of agent development using LangGraph, highlighting its prebuilt components and capabilities for building agent-based applications. It explains the structure of an agent, key features such as memory integration and human-in-the-loop control, and outlines the package ecosystem available for developers. With LangGraph, users can focus on application logic while leveraging robust infrastructure for state management and feedback.\n- [Guide to Running Agents in LangGraph](https://langchain-ai.github.io/langgraph/agents/run_agents/): This page provides a comprehensive overview of how to execute agents in LangGraph, detailing both synchronous and asynchronous methods. It covers input and output formats, streaming capabilities, and how to manage execution limits to prevent infinite loops. Additionally, it includes code examples and links to further resources for deeper understanding.\n- [Streaming Data in LangGraph](https://langchain-ai.github.io/langgraph/agents/streaming/): This page provides an overview of streaming data types in LangGraph, including agent progress, LLM tokens, and custom updates. It includes code examples for both synchronous and asynchronous streaming methods. Additionally, it covers how to stream multiple modes and disable streaming when necessary.\n- [Configuring Chat Models for Agents](https://langchain-ai.github.io/langgraph/agents/models/): This page provides detailed instructions on how to configure various chat models for use with agents in LangChain. It covers model initialization, tool calling support, and how to specify models from different providers such as OpenAI, Anthropic, Azure, Google Gemini, and AWS Bedrock. Additionally, it includes information on disabling streaming, adding model fallbacks, and links to further resources.\n- [Using Tools in LangChain](https://langchain-ai.github.io/langgraph/agents/tools/): This page provides an overview of how to define, customize, and manage tools within the LangChain framework. It covers creating simple tools, handling tool errors, and utilizing prebuilt integrations for enhanced functionality. Additionally, it discusses advanced features such as memory management and controlling tool behavior during agent execution.\n- [Integrating MCP with LangGraph Agents](https://langchain-ai.github.io/langgraph/agents/mcp/): This page provides a comprehensive guide on how to integrate the Model Context Protocol (MCP) with LangGraph agents using the `langchain-mcp-adapters` library. It includes installation instructions, example code for using MCP tools, and guidance on creating custom MCP servers. Additional resources for further reading on MCP are also provided.\n- [Understanding Context in LangGraph Agents](https://langchain-ai.github.io/langgraph/agents/context/): This page provides an overview of how to supply context to agents in LangGraph, detailing the three primary types: Config, State, and Long-Term Memory. It explains how to use these context types to enhance agent behavior, customize prompts, and access context in tools. Additionally, it includes code examples for implementing context in various scenarios.\n- [Understanding Memory in LangGraph for Conversational Agents](https://langchain-ai.github.io/langgraph/agents/memory/): This documentation page provides an overview of the two types of memory supported by LangGraph: short-term and long-term memory. It explains how to implement these memory types in conversational agents, including code examples and best practices for managing message history. Additionally, it covers the use of persistent storage and tools for enhancing memory functionality.\n- [Implementing Human-in-the-Loop in LangGraph](https://langchain-ai.github.io/langgraph/agents/human-in-the-loop/): This documentation page provides a comprehensive guide on how to implement Human-in-the-Loop (HIL) features in LangGraph, allowing for human review and approval of tool calls in agents. It covers the use of the `interrupt()` function to pause execution for human input, along with practical examples and code snippets. Additionally, it explains how to create a wrapper to add HIL capabilities to any tool seamlessly.\n- [Building Multi-Agent Systems](https://langchain-ai.github.io/langgraph/agents/multi-agent/): This page provides an overview of multi-agent systems, detailing how to create and manage them using supervisor and swarm architectures. It includes practical examples of implementing a flight and hotel booking assistant using the LangGraph libraries. Additionally, the page explains the concept of handoffs between agents, allowing for seamless communication and task delegation.\n- [Evaluating Agent Performance with LangSmith](https://langchain-ai.github.io/langgraph/agents/evals/): This page provides a comprehensive guide on how to evaluate the performance of agents using the LangSmith evaluations framework. It includes instructions on defining evaluator functions, utilizing prebuilt evaluators from the AgentEvals package, and running evaluations with specific datasets. Additionally, it covers different evaluation techniques, including trajectory matching and using LLMs as judges.\n- [Deploying Your LangGraph Agent](https://langchain-ai.github.io/langgraph/agents/deployment/): This page provides a comprehensive guide on how to deploy a LangGraph agent, including setting up a LangGraph app for both local development and production. It covers essential features, installation steps, and configuration requirements, along with instructions for launching the local server and utilizing the LangGraph Studio Web UI for debugging. Additionally, it offers links to further resources for deployment options.\n- [Agent Chat UI Documentation](https://langchain-ai.github.io/langgraph/agents/ui/): This page provides comprehensive guidance on using the Agent Chat UI for interacting with LangGraph agents. It covers setup instructions, features like human-in-the-loop workflows, and the integration of generative UI components. Users can find links to relevant resources and tips for customizing their chat experience.\n- [Overview of Agent Architectures in LLM Applications](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/): This page provides a comprehensive overview of various agent architectures used in large language model (LLM) applications, highlighting their control flows and functionalities. It discusses key concepts such as routers, tool-calling agents, memory management, and planning, along with customization options for specific tasks. Additionally, it covers advanced features like human-in-the-loop, parallelization, subgraphs, and reflection mechanisms to enhance agent performance.\n- [Understanding Workflows and Agents in LangGraph](https://langchain-ai.github.io/langgraph/tutorials/workflows/): This documentation page provides an in-depth overview of workflows and agents within LangGraph, highlighting their differences and use cases. It covers various patterns for building agentic systems, including setup instructions, building blocks, and advanced concepts like prompt chaining, parallelization, and routing. Additionally, it offers practical examples and code snippets to help users implement these workflows effectively.\n- [Understanding LangGraph: Core Concepts and Components](https://langchain-ai.github.io/langgraph/concepts/low_level/): This documentation page provides an in-depth overview of the core concepts of LangGraph, focusing on how agent workflows are modeled as graphs. It covers essential components such as States, Nodes, and Edges, and explains how they interact to create complex workflows. Additionally, it discusses graph compilation, message handling, and configuration options to enhance the functionality of your graphs.\n- [LangGraph Runtime Overview](https://langchain-ai.github.io/langgraph/concepts/pregel/): This page provides a comprehensive overview of the LangGraph runtime, specifically focusing on the Pregel execution model. It details the structure and functionality of actors and channels within the Pregel framework, along with examples of how to implement applications. Additionally, it introduces high-level APIs for creating Pregel applications using StateGraph and Functional API.\n- [Using the LangGraph API: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/how-tos/graph-api/): This documentation provides a detailed overview of how to utilize the LangGraph Graph API, covering essential concepts such as state management, node creation, and control flow. It includes practical examples for building sequences, branches, and loops, as well as advanced features like retry policies and async execution. Additionally, the guide offers insights into visualizing graphs and integrating with external tools.\n- [LangGraph Streaming System](https://langchain-ai.github.io/langgraph/concepts/streaming/): This page provides an overview of the streaming capabilities of LangGraph, enabling real-time updates for enhanced user experiences. It details the types of data that can be streamed, including workflow progress, LLM tokens, and custom updates. Additionally, it outlines various functionalities and modes available for streaming within the LangGraph framework.\n- [Streaming Outputs in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/streaming/): This documentation page provides an overview of how to utilize the streaming capabilities of LangGraph, including synchronous and asynchronous streaming methods. It covers various stream modes, such as updates, values, and custom data, along with examples of how to implement them in your graphs. Additionally, it discusses the integration of Large Language Models (LLMs) and how to handle streaming outputs effectively.\n- [LangGraph Persistence and Checkpointing](https://langchain-ai.github.io/langgraph/concepts/persistence/): This page provides an in-depth overview of the persistence layer in LangGraph, focusing on the use of checkpointers to save graph states at each super-step. It covers key concepts such as threads, checkpoints, state retrieval, and memory management, along with practical examples and code snippets. Additionally, it discusses advanced features like time travel, fault tolerance, and the integration of memory stores for cross-thread information retention.\n- [Understanding Durable Execution in LangGraph](https://langchain-ai.github.io/langgraph/concepts/durable_execution/): This page provides an overview of durable execution, a technique that allows workflows to save their progress and resume from key points. It details the requirements for implementing durable execution in LangGraph, including the use of persistence and tasks to ensure deterministic and consistent replay. Additionally, it covers how to handle pausing, resuming, and recovering workflows effectively.\n- [Implementing Memory in LangGraph for AI Applications](https://langchain-ai.github.io/langgraph/how-tos/persistence/): This documentation page provides a comprehensive guide on adding persistence to AI applications using LangGraph. It covers both short-term and long-term memory implementations, including code examples for managing conversation context and user-specific data. Additionally, it discusses the use of various storage backends and semantic search capabilities for enhanced memory management.\n- [Understanding Memory in AI Agents](https://langchain-ai.github.io/langgraph/concepts/memory/): This documentation page provides an in-depth overview of memory types in AI agents, focusing on short-term and long-term memory. It explains how these memory types can be implemented and managed within applications using LangGraph, including techniques for handling conversation history and storing memories. Additionally, it discusses the importance of memory in enhancing user interactions and the various strategies for writing and updating memories.\n- [Memory Management in LangGraph for AI Applications](https://langchain-ai.github.io/langgraph/how-tos/memory/): This page provides an overview of memory management in LangGraph, focusing on short-term and long-term memory functionalities essential for conversational agents. It includes detailed instructions on how to implement memory strategies such as trimming, summarizing, and deleting messages to optimize conversation tracking without exceeding context limits. Code examples are provided to illustrate the implementation of these memory management techniques.\n- [Human-in-the-Loop Workflows in LangGraph](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/): This page provides an overview of the human-in-the-loop (HIL) capabilities within LangGraph, highlighting how human intervention can enhance automated processes. It details key features such as persistent execution state and flexible integration points, along with typical use cases for validating outputs and providing context. Additionally, it outlines the implementation of HIL through specific functions and primitives.\n- [Implementing Human-in-the-Loop Workflows with Interrupts](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/add-human-in-the-loop/): This documentation page provides a comprehensive guide on using the `interrupt` function in LangGraph to facilitate human-in-the-loop workflows. It covers the implementation details, design patterns, and best practices for pausing graph execution to gather human input, as well as how to resume execution with that input. Additionally, it highlights common pitfalls and offers extended examples to illustrate various use cases.\n- [Understanding Breakpoints in LangGraph](https://langchain-ai.github.io/langgraph/concepts/breakpoints/): This page provides an overview of breakpoints in LangGraph, which allow users to pause graph execution at specific points for inspection. It explains how breakpoints utilize the persistence layer to save the graph state and how execution can be resumed after inspection. An illustrative example is included to demonstrate the concept visually.\n- [Using Breakpoints in Graph Execution](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/breakpoints/): This page provides a comprehensive guide on how to implement breakpoints in graph execution for debugging purposes. It covers the requirements for setting breakpoints, the difference between static and dynamic breakpoints, and includes code examples for both compile-time and run-time configurations. Additionally, it explains how to manage breakpoints in subgraphs.\n- [Time Travel Functionality in LangGraph](https://langchain-ai.github.io/langgraph/concepts/time-travel/): This page explains the time travel feature in LangGraph, which allows users to analyze and debug decision-making processes in non-deterministic systems. It outlines how to understand reasoning, debug mistakes, and explore alternative solutions by resuming execution from prior checkpoints. The functionality enables users to create new forks in the execution history for deeper insights.\n- [Using Time-Travel in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/time-travel/): This page provides a comprehensive guide on how to implement time-travel functionality in LangGraph. It outlines the steps to run a graph, identify checkpoints, modify graph states, and resume execution from specific checkpoints. Additionally, an example workflow is included to illustrate the process of generating and modifying jokes using LangGraph.\n- [Integrating Tools with AI Models](https://langchain-ai.github.io/langgraph/concepts/tools/): This page provides an overview of how AI models can interact with external systems using tool calling. It explains the concept of tools, their integration with chat models, and how to create or use prebuilt tools for various applications. Additionally, it highlights the importance of relevance in tool invocation and offers links to further resources and guides.\n- [Using Tools in LangChain](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/): This documentation page provides a comprehensive guide on how to create and utilize tools within the LangChain framework. It covers defining simple and customized tools, managing tool arguments, accessing configuration and state, and integrating tools with chat models and agents. Additionally, it discusses error handling and strategies for managing a large number of tools.\n- [Understanding Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/concepts/subgraphs/): This page provides an overview of subgraphs in LangGraph, explaining their role as encapsulated nodes within larger graphs. It discusses the benefits of using subgraphs, such as facilitating multi-agent systems and enabling independent team work. Additionally, it outlines the communication methods between parent graphs and subgraphs, detailing scenarios involving shared and different state schemas.\n- [Using Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/subgraph/): This guide provides an overview of how to effectively use subgraphs within LangGraph, including communication methods between parent graphs and subgraphs. It covers shared and different state schemas, setup instructions, and examples for implementing subgraphs in multi-agent systems. Additionally, it discusses persistence, state management, and streaming outputs from subgraphs.\n- [Understanding Multi-Agent Systems](https://langchain-ai.github.io/langgraph/concepts/multi_agent/): This page provides an in-depth overview of multi-agent systems, focusing on the architecture and benefits of using multiple independent agents to manage complex applications. It discusses various multi-agent architectures, including network, supervisor, and hierarchical models, as well as communication strategies and state management techniques for effective agent interaction.\n- [Building Multi-Agent Systems with LangGraph](https://langchain-ai.github.io/langgraph/how-tos/multi_agent/): This guide provides an overview of how to build multi-agent systems using LangGraph, focusing on the implementation of handoffs for agent communication. It covers the creation of independent agents, the use of handoffs to transfer control and data between agents, and examples of prebuilt multi-agent architectures. Additionally, it includes code snippets and best practices for managing agent interactions and state.\n- [Understanding the Functional API in LangGraph](https://langchain-ai.github.io/langgraph/concepts/functional_api/): This documentation page provides an overview of the Functional API in LangGraph, detailing its key features such as persistence, memory, and human-in-the-loop capabilities. It explains how to define workflows using the `@entrypoint` and `@", "metadata": {"file": "langgraph-llms.txt"}}
{"content": "task` decorators, along with examples and best practices for implementing workflows with state management and streaming. Additionally, it compares the Functional API with the Graph API, highlighting their differences and use cases.\n- [Functional API Documentation](https://langchain-ai.github.io/langgraph/how-tos/use-functional-api/): This page provides comprehensive guidance on using the Functional API, including creating workflows, handling parallel execution, and integrating with other APIs. It covers various features such as retry policies, caching, and human-in-the-loop workflows, along with practical examples. Additionally, it discusses memory management strategies for both short-term and long-term use cases.\n- [Overview of LangGraph Platform](https://langchain-ai.github.io/langgraph/concepts/langgraph_platform/): The LangGraph Platform is designed for developing, deploying, and managing long-running agent workflows with ease. This page outlines the platform's features, including streaming support, background runs, and memory management, which enhance the performance and reliability of agent applications. Additionally, it provides links to resources for getting started and deploying agents effectively.\n- [LangGraph Platform Quickstart Guide](https://langchain-ai.github.io/langgraph/tutorials/langgraph-platform/local-server/): This quickstart guide provides step-by-step instructions for running a LangGraph application locally. It covers prerequisites, installation of the LangGraph CLI, app creation, dependency installation, and launching the server. Additionally, it includes testing your application using the LangGraph Studio and API.\n- [LangGraph Platform Deployment Quickstart](https://langchain-ai.github.io/langgraph/cloud/quick_start/): This quickstart guide provides step-by-step instructions for deploying an application on the LangGraph Platform using GitHub. It covers prerequisites, repository creation, deployment procedures, and testing your application and API. Follow these steps to successfully set up and run your application in the LangGraph environment.\n- [Overview of LangGraph Platform Components](https://langchain-ai.github.io/langgraph/concepts/langgraph_components/): This page provides a comprehensive overview of the various components that make up the LangGraph Platform. It details the functionalities of each component, including the LangGraph Server, CLI, Studio, SDKs, and the control and data planes. Users can learn how these components work together to facilitate the development, deployment, and management of LangGraph applications.\n- [LangGraph Server Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_server/): This page provides an overview of the LangGraph Server, an API designed for creating and managing agent-based applications. It details the server versions, application structure, deployment components, and the use of assistants, persistence, and task queues. Additionally, it includes links to further resources and guides for effective deployment and usage.\n- [LangGraph Application Structure Guide](https://langchain-ai.github.io/langgraph/concepts/application_structure/): This page provides an overview of the structure of a LangGraph application, detailing the essential components such as the configuration file, dependencies, graphs, and environment variables. It includes examples of directory structures for both Python and JavaScript applications, as well as guidance on how to specify the necessary information for deployment. Additionally, it covers key concepts related to the configuration file and the role of dependencies and environment variables in the application.\n- [Setting Up a LangGraph Application with requirements.txt](https://langchain-ai.github.io/langgraph/cloud/deployment/setup/): This guide provides step-by-step instructions for configuring a LangGraph application for deployment using a requirements.txt file to manage dependencies. It covers essential topics such as specifying dependencies, defining environment variables, and creating the LangGraph configuration file. Additionally, it includes examples and tips for alternative setup methods.\n- [Setting Up a LangGraph Application with pyproject.toml](https://langchain-ai.github.io/langgraph/cloud/deployment/setup_pyproject/): This guide provides step-by-step instructions for configuring a LangGraph application using the `pyproject.toml` file for dependency management. It covers the necessary components, including specifying dependencies, environment variables, and defining graphs, along with examples and best practices. Additionally, it offers tips for alternative setups and links to further resources for deployment.\n- [Setting Up a LangGraph.js Application](https://langchain-ai.github.io/langgraph/cloud/deployment/setup_javascript/): This guide provides step-by-step instructions for configuring a LangGraph.js application for deployment on the LangGraph Platform or for self-hosting. It covers essential topics such as specifying dependencies, environment variables, defining graphs, and creating the necessary configuration file. By following this walkthrough, users will learn how to structure their application and prepare it for deployment.\n- [Customizing Your Dockerfile in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/custom_docker/): This page provides a guide on how to customize your Dockerfile by adding additional commands through the `langgraph.json` configuration file. It explains how to specify the `dockerfile_lines` key to include necessary dependencies, such as installing system packages and Python libraries. An example is provided to illustrate the process of integrating the Pillow library for image processing.\n- [LangGraph CLI Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_cli/): This page provides an overview of the LangGraph CLI, a command-line tool for building and running the LangGraph API server locally. It includes installation instructions, a list of core commands, and their descriptions to help users effectively utilize the CLI for development and deployment. For further details, users can refer to the LangGraph CLI Reference.\n- [LangGraph Studio Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/): This page provides an overview of LangGraph Studio, an IDE for visualizing, interacting with, and debugging agentic systems that utilize the LangGraph Server API. It outlines the prerequisites for using the studio, key features, and the two operational modes: Graph mode and Chat mode. Additionally, it includes links to further resources for getting started with LangGraph Studio.\n- [Getting Started with LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/studio/quick_start/): This page provides a comprehensive guide on how to connect and use LangGraph Studio with both deployed applications on the LangGraph Platform and local development servers. It includes instructions for installation, running the server, accessing the Studio UI, and debugging options. Additionally, troubleshooting tips and next steps for further exploration of LangGraph Studio features are also provided.\n- [Running Applications: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/cloud/how-tos/invoke_studio/): This page provides a detailed guide on how to submit a run to your application, covering both Graph and Chat modes. It includes instructions on specifying input, managing assistants, enabling streaming, and using breakpoints. Additionally, it offers tips for running applications from specific checkpoints in existing threads.\n- [Managing Assistants in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/studio/manage_assistants/): This page provides guidance on how to manage assistants within LangGraph Studio, including viewing, editing, and updating assistant configurations. It covers both Graph mode and Chat mode, detailing how to activate assistants and make changes to their settings. Users will learn how to navigate the interface to effectively manage their assistant configurations for graph runs.\n- [Managing Threads in Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/threads_studio/): This page provides a comprehensive guide on how to view and edit threads within the Studio application. It covers both Graph and Chat modes, detailing the steps to create new threads, view thread history, and edit thread states. Additionally, it includes links to related concepts for further learning.\n- [Modifying Prompts in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/iterate_graph_studio/): This page provides guidance on how to modify prompts within LangGraph Studio using two methods: direct node editing and the LangSmith Playground interface. It details the configuration options available for nodes, including `langgraph_nodes` and `langgraph_type`, along with examples for both Pydantic models and dataclasses. Additionally, it outlines the steps for editing prompts in the UI and utilizing the LangSmith Playground for testing LLM calls.\n- [Debugging LangSmith Traces in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/clone_traces_studio/): This guide provides step-by-step instructions for opening and debugging LangSmith traces in LangGraph Studio. It covers how to deploy threads and test local agents with remote traces, ensuring a seamless debugging experience. Additionally, it outlines the requirements for local agents and the process for cloning threads for local testing.\n- [How to Add Nodes to LangSmith Datasets](https://langchain-ai.github.io/langgraph/cloud/how-tos/datasets_studio/): This guide provides step-by-step instructions on how to add examples from nodes in the thread log to LangSmith datasets. It covers selecting threads, choosing nodes, and editing inputs/outputs before adding them to the dataset. Additionally, it includes links to further resources on evaluating intermediate steps.\n- [LangGraph SDK Documentation](https://langchain-ai.github.io/langgraph/concepts/sdk/): This page provides an overview of the LangGraph SDK, including installation instructions for both Python and JavaScript. It details the synchronous and asynchronous client options available for interacting with the LangGraph Server. Additionally, it offers links to further resources and references for the SDK.\n- [Integrating Semantic Search in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/semantic_search/): This guide provides step-by-step instructions on how to implement semantic search in your LangGraph deployment. It covers prerequisites, configuration of the store, and usage examples for searching memories and documents by semantic similarity. Additionally, it includes information on using custom embeddings and querying via the LangGraph SDK.\n- [Configuring Time-to-Live (TTL) in LangGraph Applications](https://langchain-ai.github.io/langgraph/how-tos/ttl/configure_ttl/): This guide provides detailed instructions on how to configure Time-to-Live (TTL) settings for checkpoints and store items in LangGraph applications. It covers the necessary configurations in the `langgraph.json` file, including strategies for managing data lifecycle and memory. Additionally, it explains how to combine TTL configurations and override them at runtime.\n- [LangGraph Authentication & Access Control Overview](https://langchain-ai.github.io/langgraph/concepts/auth/): This page provides a comprehensive guide to the authentication and authorization mechanisms within the LangGraph Platform. It explains the core concepts of authentication versus authorization, outlines default security models, and details the system architecture involved in user identity management. Additionally, it covers implementation examples for authentication and authorization handlers, along with common access patterns and supported resources.\n- [Custom Authentication Setup for LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/auth/custom_auth/): This guide provides step-by-step instructions on how to implement custom authentication in your LangGraph Platform application. It covers the necessary prerequisites, implementation details, configuration updates, and client connection methods. The guide is applicable to both managed and Enterprise self-hosted deployments.\n- [Documenting API Authentication in OpenAPI for LangGraph](https://langchain-ai.github.io/langgraph/how-tos/auth/openapi_security/): This guide provides instructions on how to customize the security schema for your LangGraph Platform API documentation using OpenAPI. It covers default security schemes for both LangGraph Platform and self-hosted deployments, as well as how to implement custom authentication. Additionally, it includes examples for OAuth2 and API key authentication, along with testing procedures.\n- [Managing Assistants in LangGraph](https://langchain-ai.github.io/langgraph/concepts/assistants/): This page provides an overview of how to create and manage assistants within the LangGraph Platform, which allows for separate configuration of agents without altering the core graph logic. It covers the prerequisites, configuration options, and versioning of assistants, highlighting their role in optimizing agent performance for different tasks. Additionally, it includes links to relevant API references and how-to guides for further assistance.\n- [Managing Assistants in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/): This documentation page provides a comprehensive guide on how to create, configure, and manage assistants using the LangGraph SDK and Platform UI. It includes code examples in Python and JavaScript, as well as instructions for creating new versions and using previous versions of assistants. Additionally, it covers the process of utilizing assistants in various environments.\n- [Understanding Threads in LangGraph](https://langchain-ai.github.io/langgraph/cloud/concepts/threads/): This page provides an overview of threads in the LangGraph framework, detailing how they accumulate the state of runs and the importance of checkpoints. It explains the process of creating threads and retrieving their current and historical states. Additionally, it offers links to further resources on threads, checkpoints, and the LangGraph API for managing thread states.\n- [Managing Threads in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/use_threads/): This documentation page provides a comprehensive guide on how to create, view, and inspect threads using the LangGraph SDK. It includes detailed instructions for creating empty threads, copying existing threads, and initializing threads with prepopulated states. Additionally, it covers how to list and inspect threads, including filtering and sorting options.\n- [Understanding Runs in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/runs/): This page provides an overview of what constitutes a run in the LangGraph Platform, including its input, configuration, and metadata. It also highlights the ability to execute runs on threads and offers links to the API reference for managing runs.\n- [Starting Background Runs for Your Agent](https://langchain-ai.github.io/langgraph/cloud/how-tos/background_run/): This guide provides step-by-step instructions on how to initiate background runs for your agent using Python, JavaScript, and CURL. It covers the setup process, checking current runs, starting new runs, and retrieving the final results. By following this documentation, users can efficiently manage long-running jobs within their applications.\n- [Running Multiple Agents on the Same Thread in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/same-thread/): This documentation page explains how to run multiple agents on the same thread using the LangGraph Platform. It provides step-by-step examples in Python, JavaScript, and CURL to create agents, run them on a thread, and demonstrate how the second agent can utilize the context from the first agent's responses. By following the examples, users can learn to effectively manage multiple agents and their interactions.\n- [Scheduling Cron Jobs with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/cron_jobs/): This page provides a comprehensive guide on how to schedule cron jobs using the LangGraph Platform. It includes setup instructions for different programming languages, examples of creating and deleting cron jobs, and details on managing stateless cron jobs. Users will learn how to automate tasks such as sending weekly emails without writing custom scripts.\n- [Guide to Stateless Runs in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/stateless_runs/): This page provides a comprehensive guide on how to implement stateless runs using the LangGraph Platform. It includes setup instructions for various programming languages, examples of streaming results, and methods for waiting for stateless results. Users will learn how to execute runs without maintaining persistent state, making their applications more efficient.\n- [Configurable Headers in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/configurable_headers/): This page provides guidance on how to configure headers dynamically in the LangGraph platform to modify agent behavior and permissions. It details how to include or exclude specific headers in the runtime configuration using the `langgraph.json` file. Additionally, it explains how to access these headers within your graph and offers an option to opt-out of configurable headers.\n- [Streaming in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/streaming/): This page provides an overview of streaming capabilities within the LangGraph Platform, detailing the various streaming modes available for LLM applications. It includes instructions for creating streaming runs, handling stateless runs, and joining active background runs. Additionally, code examples in Python, JavaScript, and cURL are provided to illustrate the implementation of these features.\n- [Streaming Outputs with LangGraph SDK](https://langchain-ai.github.io/langgraph/cloud/how-tos/streaming/): This documentation page provides detailed instructions on how to stream outputs from the LangGraph API server using the LangGraph SDK in Python, JavaScript, and cURL. It covers various streaming modes, including updates, values, and custom data, along with examples for each mode. Additionally, it explains how to handle subgraphs, debug information, and LLM tokens during streaming.\n- [Human-in-the-Loop Workflows in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/add-human-in-the-loop/): This page provides an overview of the human-in-the-loop (HIL) capabilities in LangGraph, allowing for human intervention in automated processes. It details the `interrupt` function, which pauses execution for human input, and includes examples in Python, JavaScript, and cURL for implementing HIL workflows. Additionally, it links to further resources for understanding and utilizing HIL features effectively.\n- [Using Breakpoints in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/human_in_the_loop_breakpoint/): This page provides an overview of how to set and use breakpoints in LangGraph to pause graph execution for inspection. It includes examples for setting breakpoints at compile time and run time in Python, JavaScript, and cURL. Additionally, it offers guidance on resuming execution after hitting a breakpoint.\n- [Using Time Travel in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/human_in_the_loop_time_travel/): This page provides a comprehensive guide on how to utilize the time travel functionality in LangGraph, allowing users to resume execution from previous checkpoints. It outlines the steps to run a graph, identify checkpoints, modify graph states, and resume execution. Additionally, the page includes code examples in Python, JavaScript, and cURL for practical implementation.\n- [Model Context Protocol (MCP) Endpoint Documentation](https://langchain-ai.github.io/langgraph/concepts/server-mcp/): This page provides comprehensive documentation on the Model Context Protocol (MCP) endpoint available in LangGraph Server. It covers the requirements for using MCP, how to expose agents as MCP tools, and includes examples for connecting with MCP-compliant clients in various programming languages. Additionally, it outlines session behavior, authentication, and instructions for disabling the MCP endpoint.\n- [Managing Double Texting in LangGraph](https://langchain-ai.github.io/langgraph/concepts/double_texting/): This page provides an overview of how to handle double texting scenarios in LangGraph, where users may send multiple messages before the first has completed. It outlines four strategies: Reject, Enqueue, Interrupt, and Rollback, each with links to detailed configuration guides. Prerequisites for implementing these strategies include having the LangGraph Server set up.\n- [Using the Interrupt Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/interrupt_concurrent/): This guide provides detailed instructions on how to utilize the `interrupt` option for double texting, allowing users to interrupt a prior run of a graph and start a new one. It includes setup instructions, code examples in Python, JavaScript, and CURL, as well as guidance on viewing run results and verifying the status of interrupted runs. Familiarity with double texting is assumed, and a link to a conceptual guide is provided for further understanding.\n- [Using the Rollback Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/rollback_concurrent/): This guide provides detailed instructions on how to utilize the `rollback` option in double texting, which allows users to interrupt a previous run and start a new one while permanently deleting the prior run from the database. It includes setup instructions, code examples in Python, JavaScript, and CURL, and demonstrates how to view run results and verify the deletion of the original run. Familiarity with double texting is assumed, and a link to a conceptual guide is provided for further reading.\n- [Using the Reject Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/reject_concurrent/): This guide provides an overview of the `reject` option in double texting, which prevents new runs of a graph from starting while an original run is still in progress. It includes setup instructions, code examples in Python, JavaScript, and CURL, and demonstrates how to handle errors when attempting to create concurrent runs. Additionally, it shows how to view the results of the original run after the rejection.\n- [Using the Enqueue Option for Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/enqueue_concurrent/): This guide provides an overview of the `enqueue` option for double texting, which allows interruptions to be queued and executed in the order they are received. It includes setup instructions, code examples in Python, JavaScript, and CURL for creating runs, and methods for viewing run results. Familiarity with double texting concepts is assumed, and a helper function for output formatting is also provided.\n- [Understanding Webhooks in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/webhooks/): This page provides an overview of webhooks and their role in enabling event-driven communication between LangGraph Platform applications and external services. It explains how to use the `webhook` parameter in various endpoints to trigger requests upon the completion of API calls. For further details, a link to a comprehensive how-to guide is also", "metadata": {"file": "langgraph-llms.txt"}}
{"content": "included.\n- [Using Webhooks with LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/how-tos/webhooks/): This documentation page provides a comprehensive guide on how to implement webhooks in the LangGraph Platform to receive updates after API calls. It includes details on supported endpoints, setup instructions for different programming languages, and examples of how to specify webhook parameters in API requests. Additionally, it covers security measures and testing tools for verifying webhook functionality.\n- [Scheduling Tasks with Cron Jobs on LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/cron_jobs/): This page provides an overview of how to use cron jobs on the LangGraph Platform to run assistants on a defined schedule. It explains the process of setting up a cron job, including specifying the schedule, assistant, and input. Additionally, it includes links to a how-to guide and API reference for further details.\n- [Scheduling Cron Jobs with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/cron_jobs/): This page provides a comprehensive guide on how to use cron jobs with the LangGraph Platform to automate graph executions on a schedule. It includes setup instructions for various programming languages, examples of creating and deleting cron jobs, and tips for managing stateless cron jobs. Users will learn how to efficiently schedule tasks without manual intervention, ensuring timely execution of automated processes.\n- [Adding Custom Lifespan Events in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/http/custom_lifespan/): This page provides a guide on how to implement custom lifespan events in your LangGraph Platform applications, specifically for Python deployments. It covers the initialization and cleanup of resources during server startup and shutdown using FastAPI. Additionally, it includes code examples and configuration steps to help you integrate these events into your application.\n- [Adding Custom Middleware to LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/http/custom_middleware/): This page provides a step-by-step guide on how to add custom middleware to your server when deploying agents to the LangGraph Platform. It covers the necessary code implementation using FastAPI, configuration settings in `langgraph.json`, and instructions for testing and deploying your application. Additionally, it offers links to related topics such as custom routes and lifespan events for further customization.\n- [Adding Custom Routes in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/http/custom_routes/): This page provides a step-by-step guide on how to add custom routes to your LangGraph platform application using a Starlette or FastAPI app. It includes instructions for creating a new app, configuring the `langgraph.json` file, and testing the server locally. Additionally, it explains how custom routes can override default endpoints and offers suggestions for further customization.\n- [LangGraph Deployment Options](https://langchain-ai.github.io/langgraph/concepts/deployment_options/): This page outlines the various deployment options available for the LangGraph Platform, including Cloud SaaS, Self-Hosted Data Plane, Self-Hosted Control Plane, and Standalone Container. Each option is described in detail, highlighting key features, management responsibilities, and compatibility. A comparison table is also provided to help users choose the best deployment strategy for their needs.\n- [LangGraph Data Plane Overview](https://langchain-ai.github.io/langgraph/concepts/langgraph_data_plane/): This page provides a comprehensive overview of the LangGraph Data Plane, detailing its components including the server infrastructure, listener application, and data management systems like Postgres and Redis. It also covers key features such as autoscaling, static IP addresses, and custom configurations for Postgres and Redis. Additionally, the page outlines telemetry, licensing, and tracing functionalities relevant to different deployment options.\n- [LangGraph Control Plane Overview](https://langchain-ai.github.io/langgraph/concepts/langgraph_control_plane/): This page provides a comprehensive overview of the LangGraph Control Plane, detailing its UI and API functionalities for managing LangGraph Servers. It covers deployment types, environment variables, database provisioning, and asynchronous deployment processes. Additionally, it highlights the integration with LangSmith for tracing projects.\n- [Cloud SaaS Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_cloud/): This page provides a comprehensive guide on deploying the LangGraph Server using the Cloud SaaS model. It outlines the roles of the control plane and data plane, detailing their functionalities and management. Additionally, it includes an architectural diagram to illustrate the deployment structure.\n- [Deployment Guide for LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/deployment/cloud/): This page provides a comprehensive guide on how to deploy applications to the LangGraph Platform using GitHub repositories. It covers prerequisites, steps for creating new deployments and revisions, managing deployment settings, and viewing logs. Additionally, it includes instructions for whitelisting IP addresses and modifying GitHub repository access.\n- [Self-Hosted Data Plane Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_self_hosted_data_plane/): This page provides an overview of the Self-Hosted Data Plane deployment option, which allows users to manage their data plane infrastructure while offloading control plane management to LangChain. It outlines the requirements, architecture, and supported compute platforms for deployment. Additionally, it includes important information regarding the beta status of this deployment option.\n- [Deploying a Self-Hosted Data Plane](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_data_plane/): This page provides a comprehensive guide on deploying a Self-Hosted Data Plane using Kubernetes and Amazon ECS. It outlines the prerequisites, setup steps, and configuration details necessary for a successful deployment. Additionally, it highlights the current beta status of this deployment option.\n- [Self-Hosted Control Plane Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_self_hosted_control_plane/): This page provides an overview of the Self-Hosted Control Plane deployment option, currently in beta. It outlines the requirements, architecture, and compute platforms supported for deploying the control and data planes in your cloud environment. Additionally, it includes important links and resources for managing your self-hosted infrastructure.\n- [Deploying a Self-Hosted Control Plane](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_control_plane/): This page provides a comprehensive guide on deploying a Self-Hosted Control Plane using Kubernetes. It outlines the prerequisites, setup steps, and configuration details necessary for a successful deployment. Additionally, it highlights the beta status of this deployment option and includes links to relevant resources for further assistance.\n- [Deploying LangGraph Server with Standalone Container](https://langchain-ai.github.io/langgraph/concepts/langgraph_standalone_container/): This page provides a comprehensive guide on deploying a LangGraph Server using the Standalone Container option. It outlines the architecture, supported compute platforms, and Enterprise server version features. Users will find essential information on managing the data plane infrastructure without a control plane.\n- [Deploying a Standalone Container with LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/standalone_container/): This documentation provides a comprehensive guide on deploying a standalone container for the LangGraph application. It covers prerequisites, environment variable configurations, and deployment methods using Docker and Docker Compose. Additionally, it includes instructions for deploying on Kubernetes using Helm.\n- [Scalability and Resilience of LangGraph Platform](https://langchain-ai.github.io/langgraph/concepts/scalability_and_resilience/): This page provides an overview of the scalability and resilience features of the LangGraph Platform. It details how the platform handles server and queue scalability, as well as the mechanisms in place for ensuring resilience during both graceful and hard shutdowns. Additionally, it covers the resilience strategies employed for Postgres and Redis to maintain service availability.\n- [LangGraph Platform Plans Overview](https://langchain-ai.github.io/langgraph/concepts/plans/): This page provides an overview of the different plans available for the LangGraph Platform, including Developer, Plus, and Enterprise options. Each plan offers varying deployment options, usage limits, and features tailored to different user needs. For detailed pricing and related resources, links to additional documentation are also included.\n\n# Examples\n\n- [Building an Agentic RAG System](https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/): This tutorial guides you through the process of creating a retrieval agent (RAG) system using LangChain and LangGraph. You will learn how to fetch and preprocess documents, create a retriever tool, and build an agentic RAG that intelligently decides when to retrieve information or respond directly to user queries. By the end, you'll have a functional system capable of semantic search and context-aware responses.\n- [Building a Multi-Agent Supervisor System](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/): This tutorial guides you through the process of creating a multi-agent supervisor system using specialized agents for research and math tasks. You will learn how to set up the environment, create individual worker agents, and implement a supervisor that orchestrates their interactions. By the end, you'll have a fully functional multi-agent architecture capable of handling complex queries.\n- [Building a SQL Agent with LangChain](https://langchain-ai.github.io/langgraph/tutorials/sql-agent/): This tutorial provides a step-by-step guide on how to create a SQL agent capable of answering questions about a SQL database. It covers the setup of necessary dependencies, configuration of a SQLite database, and the implementation of a prebuilt agent that interacts with the database to generate and execute queries. Additionally, it discusses customizing the agent for more control over its behavior.\n- [Custom Run ID, Tags, and Metadata for LangSmith Graph Runs](https://langchain-ai.github.io/langgraph/how-tos/run-id-langsmith/): This guide provides instructions on how to pass a custom run ID and set tags and metadata for graph runs in LangSmith. It covers prerequisites, configuration options, and includes code examples for setting up and running a graph with LangGraph. Additionally, it explains how to view and filter traces in the LangSmith platform.\n- [Custom Authentication Setup for Chatbots](https://langchain-ai.github.io/langgraph/tutorials/auth/getting_started/): This tutorial guides you through the process of setting up custom authentication for a chatbot using the LangGraph platform. You will learn how to implement token-based security to control user access, starting with a basic example and preparing for more advanced authentication methods in future tutorials. By the end, you'll have a functional chatbot that restricts access to authenticated users.\n- [Implementing Private Conversations in Chatbots](https://langchain-ai.github.io/langgraph/tutorials/auth/resource_auth/): This tutorial guides you through extending a chatbot to enable private conversations for each user by implementing resource-level access control. You'll learn how to add authorization handlers to ensure users can only access their own threads and test the functionality to confirm proper access restrictions. Additionally, the tutorial covers scoped authorization handlers for more granular control over resource access.\n- [Integrating OAuth2 Authentication with Supabase](https://langchain-ai.github.io/langgraph/tutorials/auth/add_auth_server/): This tutorial guides you through replacing hard-coded tokens with real user accounts using OAuth2 for secure authentication in your LangGraph application. You'll learn how to set up Supabase as your identity provider, implement token validation, and ensure proper user authorization. By the end, you'll have a production-ready authentication system that allows users to securely access their own data.\n- [Rebuilding Graphs at Runtime in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/graph_rebuild/): This guide explains how to rebuild your graph at runtime with different configurations in LangGraph. It covers the necessary prerequisites, how to define graphs, and the steps to modify your graph-making function for dynamic behavior based on user input. Additionally, it provides examples of both static and dynamic graph configurations.\n- [Interacting with RemoteGraph in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/use-remote-graph/): This documentation page provides a comprehensive guide on how to interact with a LangGraph Platform deployment using the RemoteGraph interface. It covers the initialization of RemoteGraph, invoking the graph both asynchronously and synchronously, and utilizing it as a subgraph. Additionally, it includes code examples in Python and JavaScript to facilitate understanding and implementation.\n- [Deploying Agents on LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/autogen-langgraph-platform/): This page provides a comprehensive guide on how to deploy agents like AutoGen and CrewAI using the LangGraph Platform. It covers the necessary setup, agent definition, and wrapping the agent in a LangGraph node for deployment. Additionally, it highlights the benefits of using LangGraph for scalable infrastructure and memory support.\n- [Integrating LangGraph with React: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/cloud/how-tos/use_stream_react/): This documentation provides a detailed guide on how to integrate the LangGraph platform into your React applications using the `useStream()` hook. It covers installation, key features, example implementations, and customization options for building chat experiences. Additionally, it includes advanced topics such as event handling, TypeScript support, and managing conversation threads.\n- [Implementing Generative User Interfaces with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/generative_ui_react/): This documentation provides a comprehensive guide on how to implement Generative User Interfaces (Generative UI) using the LangGraph platform. It covers prerequisites, step-by-step tutorials for defining UI components, sending them in graphs, and handling them in React applications. Additionally, it includes how-to guides for customizing components and managing UI state effectively.\n\n# Resources\n\n- [LangGraph FAQ](https://langchain-ai.github.io/langgraph/concepts/faq/): This FAQ page provides answers to common questions about LangGraph, an orchestration framework for complex agentic systems. It covers topics such as the differences between LangGraph and LangChain, performance impacts, open-source status, and compatibility with various LLMs. Additionally, it outlines the distinctions between LangGraph and LangGraph Platform, including features and deployment options.\n- [Getting Started with LangGraph Templates](https://langchain-ai.github.io/langgraph/concepts/template_applications/): This page provides an overview of open source reference applications known as templates, designed to help users quickly build applications with LangGraph. It includes installation instructions for the LangGraph CLI, a list of available templates with their descriptions, and guidance on creating and deploying a new LangGraph app. Users can find links to repositories for each template and next steps for customizing their applications.\n- [Guide to Using llms.txt and llms-full.txt for LLMs](https://langchain-ai.github.io/langgraph/llms-txt-overview/): This page provides an overview of the `llms.txt` and `llms-full.txt` formats, which facilitate access to programming documentation for large language models (LLMs) and agents. It outlines the differences between the two formats, usage instructions via an MCP server, and best practices for integrating these files into integrated development environments (IDEs). Additionally, it highlights considerations for managing large documentation files effectively.\n- [Community Agents for LangGraph](https://langchain-ai.github.io/langgraph/agents/prebuilt/): This page provides a list of community-built libraries that extend the functionality of LangGraph. Each entry includes the library name, GitHub URL, a brief description, and additional metrics like weekly downloads and stars. Additionally, it outlines how to contribute your own library to the LangGraph documentation.\n- [LangGraph Error Reference Guide](https://langchain-ai.github.io/langgraph/troubleshooting/errors/index/): This page serves as a comprehensive reference for resolving common errors encountered while using the LangGraph platform. It includes a list of error codes and links to detailed guides for troubleshooting specific issues. Users can find solutions for errors related to graph recursion, concurrent updates, node return values, and more.\n- [Handling Recursion Limits in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/GRAPH_RECURSION_LIMIT/): This page provides guidance on managing recursion limits in LangGraph's StateGraph. It explains how to identify potential infinite loops in your graph and offers solutions for increasing the recursion limit when working with complex graphs. Additionally, it includes code examples to illustrate the concepts discussed.\n- [Handling INVALID_CONCURRENT_GRAPH_UPDATE in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_CONCURRENT_GRAPH_UPDATE/): This page explains the INVALID_CONCURRENT_GRAPH_UPDATE error that occurs in LangGraph when multiple nodes attempt to update the same state property concurrently. It provides an example of how this error can arise and offers a solution by using a reducer to combine values from parallel node executions. Additionally, troubleshooting tips are included to help resolve this issue.\n- [Handling Invalid Node Return Values in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_GRAPH_NODE_RETURN_VALUE/): This page provides guidance on the error encountered when a LangGraph node returns a non-dict value. It includes an example of incorrect node implementation and the resulting error message. Additionally, troubleshooting tips are offered to ensure that all nodes return the expected dictionary format.\n- [Handling Multiple Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/MULTIPLE_SUBGRAPHS/): This page discusses the limitations of calling multiple subgraphs within a single LangGraph node when checkpointing is enabled. It provides troubleshooting tips to resolve related errors, including suggestions for compiling subgraphs without checkpointing and using the Send API for graph calls.\n- [Handling INVALID_CHAT_HISTORY Error in create_react_agent](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_CHAT_HISTORY/): This page provides an overview of the INVALID_CHAT_HISTORY error encountered in the create_react_agent function when a malformed list of messages is passed. It outlines the potential causes of the error and offers troubleshooting steps to resolve it. Users can learn how to properly invoke the graph and manage tool calls to avoid this issue.\n- [Handling INVALID_LICENSE Error in LangGraph Platform](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_LICENSE/): This page provides guidance on troubleshooting the INVALID_LICENSE error encountered when starting a self-hosted LangGraph Platform server. It outlines the scenarios in which this error may occur and offers solutions based on different deployment types. Additionally, it includes steps to verify the necessary credentials for successful deployment.\n- [LangGraph Studio Troubleshooting Guide](https://langchain-ai.github.io/langgraph/troubleshooting/studio/): This page provides troubleshooting solutions for common connection issues encountered in LangGraph Studio, particularly with Safari and Brave browsers. It also addresses potential graph edge issues and offers methods to define routing paths for conditional edges. Users can find step-by-step instructions for resolving these issues using Cloudflare Tunnel and browser settings.\n- [LangGraph Case Studies](https://langchain-ai.github.io/langgraph/adopters/): This page provides a comprehensive list of companies that have successfully implemented LangGraph, showcasing their unique use cases and the benefits they have achieved. Each entry includes links to detailed case studies or blog posts for further reading. If your company uses LangGraph, you are encouraged to share your success story to contribute to this growing collection.", "metadata": {"file": "langgraph-llms.txt"}}
